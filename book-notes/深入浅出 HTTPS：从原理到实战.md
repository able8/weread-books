## 深入浅出 HTTPS：从原理到实战
> 虞卫东

### 序1

2017年1月9日微信上线小程序后，要求开发者的所有服务端请求必须为HTTPS；同时Google已调整搜索引擎算法，让采用HTTPS的网站在搜索结果中排名更靠前，并宣布从2018年7月开始所有的HTTP网站将标记为“不安全”。是否有必要将系统升级到HTTPS，答案显而易见！

### 1.3 网络模型

TCP/IP是标准的互联网网络协议，没有该协议就没有互联网，互联网上的终端必须配置TCP/IP才能进行通信。

任何协议都是一种标准，标准的含义就是通信双方需要遵循相同的规则，才能互相协作。想象两个人互相打电话，拨打电话的人首先要知道对方的手机号（IP地址），然后拨打电话确保连接上对方（TCP），通过IP选择一条最优的传输路径，最终应用层数据（人的语言）通过终端（网卡）、网络设备（电话线）传输给对方。

TCP/IP有两个最大的特点，分别是分层和封包/拆包机制。TCP/IP对网络进行了抽象，共划分为四层，每一层的特点不同，完成各自的任务。分层的好处就是清晰描述了每一层的职责，当网络应用程序出现问题后，能够快速定位到是哪一层出现问题并予以解决。

传输层中通过端口来区分服务，通过IP地址和端口号才能构建一条传输通道，对于HTTP来说，服务器端口号默认是80，而客户端的端口是随机产生的。

传输层主要有TCP和UDP, TCP能够保证数据正确地到达，一旦出现错误，会有一系列处理机制，比如重发和校验机制，保证数据正确地传输到对端。HTTP构建在TCP之上，在连接阶段，TCP使用三次握手机制确保可靠传输。

UDP的优点就是性能高，减少了很多开销。

网络层主要是IP这个协议，客户端和服务器传输的时候，会经过很多节点，IP就是选择一条最优的路径。每个终端上都有一张路由表，路由表负责将数据传输到下一个节点，下一个节点再传输到下下个节点，最终到达目的地址。

只有链路层才是实体设备，包括光纤、网卡等设备。基于这些设备，数据最终才能到达终端。

接下来简单描述封包/拆包机制，对于客户端请求来说，传输层接收到应用层消息后，在HTTP数据包前面增加TCP包头，然后发送给网络层；网络层在TCP数据包前面加上IP包头发送给链路层；链路层在IP数据包前面加上以太网包头；最终服务器接收到完整的数据包。

然后服务器进行拆包：首先在网络层去除链路层包头；在传输层去除IP包头；在应用层去除TCP包头；最终得到完整的HTTP应用层数据。

TCP/IP需要通过Socket接口提供自身的能力，或者说Socket对TCP/IP进行了封装。有了Socket API接口，开发者并不需要深入理解TCP/IP就可以开发各类应用，这也是协议的好处之一。

### 1.4 协议安全分析

HTTP在设计之初根本没有考虑安全问题，它的设计目的是数据传输和共享。

HTTP本身传递的是明文，不会加密这些信息，只要攻击者能够获取这些明文，用户的隐私就完全暴露了。HTTP是基于TCP/IP的，TCP/IP的特点也决定了HTTP数据很容易被截获，网络传输过程中，路由策略决定HTTP数据会通过很多节点设备，节点很轻松就能截获明文数据，由于数据没有加密，很容易理解其含义。

HTTP头部却没有加密，而头部信息泄露也是安全问题之一。◎应用语言可以对消息加密，但浏览器接收到消息的时候，并不知道如何解密消息，这种方案至少在Web应用上没有可行性，因为违反了HTTP标准。

虽然TCP能够确保通信双方正确地传输数据，但是在HTTP应用中，客户端和服务器并不能确认对方的身份，在HTTP标准中，没有校验对端身份的标准。

HTTP数据在传输过程中，会经过很多节点，这些节点都可以修改原始数据，而对于客户端和服务器来说，没有任何技术来确保接收的数据就是发送者发送的原始数据。

篡改数据也叫作中间人攻击。比如ISP插入广告的例子，如果有一种机制能够让浏览器知晓数据已经被篡改，那么浏览器就可以告知用户危险，并中断本次请求。

### 1.5 Web应用安全

这里以常见的XSS攻击方式进行说明，XSS就是利用应用程序的漏洞，诱使用户触发恶意代码，从而自动发送恶意的HTTP请求至服务器，造成自动攻击。

◎攻击者发现一个博客系统存在漏洞，发表文章的时候，服务器没有转义或者过滤数据。

浏览器就会下载并置执行attack.js文件，由于该文件包含了恶意代码，就可以进行攻击。

            var cookie = encodeURIComponent(document.cookie)￼
￼

◎将用户www.example.com主机下的所有Cookie信息发送给攻击者。
◎自动以正常用户的身份生成一篇文章，而这篇文章包含同样的攻击代码。

### 2.1 对于密码学的认知

密码学原理是公开的，在工程上需要实现各种算法，最著名的就是OpenSSL项目，包括了底层密码库和命令行工具，大部分Linux发行版都预装了OpenSSL库。

### 2.3 Hash算法

每个下载页面会标识出文件对应的MD5值（MD5是一种Hash算法），用户完成文件下载后，为了避免该文件被攻击者篡改（比如被替换为一个木马文件），可以手动计算下载文件的MD5值，一旦该值和下载页面标识的MD5值是一致的，就可以放心使用。

考虑到Hash算法的一些特性，系统可以计算出口令的摘要值，然后存放到数据库中。采用这种解决方案的原理就是摘要值是很逆向的，即使数据库泄露，攻击者也无法通过口令的摘要值计算出原始口令，攻击者很难伪造用户进行攻击。

SHA（Secure Hash Algorithms）算法是美国国家标准与技术研究院（NIST）指定的算法，SHA算法不是一个算法，而是一组算法，主要分为三类算法。
（1）SHA-1
SHA-1算法类似于MD5算法，输出的长度固定是160比特。
目前SHA-1算法在严谨的加密学中已经被证明是不安全的，但是在实际应用过程中不并代表就有安全问题，在现实世界中要构造出碰撞还是非常困难的，需要经过大量的运算，不过还是尽量使用SHA-2类的Hash算法。

在Git中使用SHA-1是为了保证数据的完整性而非机密性。

SHA-2算法是目前建议使用的Hash算法，截至目前是安全的，主要有四种算法，分别是SHA-256、SHA-512、SHA-224、SHA-384，输出的长度分别是256比特、512比特、224比特、384比特。

### 2.4 对称加密算法

在密码学中，用于数据加密的算法主要有两种，分别是对称加密算法（Symmetric-key Algorithms）和非对称加密算法（Asymmetrical Cryptography）。

### 2.5 消息验证码

很多情况下，传递的消息没有必要加密，只要确保消息是完整且没有被篡改即可。

核心的观点就是加密算法不能提供完整性，加密的同时必须引入MAC算法避免消息被篡改。

ChaCha20-Poly1305是谷歌发明的一种算法，使用ChaCha20流密码算法进行加密运算，使用Poly1305算法进行MAC运算。

### 2.6 公开密钥算法

公开密钥算法（Public Key Cryptography），也称为非对称加密算法（Asymmetrical Cryptography），公开密钥算法不是一个算法而是一组算法，如果公开密钥算法用于加密解密运算，习惯上称为非对称加密算法。

相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。

公开密钥算法最重要和最广泛使用的算法就是RSA算法，

### 3.1 TLS/SSL协议综述

TLS（Transport Layer Security）协议，也可能听说过SSL（Secure Sockets Layer）协议，在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版，本书使用TLS/SSL协议代表TLS协议或者SSL协议。

网景公司为了解决HTTP的安全问题，1994年创建了SSL协议，作为浏览器的一个扩展，主要应用于HTTP。

微软为这个新协议取名TLS v1.0，目前比较稳定的版本是TLS v1.2，本书主要以这个版本讲解，当然TLS v1.3也发布了，读者在学习的时候可以比较这两个版本的差异。

TLS/SSL协议位于应用层协议和TCP之间，构建在TCP之上，由TCP协议保证数据传输的可靠性，任何数据到达TCP之前，都经过TLS/SSL协议处理。

对于应用层协议来说，它无须过多改变，引入TLS/SSL协议即可保证数据机密性和完整性。任何应用层协议（HTTP、SMTP、FTP、其他自定义应用层协议）都可以结合TLS/SSL协议。

TLS/SSL协议一般构建在TCP之上，也可以构建在UDP之上，称为DTLS（Datagram Transport Layer Security）协议，DTLS协议在Web中使用得比较少。

◎效率：解决方案必须是高效的，TLS/SSL协议涉及了很多密码学算法的运算，增加了通信延时和机器负载，这也遭到了很多人的诟病，但TLS/SSL协议发展到现在，有一些新的技术和解决方案在逐步提升TLS/SSL协议的效率。

### 3.2 TLS/SSL协议背后的算法

公开密钥算法中，所有的网络通信都会存在中间人攻击，这是务必要记住的一点，在HTTPS协议中必须引入PKI技术解决身份验证的问题，PKI技术的核心就是证书。

### 3.3 HTTPS总结

握手层在加密层的上层，握手层提供加密层所需要的信息（密钥块），对于一个HTTPS请求来说，HTTP消息在没有完成握手之前，是不会传递给加密层的，一旦握手层处理完毕，最终应用层所有的HTTP消息交由加密层进行加密。

客户端和服务器端交换一些信息，比如协议版本号、随机数、密码套件（密码学算法组合）等，经过协商，服务器确定本次连接使用的密码套件，该密码套件必须双方都认可，客户端通过服务器发送的证书确认服务器身份后，双方开始密钥协商，最终双方协商出预备主密钥、主密钥、密钥块，有了密钥块，代表后续的应用层数据可以进行机密性和完整性保护了，接下来由加密层处理。

握手层在完成握手之前客户端和服务器端需要经过多个来回才能握手完成，这也是TLS/SSL协议缓慢的原因，增加了网络延迟。

握手这个称呼很形象，客户端和服务器端互相传数据之前，需要互相协商，达成一致后才能进行数据的加密和完整性处理，那么握手包含哪些关键步骤和概念呢？

客户端在进行密钥交换之前，必须认证服务器的身份，否则就会存在中间人攻击

能自己证明自己，所以需要通过CA机构来进行认证，认证的技术解决方案就是签名的数字证书。证书中会说明CA机构采用的数字签名算法，客户端获取到证书后，会采用相应的签名算法进行验证，一旦验证通过，则表示客户端成功认证了服务器端的身份。

明白证书的作用，即为了避免中间人攻击，客户端需要对服务器发送的证书进行认证，最终从证书中获取服务器实体的公钥。

客户端和服务器端必须协商出一个双方都能接受的协议版本，确保在同样的标准下进行握手。如果服务器端强制使用TLS v1.2版本，而客户端不支持该版本，那么双方无法完成TLS/SSL协议握手。

客户端的运行环境是无法预知的，有各种各样的操作系统、操作系统版本、浏览器、浏览器版本，比如客户端可能不支持HMAC-SHA256算法，在这种情况下，客户端和服务器端必须协商，协商出双方都支持的HMAC算法。

◎客户端和服务器端选择密码套件的基本原则就是优先级，从安全角度看应该由服务器决定协商出的最终密码套件。

客户端和服务器端的OpenSSL库都包含了很多的密码套件，可以使用OpenSSL命令行工具显示客户端或服务器端支持的密码套件：

◎客户端将发送和接收到的所有握手消息组合在一起，然后计算出摘要数据，握手层使用密钥块对摘要数据进行加密和完整性保护，然后发送给服务器。
◎服务器接收到验证消息后，使用加密块解密出摘要数据。
◎紧接着服务器自行计算发送和接收的所有握手消息，再计算出消息的摘要数据，如果摘要数据和解密出的摘要数据相同，代表客户端发送的消息没有被篡改。

### 3.4 实施HTTPS网站的必备条件

◎向免费的CA机构申请证书，最著名的免费CA机构就是Let's Encrypt，在第7章会重点讲解Let's Encrypt。
◎生成自签名的证书，简单地说自签名证书就是服务器实体自己生成的证书，浏览器不会信任自签名证书，后续章节会描述。

◎服务器实体信息，比如服务器的主机名、服务器公钥。
◎CA机构的信息，比如CA机构数字签名算法标识符、签名值。

服务器实体自行生成一对密钥对，基于密钥对生成CSR文件，然后向CA机构发送CSR请求申请证书。服务器实体获取CA机构签发的证书后，需要和密钥对一起保存并部署，密钥对的私钥避免泄露。

HTTPS只是保证某个连接上请求数据的安全性，但Web页面由很多元素构成，主页面仅仅支持HTTPS是不够的，所有引用的元素也必须支持HTTPS，否则就会引发Web安全风险，接下来通过一个例子来描述非全站HTTPS策略带来的风险。

◎恰好拦截的请求包含了Cookie验证信息，表示被拦截的用户具备登录权限，可以进行很多管理操作。
◎由于Cookie是明文的，攻击者将Cookie内容保存到攻击者计算机的Cookie文件中。

总结，为保证Web应用的绝对安全，应该全面实施全站HTTPS策略，主要包括：
◎网站涉及的域名必须都配置证书，并启用HTTPS。
◎网站引用的所有元素，必须支持HTTPS。
◎暴露在互联网上的HTTP URL地址，比如来自搜索引擎的HTTP请求，必须重定向到HTTPS请求上。

### 3.5 从用户的角度看HTTPS

S/SSL握手失败
浏览器访问HTTPS网站的时候，在握手阶段可能会存在错误，比如证书的有效期过期、证书是自签名证书、客户端和服务器端无法协商出一致的密码套件，遇到类似的情况，浏览器会出现一个错误页面，告知用户存在的问题。

从技术角度看，该图标表示：
◎该页面使用的是HTTPS。
◎TLS/SSL协议握手失败。
◎浏览器不能确认服务器的真实身份。

如果继续访问，用户必须明白：
◎用户自行确认了该证书的正确性，即确认了服务器的真实身份。
◎用户所有传输的数据具备机密性和完整性，但是可能会遇到中间人攻击。
用户如果继续访问HTTPS网站，会出现如图3-10所示的警示图标。
￼

为了绝对的安全，网站必须实施全站HTTPS策略，如果某个HTTPS页面引用了非HTTPS元素，则代表页面出现了混合内容。一个HTTPS页面如果加载了混合内容，就代表该页面是不安全的，可能遭遇各类Web攻击，比如XSS攻击。

### 4.1 部署HTTPS的疑惑

即使网站本身没有很重要的数据，但是HTTP网站很容易被劫持，用户访问的页面可能被插入广告，影响用户的体验；同时用户可能仅仅浏览了网站的几个HTTP页面，攻击者就会了解用户的浏览行为，隐私毫无保障。

如果私钥泄露了，必须快速撤销证书并重新签发；企业一旦增加域名，还需要更新原有证书。这些过程都是人工干预的，需要有专门的人员负责和CA机构沟通

Let's Encrypt是一个免费CA机构，其签发和管理证书的过程都是自动化的，相对来说不用人工干预，证书管理非常方便，第7章会重点讲解。

私钥和证书需要一起部署，相对于证书来说，更需要确保私钥的安全性。

证书和私钥是一一对应的，必须协同保存，需要安全、规范的管理，核心员工一旦离职，需要立刻更新私钥和证书。

而对于HTTPS网站来说，证书和域名息息相关，从域名的角度来看，证书可以包含多种类型：
◎单域名证书
◎泛域名证书
◎SAN域名证书
◎SAN、泛域名混合证书

而对于中大型公司来说，不仅仅有Web服务器，还有CDN、负载均衡、反向代理等服务器，在何种设备上部署证书及私钥涉及网络架构和应用架构的变化，需要考虑合理性，尤其是要评估安全性

如果使用第三方HTTPS CDN服务，需要将证书和私钥部署到第三方CDN的服务器上，是很不安全的一种做法。

总体上来说，部署HTTPS网站确实有一定的复杂性，也需要有专职的人员去维护，并且打破了原有的网络架构和应用架构，需要技术人员去适应这个变化，但长期来看，这是有好处的。而为了进行智能化的管理，一个企业部署HTTPS网站应该有完善的流程和工具。

◎HTTPS会涉及密码学运算，设备需要消耗更多的CPU计算能力。
这两点会导致服务器的性能和并发能力下降，而为了弥补损失，必然扩容更多的设备，从而提高了设备成本。

大部分HTTPS CDN产商会按照请求次数额外计费，这其实是一笔不小的支出。参考国内的CDN服务，每一万次HTTPS请求相比HTTP请求来说，成本大约增加0.1元，这可能会影响一些企业部署HTTPS网站。

第一是握手阶段，为完成握手，客户端和服务器会经过几个来回协商，在这个阶段，虽然双方传递的消息数据量不大，但带来了延迟，而延迟是性能最关键的因素，由于有延迟，服务器一直会等待，整个服务器的吞吐能力会下降，从而导致服务器处理效率的下降，服务器的利用率降低。而对于客户端来说，由于有延迟，用户的等待时间加长，影响用户体验，等同于性能下降。

◎HTTPS CPU的消耗占CPU总消耗的比例小于1%!。(MISSING)
◎每个网络连接占用的内存也仅仅是10 KB，额外带来的网络负载小于2%!。(MISSING)

### 4.2 部署HTTPS的必要性

HTTP/2是下一代的HTTP，而为了构建HTTPS/2必须先支持HTTPS, HTTP/2带来的扩展性和性能足够抵消HTTPS带来的消耗。

作为全球最大的手机厂商苹果公司，为了保证用户的安全，也要求开发者在调用资源的时候必须切换到HTTPS上，该规定非常有杀伤力，相信大部分企业会进一步重视HTTPS的存在。

### 5.1 HTTPS网站构建分析

为了绝对的安全，务必实施全站HTTPS策略，而实施全站HTTPS策略，重要的就是处理混合内容以及处理暴露在互联网上的HTTP URL地址，有多种处理策略，包括301重定向、HSTS、CSP策略，需要综合使用，每种解决方案都有优缺点。

### 5.2 获取证书和密钥对

自建证书是自己签发的（表示用户就是一个CA机构），浏览器一般不会集成私有CA机构的根证书，从中也可以看出，即使是具备一定规模的CA机构想将根证书集成到各个浏览器中也并不容易。

由于浏览器没有集成自签名证书的根证书，当浏览器发现一张自签名证书，并不会立刻中断TLS/SSL握手，会提示用户该证书可能是伪造的，存在中间人攻击可能性，用户可以选择信任该证书或者拒绝该证书，一旦拒绝该证书，则整个握手失败，如果用户信任该证书，则进行后续完整的TLS/SSL握手，和正常的握手并无两样，也就是说用户一旦信任自签名证书，后续的数据通信也是处于加密保护的。

企业内部系统的用户一般运行在同一个局域网下，由防火墙保护，风险相对可控，当浏览器提示用户自签名证书存在风险时，用户可以选择信任自签名证书，等同于访问了一个HTTPS网站。


Let's Encrypt首先是一个CA机构，得到了很多大公司的支持，兼容性非常不错，同时它定义了ACME协议，将管理证书的流程进行了标准化、自动化，不用人工管理。

最重要的两个文件是fullchain.pem（完整证书链）和privkey.pem（私钥）。

需要提醒的是，webroot插件为了校验申请者的身份，申请者必须在运行Certbot客户端的服务器上启动HTTP服务，主机对应的目录是/usr/nginx/web（也就是-w参数指定的目录）。

### 5.4 测试HTTPS

测试某个网站是否支持HTTPS, --verbose参数能够了解详细的信息，包括TLS/SSL握手的详细信息：

### 5.5301重定向

通过301规则强制用户访问HTTPS的网站。为了支持301重定向，修改Web服务器的配置，以Nginx服务器为例，修改/etc/nginx/sites-enabled/default文件，

rewrite     ^ https://$server_name;￼

一旦服务器接收到HTTP请求，不管请求的URL地址是什么，一律将原有地址重定向到HTTPS网站首页。

HTTP GET请求可以进行301重定向，而HTTP POST接口无法进行301重定向。

### 6.1 X.509标准和PKI

PKI（Public Key Infrastructure，称为公钥基础设施）是一个集合体，由一系列的软件、硬件、组织、个体、法律、流程组成，主要目的就是向客户端提供服务器身份认证（服务器也可以认证客户端的身份，本书主要讲解HTTPS服务器的身份认证），认证的基础就是必须找到一个可信的第三方组织，认证的技术方案就是数字签名技术。第三方组织能够使用数字签名技术管理证书，包括创建证书、存储证书、更新证书、撤销证书。

### 6.2 证书

DV（Domain Validated）证书是最常见的一种证书类型，比如Let's Encrypt只会签发DV证书，申请证书的CSR请求会包含域名信息，CA机构获取CSR请求后，从中取出域名，校验域名的所有权，如果域名所有者就是证书申请者，代表身份审核通过，申请者有权申请该域名（包含子域名）对应的证书。

### 6.3 证书链

fullchain.pem文件包含了cert.pem和chain.pem文件的内容，构成了完整的证书链。

通过Nginx或者Apache服务器配置证书的时候，需要正确配置证书链，也就是fullchain.pem文件，配置的时候并不包含根证书，根证书预嵌入浏览器中。

### 7.1 Let's Encrypt

Let's Encrypt是一个免费的机构，没有太多的人力和精力去处理证书的申请、签发、更新、撤销。它设计了一个证书管理的标准协议ACME，通过该协议可以实现各种客户端代理（Agent），由客户端代理来向Let's Encrypt申请和撤销证书，整个过程基本上不用人工干预，极大简化了证书管理的流程。

传统CA机构都是通过邮件的方式和服务器实体沟通，签发的证书也通过邮件或者其他形式发布，很容易受到攻击。同时传统CA机构为了方便，服务器实体申请证书的时候，CA机构会同时生成服务器实体的密钥对和证书，从安全的角度来看，密钥对的私钥不应该被CA机构保存。

而Let's Encrypt设计的ACME协议充分考虑了安全性，客户端代理和Let's Encrypt之间的通信都是密码学保护的，客户端代理负责生成CSR文件和密钥对，Let's Encrypt并不知道密钥对的私钥。

Let's Encrypt作为一个CA机构，成立的时间并不长，大部分浏览器或者操作系统并没有将Let's Encrypt的根证书嵌入到可信任根证书列表中。

如果某张证书有效期大于30天，运行renew操作不会有任何作用，Let's Encrypt只会续期有效期小于30天的证书。

### 8.3 TLS/SSL协议概述

TLS握手协议由4个子协议构成，分别是：
◎握手协议（TLS Handshaking Protocols）。
◎警告协议（Alert Protocol）。
◎应用层协议（Application Data Protocol）。
◎密码切换协议（Change Cipher Spec Protocol）。

握手协议主要的工作就是客户端和服务器端协商出双方都认可的密码套件，基于密码套件协商出密钥块，TLS记录层协议进行密码学保护所需要的密码块就是握手协议产生的。

### 8.7 基于Session ID的会话恢复

下面讲解TLS/SSL协议中非常重要的一个概念，那就是会话恢复。所谓会话恢复，就是客户端和服务器端进行简短的握手，不是完整的握手。

当客户端和服务器端握手成功，建立了一个完整的TLS连接，只要客户端和服务器端不主动关闭该连接，HTTPS的应用层数据请求就一直受该TLS连接保护，一旦客户端和服务器端关闭该连接，那么客户端下次访问HTTPS网站的时候就要进行一次新的连接，造成了极大的网络延迟，并消耗客户端和服务器端的运算能力。

有没有一种机制能够复用先前的TLS连接呢？或者说能否恢复先前的TLS会话呢？在TLS/SSL协议中，可以使用会话恢复机制。
会话恢复有两种形式，分别是基于Session ID的会话恢复和基于Session ticket的会话恢复，本节主要讲解基于Session ID的会话恢复。


在了解会话恢复之前，先回顾一下完整握手过程：
◎客户端发送Client Hello消息，其中传递的Session ID值为空。
◎服务器端检查客户端的Session ID值，如果该值为空，则进行完整的握手。生成一个新的Session ID，该值通过服务器端的Server Hello消息传递给客户端。

### 8.8 SessionTicket

◎Session ID会话信息存储在服务器端，对于大型HTTPS网站来说，占用的内存量非常大，是非常大的开销。
◎HTTPS网站提供者希望会话信息的生命周期更长一点，尽量使用简短的握手。
◎HTTPS网站提供者希望会话信息能够跨主机访问，Session ID会话恢复显然不能。
◎嵌入式的服务器没有太多的内存存储会话信息。


### 8.9 使用Wireshark学习TLS/SSL协议

通过该图可以看出这是一个完整的握手：
◎客户端首先发送Client Hello消息。
◎接着服务器端回应Server Hello消息。
◎接下来服务器端在独立的TCP包中发送Certificate、Server Hello Done消息，注意没有发送Server Key Exchange消息。
◎客户端接着发送Client Key Exchange消息、Change Cipher Spec、Finished（Encrypted Handshake Message）消息。
◎然后服务器端发送New SessionTicket（支持Session Ticket的会话恢复方式）、Change Cipher Spec、Finished消息。

### 10.4 实战HTTPS网站部署

在讲解具体HTTPS配置之前，先了解下Nginx配置文件的基本结构，server容器基本上可以理解为一个虚拟主机，每个server容器里面的配置都是独立的，不会和其他server容器冲突，而HTTP容器可以包含多个server子容器。

3）ssl_protocols
表示启用的协议版本，需要注意两点：
◎OpenSSL 1.0.1以上的版本才能启用TLS v1.1、TLS v1.2。
◎OpenSSL 1.1.1版本才能启用TLS v1.3。


配置非常简单，将ssl_certificate、ssl_certificate_key指令从server容器内移动到http容器内，比如进行如下配置：


size的单位一般是MB，默认情

### 10.5 大型网站部署HTTPS

七层负载均衡设备可以分析HTTP头部，提供更多的控制，处理效率相对较差。

◎从抽象的角度看，负载均衡设备可以认为就是代理服务器，两者代表同样的含义。
◎四层负载均衡设备简称为四层设备，七层负载均衡设备简称为七层设备。

TLS/SSL协议是TCP的上层协议，所以四层设备并不能提供SSL服务，解决方案有两种：

◎使用下面讲解的方案，主要在四层设备后面增加七层设备。
3）DNS+四层设备+七层设备+后端Web服务器
首先了解下七层设备的作用：
◎分析HTTP请求头部，比如根据用户的Cookie请求不同后端Web服务器。
◎七层主要接收HTTP请求，然后将具体的请求以FastCgi协议（也可以是其他协议）转发给后端应用服务器（比如PHP-FPM）。


在这种架构下，四层设备负责流量控制，而七层设备也可以是反向代理服务器，负责代理后端Web服务器，双方分工明确。

可以直接在七层设备上处理TLS/SSL运算，系统架构不用做太大的变化，直接配置ngx_http_ssl_module模块即可。

对于七层设备来说，一般只有少数运维人员才会操作，私钥泄露的可能性比较低，相对安全。
◎在七层设备上部署HTTPS服务管理方便，所有的安装、升级、配置操作都是透明的，后端的Web服务器根本不用关心。

4）DNS+七层设备+后端Web服务器
这种架构和DNS+四层设备+七层设备+后端Web服务器架构差不多，七层设备也包含了四层设备的功能，并且七层设备可以处理TLS/SSL协议运算。

从技术的角度看，CDN服务商一般也可以在七层设备上提供HTTPS服务，本质上CDN架构等同于DNS+七层设备+后端Web服务器架构。

由于CDN服务器商每天需要处理成千上万的HTTPS请求，为了提升效率和减少成本，CDN服务商会花费很多的精力去提升HTTPS请求的性能，即使稍微提升一点，CDN的成本就会减少很多。

◎X-Forwarded-For，将客户端IP和代理服务器IP传递给后端HTTP服务。

◎X-Forwarded-Proto，这是非常重要的一个指令，后端HTTP服务以此判断客户端是一个HTTP请求还是HTTPS请求。

◎代理服务器和后端HTTP服务器之间是明文连接，存在安全风险，但是运行快速。
◎后端服务不需要提供证书，就是普通的HTTP服务，无须做过多的应用层改造。
该方案应用场景：
◎对于企业内部来说，后端服务可以使用内网HTTP服务，内网由内部的防火墙保护，安全相对有保证，笔者公司就采用该方案。


国内CDN厂商目前都是这么做的，而这会带来潜在的风险，理论上，证书和密钥对不应该部署在其他非控制的服务器上。

2）双向认证
所谓双向证书，就是客户端除了校验服务器身份，还要发送证书给服务器，供服务器校验客户端的身份，双向证书一般适用于银行系统，在第一次登录银行系统的时候，银行会给每个注册用户发送一张客户端证书，用户后续登录的时候，浏览器会发送客户端证书。

所谓双向证书，就是客户端除了校验服务器身份，还要发送证书给服务器，供服务器校验客户端的身份，双向证书一般适用于银行系统，在第一次登录银行系统的时候，银行会给每个注册用户发送一张客户端证书，用户后续登录的时候，浏览器会发送客户端证书。

◎ssl_verify_client，开启客户端证书（代理服务器）的校验。◎ssl_client_certificate，指定中间证书+根证书校验客户端证书（代理服务器）。