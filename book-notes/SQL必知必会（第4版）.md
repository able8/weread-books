## SQL必知必会（第4版）
> Ben Forta

### 第1课 了解SQL

数据库（database）
保存有组织的数据的容器（通常是一个文件或一组文件）。

描述表的这组信息就是所谓的模式（schema），模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）。

数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可以存储哪些数据种类

数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须特别关注所用的数据类型。

主键（primary key）一列（或一组列），其值能够唯一标识表中每一行。唯一标识表中每行的这个列（或这几列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行就极为困难，因为你不能保证操作只涉及相关的行。

表中的任何列都可以作为主键，只要它满足以下条件：□ 任意两行都不具有相同的主键值；□ 每一行都必须具有一个主键值（主键列不允许NULL值）；□ 主键列中的值不允许修改或更新；□ 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。

 SQL简单易学。它的语句全都是由有很强描述性的英语单词组成，而且这些单词的数目不多。

### 第2课 检索数据

利用SELECT语句从Products表中检索一个名为prod_name的列。所需的列名写在SELECT关键字之后，FROM关键字指出从哪个表中检索数据。

SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对SQL关键字使用大写，而对列名和表名使用小写，这样做使代码更易于阅读和调试。

在处理SQL语句时，其中所有空格都被忽略。SQL语句可以写成长长的一行，也可以分写在多行。

多数SQL开发人员认为，将SQL语句分成多行更容易阅读和调试。

 SELECT语句还可以检索所有的列而不必逐个列出它们。在实际列名的位置使用星号（＊）通配符可以做到这点

使用DISTINCT关键字，顾名思义，它指示数据库只返回不同的值。

DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列。例如，你指定SELECT DISTINCT vend_id, prod_price，因为指定的两列不完全相同，所以所有的行都会被检索出来。

如果你使用MySQL、MariaDB、PostgreSQL或者SQLite，需要使用LIMIT子句

MySQL、MariaDB和SQLite支持简化版的LIMIT 4 OFFSET 3语句，即LIMIT 3,4。使用这个语法，逗号之前的值对应OFFSET，逗号之后的值对应LIMIT。

### 第3课 排序检索数据

要按多个列排序，简单指定列名，列名之间用逗号分开即可（就像选择多个列时那样）。

### 第4课 过滤数据

通常，这种做法极其不妥。优化数据库后可以更快速有效地对数据进行过滤。而让客户端应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户端过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。

确定值是否为NULL，不能简单地检查是否= NULL。SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句就是IS NULL子句

### 第5课 高级数据过滤

要通过不止一个列进行过滤，可以使用AND操作符给WHERE子句附加条件。

IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值。

□ 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理。□ IN操作符一般比一组OR操作符执行得更快（在上面这个合法选项很少的例子中，你看不出性能差异）。□ IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句

### 第6课 用通配符进行过滤

LIKE指示DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。

最常使用的通配符是百分号（%!）(MISSING)。在搜索串中，%!表(MISSING)示任何字符出现任意次数。例如，为了找出所有以词Fish起头的产品

通配符可在搜索模式中的任意位置使用，并且可以使用多个通配符。下面的例子使用两个通配符，它们位于模式的两端：

%!还(MISSING)能匹配0个字符。%!代(MISSING)表搜索模式中给定位置的0个、1个或多个字符。

通配符%!看(MISSING)起来像是可以匹配任何东西，但有个例外，这就是NULL。子句WHERE prod_name LIKE '%!’(MISSING)不会匹配产品名称为NULL的行。

另一个有用的通配符是下划线（_）。下划线的用途与%!一(MISSING)样，但它只匹配单个字符，而不是多个字符。

方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。

□ 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。□ 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。

### 第7课 创建计算字段

存储在表中的数据都不是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户端应用程序中重新格式化。这就是计算字段可以派上用场的地方了。与前几课介绍的列不同，计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。

为正确返回格式化的数据，必须去掉这些空格。这可以使用SQL的RTRIM()函数来完成

RTRIM()函数去掉值右边的所有空格。通过使用RTRIM()，各个列都进行了整理。

SQL支持列别名。别名（alias）是一个字段或值的替换名。别名用AS关键字赋予。

在很多DBMS中，AS关键字是可选的，不过最好使用它，这被视为一条最佳实践。

### 第9课 汇总数据

我们经常需要汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成。

□ 使用COUNT(＊)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。□ 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。

如果指定列名，则COUNT()函数会忽略指定列的值为空的行，但如果COUNT()函数中用的是星号（＊），则不忽略。

### 第10课 分组数据

使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。

唯一的差别是，WHERE过滤行，而HAVING过滤分组。

这条SELECT语句的前三行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(＊) >= 2（两个以上订单）的那些分组。可以看到，WHERE子句在这里不起作用，因为过滤是基于分组聚集值，而不是特定行的值。

一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。

这一课讲授了如何使用GROUP BY子句对多组数据进行汇总计算，返回每个组的结果。

### 第11课 使用子查询

在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。

因为它使用了完全限定列名，而不只是列名（cust_id）。它指定表名和列名（Orders.cust_id和Customers.cust_id）。

子查询常用于WHERE子句的IN操作符中，以及用来填充计算列。我们举了这两种操作类型的例子。

### 第12课 联结表

现在有同一供应商生产的多种物品，那么在何处存储供应商名、地址、联系方法等供应商信息呢？将这些数据与产品信息分开存储的理由是：□ 同一供应商生产的每个产品，其供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间；□ 如果供应商信息发生变化，例如供应商迁址或电话号码变动，只需修改一次即可；

关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）。

在这个例子中可建立两个表：一个存储供应商信息，另一个存储产品信息。Vendors表包含所有供应商信息，每个供应商占一行，具有唯一的标识。此标识称为主键（primary key），可以是供应商ID或任何其他唯一值。Products表只存储产品信息，除了存储供应商ID（Vendors表的主键）外，它不存储其他有关供应商的信息。Vendors表的主键将Vendors表与Products表关联，利用供应商ID能从Vendors表中找出相应供应商的详细信息。这样做的好处是：□ 供应商信息不重复，不会浪费时间和空间；□ 如果供应商信息变动，可以只更新Vendors表中的单个记录，相关表中的数据不用改动；□ 由于数据不重复，数据显然是一致的，使得处理数据和生成报表更简单。总之，关系数据可以有效地存储，方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。

将数据分解为多个表能更有效地存储，更方便地处理，并且可伸缩性更好。但这些好处是有代价的。

如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？答案是使用联结。简单说，联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。

FROM子句列出了两个表：Vendors和Products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确地联结，WHERE子句指示DBMS将Vendors表中的vend_id与Products表中的vend_id匹配起来。

等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）

两个表之间的关系是以INNER JOIN指定的部分FROM子句。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。

SQL不限制一条SELECT语句中可以联结的表的数目。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。

不要联结不必要的表。联结的表越多，性能下降越厉害。

子查询并不总是执行复杂SELECT操作的最有效方法，下面是使用联结的相同查询：

这个查询中的返回数据需要使用3个表。但在这里，我们没有在嵌套子查询中使用它们，而是使用了两个联结来连接表。这里有三个WHERE子句条件。前两个关联联结中的表，后一个过滤产品RGAN01的数据。

### 第13课 创建高级联结

允许给表名起别名。这样做有两个主要理由：□ 缩短SQL语句；□ 允许在一条SELECT语句中多次使用相同的表。

自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。

外联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表

这条SELECT语句使用INNER JOIN将Customers和Orders表互相关联。GROUP BY子句按顾客分组数据，因此，函数调用COUNT(Orders.order_num)对每个顾客的订单计数，将它作为num_ord返回。

□ 应该总是提供联结条件，否则会得出笛卡儿积。

### 第14课 组合查询

SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。

使用UNION可能比使用WHERE子句更为复杂。但对于较复杂的过滤条件，或者从多个表（而不是一个表）中检索数据的情形，使用UNION可能会使处理更简单。

### 第15课 插入数据

因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各列出现在表中的实际次序。其优点是，即使表的结构改变，这条INSERT语句仍然能正确工作。

不要使用没有明确给出列的INSERT语句。给出列能使SQL代码继续发挥作用，即使表结构发生了变化。

使用INSERT的推荐方法是明确给出表的列名。使用这种语法，还可以省略列，这表示可以只给某些列提供值，给其他列不提供值。

省略的列必须满足以下某个条件。□ 该列定义为允许NULL值（无值或空值）。□ 在表定义中给出默认值。这表示如果不给出值，将使用默认值。

INSERT通常只插入一行。要插入多行，必须执行多个INSERT语句。INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT语句返回多少行，都将被INSERT插入。

### 第16课 更新和删除数据

在使用UPDATE时一定要细心。因为稍不注意，就会更新表中的所有行。使用这条语句前，请完整地阅读本节

基本的UPDATE语句由三部分组成，分别是：□ 要更新的表；□ 列名和它们的新值；□ 确定要更新哪些行的过滤条件。

在更新多个列时，只需要使用一条SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。

DELETE FROM要求指定从中删除数据的表名，WHERE子句过滤要删除的行。

使用外键确保引用完整性的一个好处是，DBMS通常可以防止删除某个关系需要用到的行。例如，要从Products表中删除一个产品，而这个产品用在OrderItems的已有订单中，那么DELETE语句将抛出错误并中止。这是总要定义外键的另一个理由。

DELETE不需要列名或通配符。DELETE删除整行而不是删除列。要删除指定的列，请使用UPDATE语句。

如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。

□ 在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。

### 第17课 创建和操纵表

两种创建表的方法：□ 多数DBMS都具有交互式创建和管理数据库表的工具；□ 表也可以直接用SQL语句操纵。

表名紧跟CREATE TABLE关键字。实际的表定义（所有列）括在圆括号之中，各列之间用逗号分隔。这个表由5列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型（关于数据类型的解释，请参阅第1课。此外，附录D列出了常见的数据类型及兼容性）。整条语句以圆括号后的分号结束。

在SQL语句中忽略的空格。语句可以在一个长行上输入，也可以分成许多行，它们没有差别。这样，你就可以用最适合自己的方式安排语句的格式。

供应商ID和供应商名字列是必需的，因此指定为NOT NULL。其余五列全都允许NULL值，所以不指定NOT NULL。NULL为默认设置，如果不指定NOT NULL，就认为指定的是NULL。

不要把NULL值与空字符串相混淆。NULL值是没有值，不是空字符串。

□ 理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。□ 所有的DBMS都允许给现有的表增加列，不过对所增加列的数据类型（以及NULL和DEFAULT的使用）有所限制。□ 许多DBMS不允许删除或更改表中的列。□ 多数DBMS允许重新命名表中的列。

### 第18课 使用视图

假如可以把整个查询包装成一个名为ProductCustomers的虚拟表，则可以如下轻松地检索出相同的数

这就是视图的作用。ProductCustomers是一个视图，它不包含任何列或数据，包含的是一个查询（与上面用以正确联结表的查询相同）。

□ 重用SQL语句。□ 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。□ 使用表的一部分而不是整个表。□ 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。

因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。

个最常见的视图应用是隐藏复杂的SQL，这通常涉及联结

视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。

视图的另一常见用途是重新格式化检索出的数据。

视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据。

### 第19课 使用存储过程

存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。

□ 通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。□ 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。

### 第20课 管理事务处理

使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。

事务处理是一种机制，用来管理必须成批执行的SQL操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。

### 第21课 使用游标

在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。

在处理OPEN CURSOR语句时，执行查询，存储检索出的数据以供浏览和滚动。

### 第22课 高级SQL特性

主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中的行。没有主键，要安全地UPDATE或DELETE特定行而不影响其他行会非常困难。

主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。

外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。

表定义使用了REFERENCES关键字，它表示cust_id中的任何值都必须是Customers表的cust_id中的值。

级联删除（cascading delete）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从Customers表中删除某个顾客，则任何关联的订单行也会被自动删除。

检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。□ 检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。□ 指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。□ 只允许特定的值。例如，在性别字段中只允许M或F。

使索引有用的因素是什么？很简单，就是恰当的排序。

搜索其他列中的值通常效率不高。例如，如果想搜索住在某个州的客户，怎么办？因为表数据并未按州排序，DBMS必须读出表中所有行（从第一行开始），看其是否匹配。这就像要从没有索引的书中找出词汇一样。

解决方法是使用索引。可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。

 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。□ 索引数据可能要占用大量的存储空间。

许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。

触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联。

约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。

### 附录A样例表脚本

编写SQL语句需要良好地理解基本数据库设计。如果不知道什么信息存放在什么表中，表与表之间如何互相关联，行中数据如何分解，那么要编写高效的SQL是不可能的。

Vendors表存储销售产品的供应商。每个供应商在这个表中有一个记录，供应商ID列（vend_id）用于进行产品与供应商的匹配。

Products表包含产品目录，每行一个产品。每个产品有唯一的ID（prod_id列），并且借助vend_id（供应商的唯一ID）与供应商相关联。

为实施引用完整性，应该在vend_id上定义一个外键，关联到Vendors的vend_id列。

Orders表存储顾客订单（不是订单细节）。每个订单唯一编号（order_num列）。Orders表按cust_id列（关联到Customers表的顾客唯一ID）关联到相应的顾客。

个表应该用order_num和order_item作为其主键。

数据库管理员通常使用关系图来说明数据库表的关联方式。要记住，正如上面表描述提到的，外键定义了这些关系。

### 附录B流行的应用程序

两种方式使用PostgreSQL。DBMS带有一个名为psql的命令行实用程序，这是一个纯文本工具，通常与PostgreSQL一起安装，用来执行任意SQL语句。另外，有一个名为pgAdmin的交互工具，主要用于DBMS管理，可测试SQL语句。

### 附录D SQL数据类型

数据类型用于以下目的。□ 数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。□ 数据类型允许在内部更有效地存储数据。可以用一种比文本字符串更简洁的格式存储数值和日期时间值。

定长字符串接受长度固定的字符串，其长度是在创建表时指定的。例如，名字列可允许30个字符

既然变长数据类型这样灵活，为什么还要使用定长数据类型？答案是性能。DBMS处理定长列远比处理变长列快得多。此外，许多DBMS不允许对变长列（或一个列的可变部分）进行索引，这也会极大地影响性能（详细请参阅第22课）

你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是这样做并不可取。如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。