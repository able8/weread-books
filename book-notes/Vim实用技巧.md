## Vim实用技巧
> Drew Neil

### 自序

Vim的祖先要追溯到经典的UNIX编辑器vi和ed，参见技巧27中的“Vim（及其家族）的词源”部分，它们比鼠标及所有点击界面出现得都早，因此根本没有这类接口，所有操作都通过键盘完成。Vim 也是一样，在Vim 中所有的操作也都可以通过键盘完成。对盲打人员来说，这意味着用 Vim 做任何事都能更快些。

### 写作体例说明

传统上，Vim在终端内运行，没有图形用户界面（GUI）。我们也可以说Vim具有TUI，即文本用户界面。如果你每天有大量时间花在命令行上，你会感觉这很自然。

### 第1章 Vim解决问题的方式

Vim对重复性操作进行了优化。它之所以能高效地重复，是因为它会记录我们最近的操作，让我们用一次按键就能重复上次的修改。

. 命令可以让我们重复上次的修改，它是Vim中最为强大的多面手。


>G 命令会增加从当前行到文档末尾处的缩进层级。如果我们在此命令后使用 . 命令，那么“重复上次修改”会让 Vim 增加从当前行到文档末尾的缩进层级。在下例中，我们让光标从第二行开始，以便一目了然地看出差别。

从进入插入模式的那一刻起（例如，输入 i），直到返回普通模式时为止（输入<Esc>），Vim会记录每一个按键操作。做出这样一个修改后再用 . 命令的话，它将会重新执行所有这些按键操作（

由于 . 命令可以重复上次的修改，因此我们不必重复之前的操作，而是执行两次 j$.。一个键（.）顶 3 个（a;<Esc>），虽然每次省的并不多，不过在重复操作时，累积效应可不小。

s 命令把两个操作合并为一个：它先删除光标下的字符，然后进入插入模式。在删除 + 号后，我们先输入￼+￼，然后退出插入模式。

f{char} 命令让Vim查找下一处指定字符出现的位置，如果找到了，就直接把光标移到那里（参见:h f￼）。

我们可以重复按 f+ 命令跳到下一个 + 号所在的位置。不过，还有一种更好的方法可以用。; 命令会重复查找上次 f 命令所查找的字符

; 命令带我们到下一个目标字符上，而 . 命令则重复上次的修改。

在面对重复性工作时，我们需要让移动动作和修改都能够重复，这样就可以达到一个最佳编辑模式。Vim 对此的支持是：它会记住我们的操作，并使最常用的操作触手可及，所以我们可以很方便地重复执行它们。

如果在使用 f{char} 命令后，不小心按了太多次 ; 键，就会偏离我们的目标。不过我们可以再按 , 键跳回去，这个命令会反方向查找上次 f{char}所查找的字符（

是* 命令，此命令可以查找当前光标下的单词

我们把光标移到单词“content”上，然后使用 * 命令对它进行查找，你也可以自己试一下。这会产生两个结果：一是光标会跳到下一个匹配项上，二是所有出现这个词的地方都会被高亮显示出来。如果你并没有看到高亮，试着运行一下 :set hls。

执行过一次查找“content”的命令后，现在我们只需按 n 键就可以跳到下一个匹配项。在本例中，按 *nn 会遍历完所有的匹配项，从而跳回到本次查找的起点。

万事俱备！每次我们按 n 键时，光标就会跳到下一个“content”单词所在之处，而当我们按 . 键时，它就会把光标下的单词改为“copy”。

如果我们想替换所有地方，就可以不加思考地一直按 n.n.n. 以完成所有的修改（但是，这种情况下也可以用 :%!s(MISSING)/content/copy/g 命令）。

在技巧 2 中，我们想在一系列行的结尾添加分号。我们先用 A;<Esc> 修改了第一行，做完这步准备后，就可以使用 . 命令对后续行重复此修改。我们使用了 j 命令在行间移动，要完成剩余的修改，只需简单地按足够多次j. 就可以了。

在技巧 3 中，我们想为每个 + 号的前后各添加一个空格。我们先用 f+ 命令跳到目标字符上，然后用 s 命令把一个字符替换成3 个，做完这步准备后，我们就可以按若干次 ;. 完成此任务。

### 第2章 普通模式

在Vim中，我们自己可以控制撤销的粒度。

u 键会触发撤销命令，它会撤销最新的修改。一次修改可以是改变文档内文本的任意操作，其中包括在普通模式、可视模式以及命令行模式中所触发的命令，而且一次修改也包括了在插入模式中输入（或删除）的文本，因此我们也可以说，i{insert some text}<Esc> 是一次修改。

从进入插入模式开始，直到返回普通模式为止，在此期间输入或删除的任何内容都被当成一次修改。因此，只要我们控制好对 <Esc> 键的使用，就可使撤销命令作用于单词、句子或段落。

那么，应该多久离开一次插入模式呢？这是个人喜好的问题，不过我喜欢让每个“可撤销块”对应一次思考过程。在写这段文字时（当然是在Vim中写的），我经常在每句话的结尾停顿一下，想一想接下来该写什么。不管停顿的时间有多短，每次停顿都是一个自然的中断点，提示我该退出插入模式了。当我准备好继续写时，按 A 命令就可以回到原来的地方继续写作。

当处于插入模式时，如果光标位于行尾的话，另起一行最快的方式是按<CR>。不过有时我更喜欢按 <Esc>o，这是因为我有预感，也许在撤销时我想拥有更细的粒度。如果听起来这不太好理解，不必担心，当你对Vim越来越熟悉时，就会感到切换模式越来越轻松。

我们先用 b 命令把光标移到单词的开头，移动好后，就可以用一个 dw 命令删掉整个单词。这一次的Vim高尔夫得分也是3分。

把 daw 命令解读为“delete a word”，这样比较容易记忆。

daw 可以发挥 . 命令的最大威力，因此我宣布它是本轮的获胜者。
要想充分利用 . 命令，事先常常需要进行一番周详的考虑。如果你发现自己要在几个地方做同样的小修改，就可以尝试构造你的修改，让它们能够被 . 命令重复执行。要识别出这类机会需要进行一定的实践，不过一旦你养成了使修改可重复的习惯，那么你就会从 Vim 这里得到“奖赏”。

<C-a> 和 <C-x> 命令分别对数字执行加和减操作。在不带次数执行时，它们会逐个加减，但如果带一个次数前缀，那么就可以用它们加减任意整数。例如，如果我们把光标移到字符5上，执行 10<C-a>就会把它变成15

<C-a> 命令会“把当前光标之上或之后的数值加上[count]”（参见:h ctrl-a￼）。因此，如果光标不在数字上，那么 <C-a> 命令将在当前行正向查找一个数字，如果找到了，它就径直跳到那里。我们可以利用这一点简化操作。

set nrformats=
这会让Vim把所有数字都当成十进制，不管它们是不是以0开头的。

还记得吗，我们的口诀是（参见技巧4）：执行、重复、回退。这里就是在把它付诸行动。

使用次数的另一个好处是：它保留了一个干净、连贯的撤销历史记录。完成这次修改后，我们按一下 u 键就可以撤销整个修改，这和技巧8中的讨论是一致的。

操作符 + 动作命令 = 操作
d{motion} 命令可以对一个字符（dl）、一个完整单词（daw）或一整个段落（dap）进行操作，它作用的范围由动作命令决定。c{motion}、y{motion}以及其他一些命令也类似，它们被统称为操作符（operator）。

表2-1 Vim的操作符命令

g～、gu和gU命令要用两次按键来调用，我们可以把上述命令中的 g 当做一个前缀字符，用以改变其后面的按键行为，进一步的讨论请参见本技巧最后的“结识操作符待决模式”部分。

假如我们已经知道如何用 daw 删除一个单词，然后又学到 gU 命令（参见 :h gU￼）。它也是个操作符，所以我们可以用 gUaw 把当前单词转换成大写形式。如果我们的词汇进一步扩充，学会了作用于段落的 ap 动作命令，就会发现我们可以进行两个新的操作：用 dap 删除整个段落，或者用 gUap 把整段文字转换为大写。

Vim的语法只有一条额外规则，即当一个操作符命令被连续调用两次时，它会作用于当前行。所以 dd 删除当前行，而 >> 缩进当前行。gU 命令是一种特殊情况，我们既可以用 gUgU ，也可以用简化版的 gUU 来使它作用于当前行。

如果想用 = 命令自动缩进整个文件，我们可以执行 gg=G （就是说，先用 gg 跳到文件开头，然后用 =G 自动缩进从光标位置到文件结尾的所有内容）。

简单地执行 =ae 就可以了。运行这条命令时光标在哪儿并不重要，因为它总是作用于整个文件。

### 第3章 插入模式

这些命令不是插入模式所独有的，甚至也不是Vim所独有的，在Vim的命令行模式中，以及在 bash shell中，也可以使用它们。

切换回普通模式的经典方式是使用 <Esc> 键，但在许多键盘上这个键的距离似乎有点远。作为替代，我们也可以用 <C-[> ，它的效果与 <Esc> 完全相同（参见 :h i_CTRL-[￼）。

结识插入-普通模式
插入-普通模式是普通模式的一个特例，它能让我们执行一次普遍模式命令。在此模式中，我们可以执行一个普通模式命令，执行完后，马上就又返回到插入模式。要从插入模式切换到插入-普通模式，可以按<C-o>（参见:h i_CTRL-O￼）。

用 zz 命令可以重绘屏幕，并把当前行显示在窗口正中，这样就能够阅读当前行之上及之下的半屏内容。我常常会键入 <C-o>zz，在插入-普通模式中触发这条命令。此操作完成后就会直接回到插入模式，因此我可以不受中断地继续打字

这个命令一般的格式是 <C-r>{register}，其中{register}是我们想要插入的寄存器的名字（参见:h i_CTRL-R￼）。

在插入模式中，可以用<C-r>{register} 命令很方便地粘贴几个单词。

我们可以用 = 符号指明使用表达式寄存器。在插入模式中，输入 <C-r>= 就可以访问这一寄存器。这条命令会在屏幕的下方显示一个提示符，我们可以在其后输入要执行的表达式。输入表达式后敲一下 <CR>，Vim就会把执行的结果插入到文档的当前位置了。

解决方法是可以用4位十六进制编码来输入这些字符，即输入 <C-v>u{1234}（注意数字前的 u ）。假设我们想插入字符编码为00bf的反转问号（“¿”），只需在插入模式中输入 <C-v>u00bf 即可。更多详细内容可参见:h i_CTRL-V_digit￼。

如果你想知道文档中任意字符的编码，只需把光标移到它上面并按 ga 命令，然后屏幕下方就会显示出一条消息，分别以十进制和十六进制的形式显示出其字符编码（参见 :h ga￼）。

如果你想知道文档中不存在的字符的编码，该命令就无能为力了。在这种情况下，你或许得去查一下unicode表。

### 第4章 可视模式

Vim具有3种不同的可视模式，分别用于操作字符文本、行文本或块文本。

也可以用 f{char} 跳到当前行的某个字符上，然后用 ; 和 , 命令相应地正向或反向重复此跳转；

还可以用查找命令（以及n / N 命令）跳转到匹配指定模式的地方。每次在可视模式中移动光标，都会改变高亮选区的边界。

“March”的某个位置，然后执行 viw 来高亮选择这个词。

v 键是通往可视模式的大门。在普通模式下，按 v 可激活面向字符的可视模式，按V（v和Shift键一起按）可激活面向行的可视模式，而按 <C-v>（v和Ctrl键一起按）则可激活面向列块的可视模式

gv 命令是个有用的快捷键，它用来重选上一次由可视模式所选择的文本范围。不管上个选区是面向字符的、面向行的，或是面向列块的，gv 命令都能够正确地工作。不过如果上次的选区被删除了，它也许会工作得不太正常。

高亮选区的范围由其两个端点界定。其中一端固定，而另一端可以随光标自由移动，我们可以用 o 键来切换其活动的端点。在定义选区时，如果定义到一半时，才发现选区开始的位置不对，此时用这个键会很方便，我们用不着退出可视模式再从头开始，只需按一下 o，然后重新调整选区的边界即可。

当使用 . 命令重复对高亮选区所做的修改时，此修改会重复作用于相同范围的文本。在本节中，我们会对一个面向行的高亮选区做一个修改，然后使用 . 命令重复此修改。

在使用 . 命令重复一条可视模式命令时，它所操作的文本数量和上次被高亮选中的文本数量相同。对于面向行的高亮选区来说，这种做法往往符合我们的需要。但

使用可视模式下的命令
在可视模式中，我们可以选定一个选区然后对其进行操作。本例中，我们可以使用U命令来把所选中的字符转换为大写（

可视模式下的U命令有一个等效的普通模式命令：gU{motion}（参见:h gU￼）。如果我们用此命令做第一处修改，就可以用点范式完成后续的修改

如果我们想使点命令能够重复某些有用的工作，那么最好要远离可视模式。作为一般的原则，在做一系列可重复的修改时，最好首选操作符命令，而不是其对应的可视模式命令。

我们或许也想画一条横线来分隔表头及其下的内容。我们先快速地复制顶行并粘贴一份副本（yyp），然后再用连字符替换该行内的所有字符（Vr-）。

Vim 对于从列块可视模式切换到插入模式的命令也遵从类似的约定。I 命令和 A命令都完成此切换，并分别把光标置于选区的开头和结尾。那 i 和 a 命令呢，它们在可视模式里干什么？在可视模式及操作符待决模式中，i 和 a 键沿用一个不同的约定。它们会被当作一个文本对象的组成部分，我们将在技巧51中深入探讨文本对象。如果你在列块可视模式里选中了一块区域，并且很奇怪为什么按 i 键没进入插入模式，那么换用 I 键试一下。

### 第5章 命令行模式

初时，先有 ed，ed 为 ex 之父，ex 为 vi 之父，而vi为 Vim 之父。

命令行模式会提示我们输入一条 Ex 命令、一个查找模式，或一个表达式。

那个年代，从终端到大型机之间的连接很慢，以至于一个快速打字员比网络还快，他们输入命令的速度要比命令被发出去处理更快。在这种情况下，ed 能够提供一个简洁的语法变得异常重要。想一下为何p 被用来打印当前行，而 %!p(MISSING) 被用来打印整个文件，皆缘于此。

用地址指定一个范围
迄今为止，地址只是被当成一个单独的行号，不过我们也可以用它来指定一个范围，如下例所示：
➾:2,5p

符号 . 代表当前行的地址。因此，我们可以很容易地写出一个范围，用以代表从当前位置到文件末尾间的所有行：
➾:2
➾:.,$p

符号 %!也(MISSING)有特殊含义，它代表当前文件中的所有行：
➾:%!p(MISSING)

➾:%!s(MISSING)/Practical/Pragmatic/
上述命令让 Vim 把每行内的第一个“Practical”替换为“Pragmatic”，我们将在第14章学习关于此命令的更多内容。

用模式指定范围
Vim 也接受以模式作为一条 Ex 命令的地址，如下所示：
➾:/<html>/,/<\/html>/p


➾:/<html>/+1,/<\/html>/-1p


偏移的一般形式是这样的：
:{address}+n
如果 n 被省略，那么缺省偏移量为1。{address} 可以是一个行号、一个位置标记，或是一个查找模式。

:copy 命令（及其简写形式 :t）让我们可以把一行或多行从文档的一部分复制到另一部分，而 :move 命令则可以让我们把一行或多行移到文档的其他地方。

copy命令的格式如下（参见:h :copy￼）：
:[range]copy {address}
在此例中，[range] 是第6行，而 {address} 用的是符号 .，它代表当前行。因此，我们可以把 :6copy. 命令解读为“为第6行创建一份副本，并放到当前行下方”。
:copy 命令可以简写为两个字母 :co，或者也可以用更加简练的 :t 命令，它是 :copy 命令的同义词。

我们得先跳到想复制的行上（6G），复制该行（yy），快速跳回原先的位置（<C-o>），然后再用粘贴命令（p）创建一个副本。由此可见，在复制距离较远的行时，:t 命令通常更加高效。

在选中高亮选区后，只需简单地执行命令 :'<,'>m$ 即可。另外还有种做法，我们也可以执行 dGp，此命令可以分解为：d 删除高亮选区，G 跳转到文件结尾，而 p 则粘贴刚刚删除的文本。

如果想在一系列连续行上执行一条普通模式命令，我们可以用 :normal 命令。此命令在与 . 命令或宏结合使用时，我们只需花费很少的努力就能完成大量重复性任务。

:'<,'>normal . 命令可以解读为“对高亮选区中的每一行，对其执行普通模式下的 . 命令”。无论是操作5行还是50行文本，这种方法都能出色地完成任务，更棒的是我们甚至都不需要计算行数，在可视模式中选中这些行使我们摆脱了计数的负担。

➾:%!n(MISSING)ormal A;
符号 %!代(MISSING)表整个文件范围，因此 :%!n(MISSING)ormal A; 告诉 Vim 在文件每行的结尾都添加一个分号。在做此修改时会切换到插入模式，但是在修改完后Vim会自动返回到普通模式。

例如，下面这条命令可以把整个JavaScript文件注释掉：
➾:%!n(MISSING)ormal i//
虽然用 :normal 命令可以执行任意的普通模式命令，但是我发现当它和 Vim 的重复命令结合在一起时，最为强大，既可以用 :normal . 应对简单的重复性工作，也可以用 :normal @q 应对较复杂的任务。具体的实例参见技巧67 和技巧69。

. 命令可以重复上次的普通模式命令。然而，如果想重复上次的 Ex 命令的话，我们得使用 @: 才行。

由于光标已经在单词“counter”上了，因此我们无需再次输入它，而是直接用 <C-r><C-w>映射项把它插入到替换域：
➾:%!s(MISSING)//<C-r><C-w>/g


在Vim的命令行模式中，给命令加一个叹号前缀（参见:h:!￼）就可以调用外部程序。例如，如果想查看当前目录的内容，可以运行下面的命令：
➾:!ls

在Vim的命令行中，符号%!代(MISSING)表当前文件名（参见:h cmdline-special￼）。在运行那些操作当前文件的外部命令时，我们可以使用它。例如，如果我们正在编辑某个Ruby 文件，那么可以用下面的方式执行此文件：
➾:!ruby %!(NOVERB)

在用 :!{cmd}时，Vim 会回显 {cmd} 命令的输出。如果命令的输出很少或没有输出，这工作得很好；但如果命令会产生大量输出，这样回显用处不大。另外一种做法是我们可以用 :read !{cmd} 命令，把 {cmd} 命令的输出读入当前缓冲区中（参见:h read![插图]）。:read !{cmd} 命令让我们把命令的标准输出重定向到缓冲区。正如你所期望的一样，:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入（参见:h:write_c[插图]），跳到技巧45可以看到此功能的一个应用实例。

当给定一个范围时，:!{cmd} 命令就具有了不同的含义。由[range]所指定的行会传给{cmd} 作为标准输入，然后又会用{cmd} 的输出覆盖 [range]内原本的内容。换一种说法就是 [range] 内的文本会被指定的 {cmd} 进行过滤（参见 :h:range![插图]）。Vim 把过滤器定义为“一个由标准输入读取文本，并对其进行某种形式的修改后输出到标准输出的程序”。

我们想基于第二个字段“姓氏”来重排这些记录。我们可以用 -t’,’ 参数告诉sort 命令，这些记录以逗号分隔，然后再用-k2 参数指定按第二个字段进行排序。因为文件的第一行是标题信息，我们想把它们保留在文件顶部，因此需要用范围 :2,$ 把它排除在排序范围之外。下列命令将完成我们想要的功能：➾:2,$!sort -t',' -k2

### 第6章 管理多个文件

Vim允许我们同时在多个缓冲区上工作。先在shell里用下面的命令打开几个文件：
➾ $ cd code/files
➾ $ vim *.txt

:ls命令会列出所有被载入到内存中的缓冲区的列表

用 :bn 和 :bp 来遍历缓冲区列表可以省点儿事

打开及关闭标签页
用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了{filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区。

标签页的编号从1开始，我们可以用 {N}gt 命令在标签页间切换，可以把此命令记成“跳到标签页{N}”。

### 第8章 用动作命令在文档中移动

j 和 k 命令会根据实际行向下及向上移动，而 gj 和 gk 则是按屏幕行向下及向上移动。

你可以留意到这样一个特点，即j、k、0和 $ 都用于操作实际行，而如果在这些键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作。

Vim 提供了一组动作命令，让我们每次可以把光标正向或反向移动一个单词的距离（参见:h word-motions￼）

w和 b 命令都以词首为目标，而 e 和ge 命令则是以词尾为目标。w 和 e 都正向移动光标，而 b 和 ge 命令则反向移动光标

把 ea 命令连在一起可被解读为“在当前单词结尾后添加”。我经常会用到 ea，就好像它是一条单独的命令似的。另外，也可以把 gea 命令当成“在上一单词结尾后添加”的命令，我们偶尔也会用到它。

Vim对此有两种不同的定义，并且分别用“单词”（word）和“字串”（WORD）对其进行区分。我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对应，这当中包括 W、B、E和 gE。

一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白字符分隔（参见:h word￼）。

而字串的定义则更简单，它由非空白字符序列组成，字串间以空白字符分隔（参见:h WORD￼）。

相反，如果我们基于字串移动，用更少的按键就可以达到同样的效果：

本例中，fx 命令什么都不做。Vim 会正向查找字符“x”，但因为未能找到匹配的字符，因此光标保持不动。而 fo 命令找到了字符“o”，因此光标会被移到第一个匹配的字符上。

幸运的是，我们不必一遍遍地重复输入fc 命令。Vim 会记录上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了（参见 :h ;￼）。在本例中，我们得连按3次 ; 才能使光标就位。

我们不小心跳过头了，这个时候，用 , 命令就可以再跳回来。此命令也会重复上次的f{char}命令，不过会按相反的方向进行查找（参见:h ,￼）。还记得技巧4中提到的口诀吗？执行、重复、回退。我把 , 当成一个安全网来用，当按 ; 键按过头时，可以用它来回退。

可以把 t{char} 及 T{char} 命令当成“直到查找到指定的字符为止”（search till the specified character）的命令，它们使光标停留在 {char} 前面的那个字符上，而f{char} 和 F{char} 命令则把光标移动到指定字符上

刚开始，我们先把光标直接移到逗号上，因此使用了 f, 命令。接下来，我们想删除从此处到句尾的所有文本，但又不想删除句号，此时可以用 dt. 命令完成这项工作。

查找命令允许我们用很少几个键就能快速地进行跳转，跳转的距离可以很近，也可以很远。

虽然字符查找命令（f{char、t{char}等）执行起来方便快捷，但是它们具有一定的局限性。这些命令一次只能查找一个字符，并且它们只能在当前行内查找。如果想查找一个以上的字符，或是移动到当前行之外的话，就需要使用查找命令。

另外，如果按n 键的次数过多了，我们还可以用 N 命令再跳回来。现在你应该对技巧4中提到的口诀更加熟悉了，即执行、重复、回退

学会把 d{motion} 操作符与查找动作结合在一起使用，这是个很大的进步，

文本对象就是基于结构定义的文本区域（参见:h text-objects￼）。通过使用文本对象，我们只需几个键就可以选择或操作一大段文本。

Vim 的文本对象由两个字符组成，第一个字符永远是 i 或是 a。我们一般说，以 i 开头的文本对象会选择分隔符内部的文本，而以 a 开头的文本对象则会选择包括分隔符在内的整个文本。为了便于记忆，可以把 i 想成“inside”，而把 a 想成“around”或“all”

文本对象通常是成对出现的，一个用于操作对象内部的文本，而另一个则操作对象周围的文本。在本节中，我们将剖析每类文本对象的典型用法。

让我们比较一下 iw 及 aw 文本对象。按之前说过的记忆方式，可以分别把它们解读为操作单词内部（inside the word）或单词周围（around the word）。不过这究竟代表着什么呢？iw 文本对象包含当前单词从第一个到最后一个字符间的全部内容，aw 文本对象也是一样，但它的范围有所扩大，它会额外包含该单词前面或后面的一个空白字符（假如该处有空白字符的话）。

Vim 的位置标记允许我们快速跳转到文档中感兴趣的地方。我们可以手动设置位置标记，不过 Vim 也会自动帮我们记录某些感兴趣的位置点。

m{a-zA-Z}命令会用选定的字母标记当前光标所在位置（参见:h m￼）。小

技巧54 在匹配括号间跳转
Vim 提供了一个动作命令，让我们可以在开、闭括号间跳转。在

%!命(MISSING)令允许我们在一组开、闭括号间跳转（参见:h %!￼(MISSING)），它可作用于()、{}以及[]，如下例所示：

S" 命令是surround.vim 提供的一个命令，可以把它解读为“用一对双引号把选中的文本括起来”（Surround the selection with a pair of double quote marks）。如果想把选中的文本用圆括号或花括号括起来，只需简单地用 S) 或 S} 即可。

### 第9章 在文件间跳转

而Vim则通过跳转列表提供了类似的功能。<C-o> 命令像后退按钮一样，而与之互补的 <C-i> 命令则像是前进按钮。这两条命令允许我们对 Vim 的跳转列表进行遍历。不过，究竟什么是跳转呢？

用 [count]G 命令直接跳到指定的行号也会被当成一次跳转，但每次向上或向下移动一行则不算。面向句子的动作及面向段落的动作都算跳转，但面向字符及面向单词的动作则不算。用一句话来概括，我们可以说大范围的动作命令可能会被当成跳转，但小范围的动作命令则只能算移动。

Vim 可以同时维护多份跳转列表。实际上，每个单独的窗口都拥有一份自己的跳转列表。如果你正在使用分割窗口或多标签页，那么 <C-o> 和 <C-i> 命令会始终在当前活动窗口的跳转列表范围内进行跳转。

每当对文档做出修改后，Vim 都会记录当时光标所在的位置。遍历改变列表的方法很简单，并且这大概是跳到你要去的地方的最快方式。

Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改，此表就是所谓的改变列表（change list，参见:h changelist￼）。用下面的命令可以查看其内容：
➾ :changes

Vim 为每次修改都记录了行号与列号，我们可以用 g; 和 g,命令反向或正向遍历改变列表。你可以拿 ; 和 , 命令当参考，来帮你记忆 g; 与 g, 命令。前两条命令分别用来正向及反向重复 f{char} 命令（参见技巧49）。
要想跳到上次文档中被更改过的地方，我们可以按 g;。它会跳到上次完成编辑时光标所在的行及列上，

Vim 会自动创建一些位置标记，它们是对改变列表的一个有用补充。`. 标记总是指向上次修改的位置（参见:h`.￼），而`^标记则会记录上次退出插入模式时光标所在的位置（参见:h`^￼）。

Vim 会为编辑会话中的每个单独缓冲区维护一个改变列表，而与之不同的是，每个窗口都会创建一个单独的跳转列表。

技巧57 跳转到光标下的文件
Vim 会把文档中的文件名当成一个超链接。在进行了正确的配置后，我们就可以用 gf 命令跳转到光标下的文件了。

全局位置标记是一种书签，让我们可以在文件间跳转。全局标记在我们分析完代码，并想快速跳回一个文件时特别有用。

小写字母会创建局部于缓冲区的标记，而大写字母则创建全局标记。设置好标记后，就可以用`{letter}命令使光标快速回到标记所在之处（参见:h `￼）。

试下这个例子：先打开你的vimrc 文件，按 mV 设置一个全局标记（助记词V 代表 vimrc），然后切换到另一个文件中按 `V。现在，你应该马上就跳回到vimrc的全局标记处了。缺省情况下，全局标记在两次编辑会话之间仍然会保留（然而这是可配置的，请参见:h 'viminfo'￼）。因此，现在你用两次按键就可以打开你的vimrc文件了，除非你又把全局标记 V 设到了另一个地方。
在浏览代码前先设置一个全局标记
当你需要浏览一些文件，然后再快速跳回到原处时，全局标记会显得特别有用。

### 第10章 复制与粘贴

Vim的删除（delete）、复制（yank）与粘贴（put）命令处理一些常见的问题。

剪切（cut）、复制（copy）与粘贴（paste），这些都是众所周知的术语，而且大多数桌面软件和操作系统都支持这3类操作。Vim当然也提供这些功能，只不过使用的是另外的术语delete、yank与put

Vim的yank命令也等同于复制操作。但由于历史原因，当时c命令已经被用于修改（change）操作了，因此 Vi 的作者们被迫选择了另一个名字 yank。由于那时y键还可用，因此它就成了复制操作的命令。

Vim的delete命令也与标准剪切操作的作用一致。也就是说，该命令会先把指定文本复制到寄存器后再从文档中删掉。能够理解这一点，是避开类似糟糕！我弄丢了复制内容所遇到的常见陷阱的关键。

Vim 还提供了几组可被隐式赋值的寄存器。它们被称作只读寄存器（参见:h quote.[插图]），如下表所示：

我有时更喜欢在插入模式中使用 <C-r>{register}的映射项，来粘贴面向字符的文本区域。通过这种方式，寄存器的文本总会被插入至光标之前，就像我们在插入模式下手动输入它们一样。

在插入模式下，我们可以通过输入 <C-r>" 来插入无名寄存器的内容，或者输入<C-r>0来插入复制专用寄存器的内容

### 第11章 宏

我们可以用宏把任意数目的按键操作录制到寄存器，用于之后的回放。
宏很适合针对一系列相似的行、段落，甚至是文件，进行重复性的修改。我们将会发现在一组目标上执行宏可以有两种方式——以串行方式回放或者以并行方式多次运行，我们将逐一学习这两种技巧。

q 键既是“录制”按钮，也是“停止”按钮。为了录制我们的按键操作，一开始需要按q{register}，从而指定一个用于保存宏的寄存器。当状态栏中出现“记录中”时，表示录制已经开始。此后，我们执行的每一条命令都将被宏捕获，直到我们再次按下q键停下为止。

我们可以通过以下命令查看寄存器a中的内容：
➾:reg a
《 --- Registers ---
"a A;^[Ivar ^[
尽管这些内容难以理解，但对于你应该似曾相识，因为它们正是刚刚录制的命令序列。唯一的不同可能是符号 ^[ ，它代表Esc键。

通过执行宏来回放命令序列
我们可以用@{register}命令执行指定寄存器的内容（参见:h @￼)，也可以用@@ 来重复最近调用过的宏。

注意：我们在第一行用 @a 回放宏，而在下一行用 @@ 来回放同样的宏

黄金法则：在录制一个宏时，要确保每条命令都可被重复执行。

当动作命令失败时，宏将中止执行
Vim 的动作命令可能会执行失败。举例来说，如果光标位于文件的首行，运行 k命令将什么也不会发生。若光标位于文件的末行，按下 j也会出现同样的情况。当发生上述情况时，Vim 缺省会发出“哔”的一声，提示我们动作命令失败了。当然，也可以设置‘visualbell’（参见:h 'visualbell'￼）关闭提示音。

直到再也没有一处匹配为止。若此时再执行该宏，由于已没有匹配项，n命令会失败，宏将中止退出。

技巧67 在连续的文本行上重复修改
对于多行范围内的重复性改动，可以先录制一个宏，然后再在每一行上回放，这将会极大减轻我们的工作量。该功能可用两种执行宏的方式实现，串行或者并行。

注意动作命令在该宏中的用法。首先，我们输入 0 命令，将光标置于行首，从而规范了光标的位置。这意味着下一条动作命令总是从相同的位置开始执行，重复性更强。

使用 f. 这条动作命令会为我们增加一种安全捕获机制。如果在当前行没找到字符 . ，f. 命令会提示一个错误，宏将中止执行。稍后我们将会用到这一特点，所以请大家牢记这种用法。

以串行方式执行宏
我们可以用 @a 执行刚刚录制好的宏，它将执行以下步骤：首先，把光标移到该行首个 . 字符上，把 . 改成 ) ，然后，将下一个单词的首字母变为大写，最后，将光标移至下一行。
我们可以调用3次 @a 命令完成这次任务，但运行 3@a 会更快：

宏在执行到第3行时停了下来，没错，就是那行注释。f. 命令没有在这行发现字符 . ，于是宏被中止执行了。安全捕获机制截住了我们，这也是个好事情，因为如果该宏成功地在这行执行了，也就意味着它做了我们可能根本不想要的修改。

我们又重新录制了宏。这一次，除了省略向下移动的 j 命令（最后一条）外，宏命令没变，因为这一次，我们不再需要它移动光标至下一行了。
:normal @a 命令指示 Vim 在高亮选区中的每一行上执行这个宏。

我们在之前的宏中使用～命令切换光标所在处的字母大小写（参见:h ～￼）。而这一次，我们用新命令vU替换～命令，它会把光标处的字母变为大写（参见:h v_U￼）。

将宏粘贴到文档中
用于录制宏的寄存器，与用作复制、粘贴操作的寄存器是一样的。因此，如果我们想修改寄存器 a中的宏的话，只需将其粘贴至文档中，便可以像编辑普通文本一样编辑它了。
首先，我们按G键，跳到当前文档的结尾，目的是要把寄存器a中的内容粘贴至新的一行。处理这种情况最简单的方式是用 :put命令：

我们依次运行命令 0 以及 "ay$，将把该行除回车符之外的每一个字符都复制下来。

### 第13章 查找

查找提示符始终以 / 或者 ? 字符开头，表明此次查找的扫描方向。

果我们用 / 执行一次正向查找，n将继续向下查找；而如果最初的查找命令是 ? 的话，n 将继续向上查找。同时，N 命令将始终与上一次查找的方向保持相反。

如果我们的模式匹配某个完整的单词，则可以用e或者iw操作这个单词

### 第六部分 工具

“只做一件事，并做到极致”是Unix哲学的精髓所在。

### 第21章 接下来干什么

持之以恒地使用Vim。因为通过训练，曾经很棘手的事情都将变成你的第二天性，你应该把“不加思考就能用Vim完成操作”当成你的目标。一旦你达到了这种水平，就能以思考的速度编辑文本了。