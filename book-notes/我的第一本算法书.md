## 我的第一本算法书
> 宫崎修一 石田保辉

### 前言

使用不同的算法解决同一个问题时，就算得到的结果是一样的，算法之间的性质也有很大的差异。比如，某个算法的运行时间很短，但需要占用大量内存；而另一个算法运行时间较长，但内存资源占用较少。学习各种算法可以使我们在编程时有更多的选择。成为优秀程序员的必要条件之一，就是可以根据应用场景选择最合适的算法。

算法是解决问题的计算步骤，用于编写程序之前。即使是解决同样的问题，高效算法和低效算法所花费的时间也迥然不同。另外，要想执行高效的算法，还需要使用合适的数据结构。本书的目的就是让初学者也能轻松地理解算法和数据结构。

### 序章 算法的基本知识

算法就是计算或者解决问题的步骤。我们可以把它想象成食谱。

只解决这一个问题很简单，但是算法是可以应对任意输入的计算步骤，所以必须采用通用的描述。虽然在这个示例中输入的整数个数n为8，然而不管n多大，算法都必须将问题解决。

是不是先从输入的数字中找出最小的数字，再将它和最左边的数字交换位置呢？

计算机擅长高速执行一些基本命令，但无法执行复杂的命令。此处的“基本命令”指的是“做加法”或者“在指定的内存地址上保存数据”等。

我们就把这个算法称为“全排列算法”吧。全排列算法列出了所有的排列方法，所以不管输入如何，都可以得到正确的结果。
那么，需要等多久才能出结果呢？若运气好，很快就能出现正确排列的话，结果也就立马出来了。然而，实际情况往往并不如我们所愿。最差的情况，也就是直到最后才出现正确排列的情况下，计算机就不得不确认所有可能的排列了。

也就是说，仅仅是对50个数字进行排序，若使用全排列算法，就算花费宇宙年龄的109倍时间也得不出答案。

### 0-2 运行时间的计算方法

也就是说，对式子影响最大的是n2。所以，我们删掉其他部分，将结果表示成下式右边的形式。

O这个符号的意思是“忽略重要项以外的内容”，读音同Order。O（n2）的含义就是“算法的运行时间最长也就是n2的常数倍”，准确的定义请参考相关专业书籍。重点在于，通过这种表示方法，我们可以直观地了解算法的时间复杂度￼。

我们知道选择排序的时间复杂度为O（n2）、快速排序的时间复杂度为O（nlogn）时，很快就能判断出快速排序的运算更为高速。二者的运行时间根据输入n产生的变化程度也一目了然。

### 第1章 数据结构

数据存储于内存时，决定了数据顺序和位置关系的便是“数据结构”。

将数据存储于内存时，根据使用目的选择合适的数据结构，可以提高内存的利用率。

### 1-2 链表

链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间。

在链表中，数据一般都是分散存储于内存中的，无须存储在连续空间内。

因为数据都是分散存储的，所以如果想要访问数据，只能从第1个数据开始，顺着指针的指向一一往下访问（这便是顺序访问）。

这便是“循环链表”，也叫“环形链表”。循环链表没有头和尾的概念。想要保存数量固定的最新数据时通常会使用这种链表。

上文链表里的每个数据都只有一个指针，但我们可以把指针设定为两个，并且让它们分别指向前后数据，这就是“双向链表”。使用这种链表，不仅可以从前往后，还可以从后往前遍历数据，十分方便。
但是，双向链表存在两个缺点：一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。

### 1-3 数组

在数组中，访问数据十分简单，而添加和删除数据比较耗工夫

由于数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”）。

### 1-4 栈

栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取。

栈只能在一端操作这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。

比如，规定（AB（C（DE）F）（G（（H）I J）K））这一串字符中括号的处理方式如下：首先从左边开始读取字符，读到左括号就将其入栈，读到右括号就将栈顶的左括号出栈。此时，出栈的左括号便与当前读取的右括号相匹配。通过这种处理方式，我们就能得知配对括号的具体位置。

### 1-5 队列

但队列中添加和删除数据的操作分别是在两端进行的

“先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。比

### 1-6 哈希表

在哈希表这种数据结构中，使用将在5-3节讲解的“哈希函数”，可以使数据的查询效率得到显著提升。

使用哈希函数（Hash）计算Joe的键，也就是字符串“Joe”的哈希值。得到的结果为4928（哈希函数的详细说明在5-3节）。

在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。

在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。

### 1-7 堆

堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为O（1）。

### 2-7 快速排序

快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。

快速排序是一种“分治法”。它将原本的问题分成两个子问题（比基准值小的数和比基准值大的数），然后再分别解决这两个问题。子问题，也就是子序列完成排序后，再像一开始说明的那样，把他们合并成一个序列，那么对原始序列的排序也就完成了。

不过，解决子问题的时候会再次使用快速排序，甚至在这个快速排序里仍然要使用快速排序。只有在子问题里只剩一个数字的时候，排序才算完成。

### 第3章 数组的查找

线性查找需要从头开始不断地按顺序检查数据，因此在数据量大且目标数据靠后，或者目标数据不存在时，比较的次数就会更多，也更为耗时。若数据量为n，线性查找的时间复杂度便为O（n）。

### 3-2 二分查找

二分查找也是一种在数组中查找数据的算法。和3-1节讲到的线性查找不同，它只能查找已经排好序的数据。二分查找通过比较数组中间的数据与目标数据的大小，可以得知目标数据是在数组的左边还是右边。因此，比较一次就可以把查找范围缩小一半。重复执行该操作就可以找到目标数据，或得出目标数据不存在的结论。

二分查找利用已排好序的数组，每一次查找都可以将查找范围减半。查找范围内只剩一个数据时查找结束。

二分查找的时间复杂度为O（logn），与线性查找的O（n）相比速度上得到了指数倍提高（x=log2n，则n=2x）。

而使用线性查找时，数组中的数据可以是无序的，因此添加数据时也无须顾虑位置，直接把它加在末尾即可，不需要耗费时间。

### 第5章 安全算法

为了应对第一个问题“窃听”，我们会使用 “加密”技术。
为了应对第二个问题“假冒”，我们会使用“消息认证码”（下图左）或“数字签名”（下图右）技术。

### 5-2 加密的基础知识

在加密运算上会用到“密钥”。所以加密就是用密钥对数据进行数值运算，把数据变成第三者无法理解的形式的过程（

### 5-3 哈希函数

输出固定长度的无规律数值。把哈希函数想像成搅拌数据的搅拌机就很容易理解了。输出

第一个特征是输出的哈希值数据长度不变。

即使输入了相当大的数据，输出的哈希值的长度也保持不变。

第二个特征是如果输入的数据相同，那么输出的哈希值也必定相同。

第三个特征是即使输入的数据相似，但哪怕它们只有一比特的差别，那么输出的哈希值也会有很大的差异。输入相似的数据并不会导致输出的哈希值也相似。

第四个特征是即使输入的两个数据完全不同，输出的哈希值也有可能是相同的，虽然出现这种情况的概率比较低。这种情况叫作“哈希冲突”。
11

哈希函数的算法中具有代表性的是MD5￼、SHA-1￼和SHA-2等。其中SHA-2是现在应用较为广泛的一个，而MD5和SHA-1存在安全隐患，不推荐使用。

### 5-4 共享密钥加密

共享密钥加密是加密和解密都使用相同密钥的一种加密方式。由于使用的密钥相同，所以这种算法也被称为“对称加密”。

实现共享密钥加密的算法有凯撒密码、AES￼、DES￼、动态口令等，其中AES的应用最为广泛。

但是，该密钥也有可能会被X窃听。这样一来，X也可以使用密钥对密文进行解密了。

### 5-5 公开密钥加密

加密是加密和解密使用不同密钥的一种加密方法。由于使用的密钥不同，所以这种算法也被称为“非对称加密”。加密用的密钥叫作“公开密钥”，解密用的叫作“私有密钥”。
01

需要由接收方B来生成公开密钥￼和私有密钥￼。

然后把公开密钥发送给A。

A使用B发来的公开密钥加密数据。

实现公开密钥加密的算法有RAS算法、椭圆曲线加密算法等，其中使用最为广泛的是RSA算法。RSA算法由其开发者Rivest、Shamir、Adleman的首字母命名而来，三人在2002年获得了图灵

B用私有密钥对收到的密文进行解密，取得原本的数据。这种情况就不需要为每个发送对象都准备相对应的密钥了。需要保密的私有密钥仅由接收方保管，所以安全性也更高。
14

于是公开密钥PX传到了A那里。由于公开密钥无法显示自己是由谁生成的，所以A不会发现自己收到的公开密钥已经被人替换。

公开密钥来窃听数据的攻击方法叫作“中间人攻击”（man-in-the-middle attack）。

公开密钥加密还有一个问题，那就是加密和解密都比较耗时，所以这种方法不适用于持续发送零碎数据的情况。要想解决这个问题，就要用到“混合加密”。

### 5-6 混合加密

共享密钥加密存在无法安全传输密钥的密钥分配问题，公开密钥加密又存在加密解密速度较慢的问题。结合这两种方法以实现互补的一种加密方法就是混合加密。

使用处理速度较快的共享密钥加密对数据进行加密。加密时所用的密钥在解密时也要用到，因此A需要把密钥发送给B。

A使用收到的公开密钥，对共享密钥加密中需要使用的密钥进行加密。

接下来，A只要将使用这个密钥加密好的数据发送给B即可。加密数据时使用的是处理速度较快的共享密钥加密。

混合加密在安全性和处理速度上都有优势。能够为网络提供通信安全的SSL协议也应用了混合加密方法。SSL是Secure Sockets Layer（安全套接层）的简写，该协议经过版本升级后，现在已正式命名为TLS（Transport Layer Security，传输层安全）。但是，SSL这个名字在人们心中已经根深蒂固，因此该协议现在也常被称为SSL协议或者SSL / TLS协议。

### 5-8 消息认证码

消息认证码可以实现“认证”和“检测篡改”这两个功能。密文的内容在传输过程中可能会被篡改，这会导致解密后的内容发生变化，从而产生误会。消息认证码就是可以预防这种情况发生的机制。

假设A发送给B的密文在通信过程中被X恶意篡改了，而B收到密文后没有意识到这个问题。

如果使用消息认证码，就能检测出消息已被篡改。

以下简称为MAC（Message Authentication Code）。

我们可以把MAC想象成是由密钥和密文组成的字符串的“哈希值”。计算MAC的算法有HMAC￼、OMAC￼、CMAC￼等。目前，HMAC的应用最为广泛。

B意识到密文或者MAC，甚至两者都可能遭到了篡改。于是B废弃了收到的密文和MAC，向A提出再次发送的请求。
解说

但是，如果原本的消息就是商品编号等无法被人们直接理解的内容，那么解密后接收者便很难判断它是否被篡改。由于密码本身无法告诉人们消息是否被篡改，所以就需要使用消息验证码来检测。

使用MAC时，生成的一方和检测的一方持有同样的密钥，所以不能确定MAC由哪方生成。这个问题可以用下一节将会讲到的“数字签名”来解决。

### 5-9 数字签名

数字签名不仅可以实现消息认证码的认证和检测篡改功能，还可以预防事后否认问题的发生

数字签名的生成使用的是公开密钥加密。
参考：5-5 公开密钥加密

使用私有密钥加密消息。加密后的消息就是数字签名。

它可以保证这个密文的制作者只能是持有私有密钥的A。

能够用A的公开密钥解密的密文，必定是由A生成的。因此，我们可以利用这个结论来确认消息的发送者是否为A，消息是否被人篡改。
由于B只有公开密钥，无法生成A的签名，所以也预防了“事后否认”这一问题的发生。

在公开密钥加密中，用公开密钥加密的数据都可以用私有密钥还原。而本节讲解的数字签名利用的是用私有密钥加密的数据，用公开密钥解密后就能还原这一性质。也就是说，即使密钥的使用顺序不同，运行结果也都是一样的。并不是所有的公开密钥加密都具有这个性质，不过RSA加密算法是可以的。

补充说明
公开密钥加密的加密和解密都比较耗时。为了节约运算时间，实际上不会对消息直接进行加密，而是先求得消息的哈希值，再对哈希值进行加密，然后将其作为签名来使用（请参考下图）

那就是，虽然使用数字签名后B会相信消息的发送者就是A，但实际上也有可能是X冒充了A。
其根本原因在于使用公开密钥加密无法确定公开密钥的制作者是谁。收到的公开密钥上也没有任何制作者的信息。因此，公开密钥有可能是由某个冒充A的人生成的。

### 5-10 数字证书

A首先需要向认证中心（Certification Authority, CA）申请发行证书，证明公开密钥PA确实由自己生成。

A将公开密钥PA和包含邮箱信息的个人资料发送给认证中心。

认证中心对收到的资料进行确认，判断其是否为A本人的资料。确认完毕后，认证中心使用自己的私有密钥SC，根据A的资料生成数字签名。

确认了证书是由认证中心发行的，且邮件地址就是A的之后，B从证书中取出A的公开密钥PA。这样，公开密钥便从A传到了B。

假设X为了假冒A，准备在认证中心登记自己的公开密钥。然而X无法使用A的邮箱地址，因此无法获得A的证书。

最顶端的认证中心被称为“根认证中心”（root CA），其自身的正当性由自己证明。对根认证中心自身进行证明的证书为“根证书”。如果根认证中心不被信任，整个组织就无法运转。因此根认证中心多为大型企业，或者与政府关联且已经取得了社会信赖的组织。

数字证书就是像这样通过认证中心来担保公开密钥的制作者。这一系列技术规范被统称为“公钥基础设施”（Public Key Infrastructure, PKI）。

### 6-2 k-means算法

k-means算法是聚类算法中的一种，它可以根据事先给定的簇的数量进行聚类。

重复执行“将数据分到相应的簇中”和“将中心点移到重心的位置”这两个操作，直到中心点不再发生变化为止。
08

由于k-means算法需要事先确定好簇的数量，所以设定的数量如果不合理，运行的结果就可能会不符合我们的需求。

在层次聚类算法中，一开始每个数据都自成一类。也就是说，有n个数据就会形成n个簇。然后重复执行“将距离最近的两个簇合并为一个”的操作n-1次。每执行1次，簇就会减少1个。执行n-1次后，所有数据就都被分到了一个簇中。在这个过程中，每个阶段的簇的数量都不同，对应的聚类结果也不同。只要选择其中最为合理的1个结果就好。

### 第7章 其他算法

欧几里得算法（又称辗转相除法）用于计算两个数的最大公约数，被称为世界上最古老的算法。

使用欧几里得算法，只需重复做除法便能求得最大公约数。这个算法最大的优势就在于即使两个数字再大，只要按照步骤进行操作就能高效地求得两者的最大公约数。


### 7-3 网页排名

网页排名就是利用网页之间的链接结构计算出网页价值的算法。

但不管是从利用网页链接结构计算出网页价值这种思路来看，还是从链接形成环状时也能进行计算这点来看，网页排名都是一个划时代的算法。

### 7-4 汉诺塔

再次按照之前的操作，把B上的2个圆盘移动到C。于是，3个圆盘的移动也完成了。实际上，不管需要移动多少圆盘，这个游戏最终都能达成目标。我

在算法描述中调用算法自身的方法就叫作“递归”。递归被运用到各种各样的算法中，这些算法统称为“递归算法”

上面的公式即为T（n）=2n-1，这便是解决这个问题所需要的最短时间。
