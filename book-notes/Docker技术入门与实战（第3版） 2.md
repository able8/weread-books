## Docker技术入门与实战（第3版）
> 杨保华 戴王剑 曹亚仑

### 第3版前言

Docker诞生于云计算第一个十年的尾巴上。眨眼间，它所代表的现代容器技术，已经占据了云计算的半壁江山。

### 第1章 初识Docker与容器

在云时代，最为看重的则是凭借虚拟化技术所构建的集群处理能力。

从20世纪60年代IBM推出的大型主机虚拟化，到后来以Xen、KVM为代表的虚拟机虚拟化，再到现在以Docker为代表的容器技术，虚拟化技术自身也在不断进行创新和突破。

容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为“新一代的虚拟化”技术，并将基于容器打造的云平台亲切地称为“容器云”。

### 1.1 什么是Docker

Docker是基于Go语言实现的开源容器项目。它诞生于2013年年初，最初发起者是dotCloud公司。Do

2014年，Docker镜像下载数达到了一百万次，2015年直接突破十亿次，2017年更是突破了惊人的百亿次。

Docker的构想是要实现“Build, Ship and Run Any App, Anywhere”，即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。

Docker首次为应用的开发、运行和部署提供了“一站式”的实用解决方案。

Linux容器（Linux Containers, LXC）技术

### 1.2 为什么要使用Docker

在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须是“任何时间任何地点”可获取的。因此，开发者们需要一种新型的创建分布式应用程序的方式，快速分发和部署，而这正是Docker所能够提供的最大优势。

而Docker提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台。这无疑将帮助我们节约大量的宝贵时间，并降低部署过程出现问题的风险。

❑ 更简单的更新管理。使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。

❑ Docker通过类似Git设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新；
❑ Docker通过Dockerfile支持灵活的自动化创建和部署机制，以提高工作效率，并标准化流程。

### 2.1 核心概念

Docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。

容器是从镜像创建的应用运行实例。它可以启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的。
可以把容器看作一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。

镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。

目前，最大的公开仓库是官方提供的Docker Hub，其中存放着数量庞大的镜像供用户下载。国内不少云服务提供商（如腾讯云、阿里云等）也提供了仓库的本地源，可以提供稳定的国内访问。

可以看出，Docker利用仓库管理镜像的设计理念与Git代码仓库的概念非常相似，实际上Docker设计上借鉴了Git的很多优秀思想。

### 2.2 安装Docker引擎

Docker目前支持的最低Ubuntu版本为14.04 LTS，但实际上从稳定性上考虑，推荐使用16.04 LTS或18.0.4 LTS版本，并且系统内核越新越好，以支持Docker最新的特性。

Ubuntu发行版中，LTS（Long-Term-Support）意味着更稳定的功能和更长期（目前为5年）的升级支持，生产环境中推荐尽量使用LTS版本。

首先需要安装apt-transport-https等软件包支持https协议的源：

添加成功后，再次更新apt软件包缓存：
￼
        $ sudo apt-get update

之后更新yum软件源缓存，并安装Docker：
￼
        $ sudo yum update￼
        $ sudo yum install -y docker-ce
最后，确认Docker服务启动正常：

### 2.3 配置Docker服务

为了避免每次使用Docker命令时都需要切换到特权身份，可以将当前用户加入安装中自动创建的docker用户组，代码如下：
￼
        $ sudo usermod -aG docker USER_NAME
用户更新组信息，退出并重新登录后即可生效。
Docker服务启动时实际上是调用了dockerd命令，支持多种启动参数。因此，用户可以直接通过执行dockerd命令来启动Docker服务，如下面的命令启动Docker服务，开启Debug模式，并监听在本地的2376端口：
￼
        $ dockerd -D -H tcp://127.0.0.1:2376

这些选项可以写入/etc/docker/路径下的daemon.json文件中，由dockerd服务启动时读取：
￼
        {￼
            "debug": true,￼
            "hosts": ["tcp://127.0.0.1:2376"]￼
        }

例如让Docker服务开启网络2375端口的监听：
￼
        DOCKER_OPTS="$DOCKER_OPTS -H tcp://0.0.0.0:2375-H unix:///var/run/docker.sock"

对于CentOS、RedHat等系统，服务通过systemd来管理，配置文件路径为/etc/systemd/system/docker.service.d/docker.conf。更新配置后需要通过systemctl命令来管理Docker服务：
￼
        $ sudo systemctl daemon-reload￼
        $ sudo systemctl start docker.service

此外，如果服务工作不正常，可以通过查看Docker服务的日志信息来确定问题，例如在RedHat系统上日志文件可能为/var/log/messages，在Ubuntu或CentOS系统上可以执行命令journalctl -u docker.service。

### 2.4 推荐实践环境

默认数据网段地址范围为10.0.0.0/24，管理网段地址范围为192.168. 0.0/24。

### 3.2 查看镜像信息

其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。

镜像大小信息只是表示了该镜像的逻辑体积大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像逻辑体积之和。

❑ -q, --quiet=true|false：仅输出ID信息，默认为否。

2．使用tag命令添加镜像标签
为了方便在后续工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签。

3．使用inspect命令查看详细信息
使用docker[image]inspect命令可以获取该镜像的详细信息，包括制作者、适应架构、各层的数字摘要等：

4．使用history命令查看镜像历史
既然镜像文件由多个层组成，那么怎么知道各个层的内容具体是什么呢？这时候可以使用history子命令，该命令将列出各层的创建信息。

注意，过长的命令被自动截断了，可以使用前面提到的--no-trunc选项来输出完整命令。

### 3.3 搜寻镜像

❑ --no-trunc：不截断输出结果。

### 3.4 删除和清理镜像

使用docker rmi或docker image rm命令可以删除镜像，命令格式为docker rmi IMAGE [IMAGE...]，其中IMAGE可以为标签或ID。
支持选项包括：
❑ -f, -force：强制删除镜像，即使有容器依赖它；
❑ -no-prune：不要清理未带标签的父镜像。

注意，当有该镜像创建的容器存在时，镜像文件默认是无法被删除的，例如：先利用ubuntu:18.04镜像创建一个简单的容器来输出一段话：

试图删除该镜像，Docker会提示有容器正在运行，无法删除：
￼
        $ docker rmi ubuntu:18.04￼
        Error  response  from  daemon:  conflict:  unable  to  remove  repository  reference￼
            "ubuntu:18.04" (must force) - container a21c0840213e is using its referenced￼
            image 8f1bd21bd25c
如果要想强行删除镜像，可以使用-f参数：

注意，通常并不推荐使用-f参数来强制删除一个存在容器依赖的镜像。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像。

如下命令会自动清理临时的遗留镜像文件层，最后会提示释放的存储空间：
￼
        $ docker image prune -f￼

### 4.1 创建容器

所需要的命令主要为docker [container] run，等价于先执行docker [container] create命令，再执行docker [container] start命令。

当利用docker [container] run来创建并启动容器时，Docker在后台运行的标准操作包括：
❑ 检查本地是否存在指定的镜像，不存在就从公有仓库下载；
❑ 利用镜像创建一个容器，并启动该容器；
❑ 分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；
❑ 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；
❑ 从网桥的地址池配置一个IP地址给容器；
❑ 执行用户指定的应用程序；
❑ 执行完毕后容器被自动终止。

其中，-t选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。更多的命令选项可以通过man docker-run命令来查看。

对于所创建的bash容器，当用户使用exit命令退出bash进程之后，容器也会自动退出。这是因为对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。

❑ 125:Docker daemon执行出错，例如指定了不支持的Docker命令参数；
❑ 126：所指定命令无法执行，例如权限出错；
❑ 127：容器内命令无法找到。

更多的时候，需要让Docker容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加-d参数来实现。

要获取容器的输出信息，可以通过docker [container] logs命令。
该命令支持的选项包括：
❑ -details：打印详细信息；
❑ -f, -follow：持续保持输出；
❑ -since string：输出从某个时间开始的日志；
❑ -tail string：输出最近的若干日志；
❑ -t, -timestamps：显示时间戳信息；

### 4.2 停止容器

该命令会首先向容器发送SIGTERM信号，等待一段超时时间后（默认为10秒），再发送SIGKILL信号来终止容器：

### 4.3 进入容器

在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。
这个时候如果需要进入容器进行操作，推荐使用官方的attach或exec命令。

❑ -i, --interactive=true|false：打开标准输入接受用户输入命令，默认值为false；


❑ -t, --tty=true|false：分配伪终端，默认值为false；
❑ -u, --user=""：执行命令的用户名或ID。

### 4.6 查看容器

2．查看容器内进程
查看容器内进程可以使用docker [container] top [OPTIONS] CONTAINER [CONTAINER...]子命令。

查看统计信息可以使用docker [container] stats [OPTIONS] [CONTAINER...]子命令

❑ -no-stream：不持续输出，默认会自动更新持续实时结果；
❑ -no-trunc：不截断输出信息。
例如，查看当前运行中容器的系统资源使用统计：

### 4.7 其他容器命令

例如，将本地的路径data复制到test容器的/tmp路径下：
￼
        docker [container] cp data test:/tmp/

container diff查看容器内文件系统的变更。命令格式为docker [container] diff CONTAINER。
例如，查看test容器内的数据修改：

container port命令可以查看容器的端口映射情况。

### 5.3 搭建本地私有仓库

安装Docker后，可以通过官方提供的registry镜像来简单搭建一套本地私有仓库环境：
￼
        $ docker run -d -p 5000:5000 registry:2
这将自动下载并启动一个registry容器，创建本地的私有仓库服务。

比较新的Docker版本对安全性要求较高，会要求仓库支持SSL/TLS证书。对于内部使用的私有仓库，可以自行配置证书或关闭对仓库的安全性检查。

首先，修改Docker daemon的启动参数，添加如下参数，表示信任这个私有仓库，不进行安全证书检查：
￼
        DOCKER_OPTS="--insecure-registry 10.0.2.2:5000"

### 第6章 Docker数据管理

容器中的管理数据主要有两种方式：
❑ 数据卷（Data Volumes）：容器内数据直接映射到本地主机环境；
❑ 数据卷容器（Data Volume Containers）：使用特定容器维护数据卷。

### 6.1 数据卷

数据卷（Data Volumes）是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount行为。

数据卷可以提供很多有用的特性：
❑ 数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便；
❑ 对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；
❑ 对数据卷的更新不会影响镜像，解耦开应用和数据；
❑ 卷会一直存在，直到没有容器使用，可以安全地卸载它。

除了create子命令外，docker volume还支持inspect（查看详细信息）、ls（列出已有数据卷）、prune（清理无用数据卷）、rm（删除数据卷）等，读者可以自行实践。

上述命令等同于使用旧的-v标记可以在容器内创建一个数据卷：
￼
        $ docker run -d -P --name web -v /webapp:/opt/webapp training/webapp python app.py
这个功能在进行应用测试的时候十分方便，比如用户可以放置一些程序或数据到本地目录中实时进行更新，然后在容器内运行和使用。

Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读：

### 6.2 数据卷容器

如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门提供数据卷给其他容器挂载。

可以在其他容器中使用--volumes-from来挂载dbdata容器中的数据卷，例如创建db1和db2两个容器，并从dbdata容器挂载数据卷：

此时，容器db1和db2都挂载同一个数据卷到相同的/dbdata目录，三个容器任何一方在该目录下的写入，其他容器都可以看到。

如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。

### 7.1 端口映射实现容器访问

-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有IP:HostPort:ContainerPort

3．映射到指定地址的指定端口
可以使用IP:HostPort:ContainerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1：

使用docker port来查看当前映射的端口配置，也可以查看到绑定的地址：

### 7.2 互联机制实现便捷互访

容器的名称是唯一的。如果已经命名了一个叫web的容器，当你要再次使用web这个名称的时候，需要先用docker rm命令删除之前创建的同名容器。

使用--link参数可以让容器之间安全地进行交互。

--link参数的格式为--link name:alias，其中name是要链接的容器的名称，alias是别名。

db也有web/db。这表示web容器链接到db容器，web容器将被允许访问db容器的信息。

ping db￼

### 9.2 Alpine

Alpine操作系统是一个面向安全的轻型Linux发行版，关注安全，性能和资源效能。不同于其他发行版，Alpine采用了musl libc和BusyBox以减小系统的体积和运行时资源消耗，比BusyBox功能上更完善。在保持瘦身的同时，Alpine还提供了包管理工具apk查询和安装软件包。

目前Docker官方推荐使用Alpine作为默认的基础镜像环境，这可以带来多个优势，如镜像下载速度加快、镜像安全性提高、主机之间的切换更方便、占用更少磁盘空间等。

3．迁移至Alpine基础镜像
目前，大部分Docker官方镜像都已经支持Alpine作为基础镜像，可以很容易进行迁移。例如：
❑ ubuntu/debian -> alpine
❑ python:2.7-> python:3.6-alpine
❑ ruby:2.6-> ruby:2.6-alpine

### 9.4 CentOS/Fedora

CentOS和Fedora都是基于Redhat的Linux发行版。CentOS是目前企业级服务器的常用操作系统；Fedora则主要面向个人桌面用户。

### 10.1 基于commit命令创建

可以替换为国内163、sohu等镜像的源。以163源为例，在容器内创建/etc/apt/sources.list.d/163.list文件：
￼
        root@fc1936ea8ceb:/# vi /etc/apt/sources.list.d/163.list

3．安装和配置SSH服务
更新软件包缓存后可以安装SSH服务了，选择主流的openssh-server作为服务端。可以看到需要下载安装众多的依赖软件包：
￼
        root@fc1936ea8ceb:/# apt-get install openssh-server
如果需要正常启动SSH服务，则目录 /var/run/sshd必须存在。下面手动创建它，并启动SSH服务：

### 11.2 Nginx

Nginx（发音为“engine-x”）是一款功能强大的开源反向代理服务器，支持HTTP、HTTPS、SMTP、POP3、IMAP等协议。它也可以作为负载均衡器、HTTP缓存或Web服务器。

Nginx特性如下：
❑ 热部署：采用master管理进程与worker工作进程的分离设计，支持热部署。在不间断服务的前提下，可以直接升级版本。也可以在不停止服务的情况下修改配置文件，更换日志文件等。
❑ 高并发连接：Nginx可以轻松支持超过100K的并发，理论上支持的并发连接上限取决于机器内存。

3．参数优化
为了能充分发挥Nginx的性能，用户可对系统内核参数做一些调整。下面是一份常见的适合运行Nginx服务器的内核优化参数：
￼
        net.ipv4.ip_forward = 0￼
        net.ipv4.conf.default.rp_filter = 1￼
        net.ipv4.conf.default.accept_source_route = 0￼
        kernel.sysrq = 0￼
        kernel.core_uses_pid = 1￼
        net.ipv4.tcp_syncookies = 1￼


        net.ipv4.tcp_synack_retries = 1￼
        net.ipv4.tcp_syn_retries = 1￼
        net.ipv4.tcp_tw_recycle = 1￼
        net.ipv4.tcp_tw_reuse = 1￼
        net.ipv4.tcp_mem = 94500000915000000927000000￼
        net.ipv4.tcp_fin_timeout = 1￼
        net.ipv4.tcp_keepalive_time = 30￼
        net.ipv4.ip_local_port_range = 102465000

### 11.3 Tomcat

Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持。同时，它提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，也可以当作单独的Web服务器来使用。

### 11.4 Jetty

Jetty是一个优秀的开源servlet容器，以其高效、小巧、可嵌入式等优点深得人心，它为基于Java的Web内容（如JSP和servlet）提供运行环境。Jetty基于Java语言编写

### 第13章 分布式处理与大数据平台

分布式系统和大数据处理平台是目前业界关注的热门技术。本章将重点介绍热门的大数据分布式处理的三大重量级武器：Hadoop、Spark、Storm，以及新一代的数据采集和分析引擎Elasticsearch。
围绕如何基于Docker快速部署和使用这些工具，读者将能学习到相关的操作实践，并能领略分布式处理技术在大数据领域的重要用途。

### 13.1 Hadoop

Hadoop主要基于Java语言实现，由三个核心子系统组成：HDFS、YARN、MapReduce，其中，HDFS是一套分布式文件系统；YARN是资源管理系统，MapReduce是运行在YARN上的应用，负责分布式处理管理。如果从操作系统的角度看，HDFS相当于Linux的ext3/ext4文件系统，而Yarn相当于Linux的进程调度和内存分配模块。

### 15.2 容器云服务

时速云做基于Kubernetes的CaaS平台，以容器化应用作为交付的标准，立足于公有云，为开发者和企业提供了一个快速构建、集成、部署、运行容器化应用的平台，帮助开发者和企业提高应用开发的迭代效率，简化运维环节，降低运维成本。客户包括华大基因、京东方、中国移动、新浪、腾讯等重量级用户。

❑ 企业级镜像仓库：集群化部署、多角色权限控制、集成企业LDAP、增强扩展组件、可视化管理；
❑ 持续集成和持续交付（CI/CD）：轻松云端构建、定制集成、部署规则、事件触发定义、关键环节审核；
❑ 镜像及安全服务中心：多层次镜像扫描、服务安全防护、可视化审查、第三方规则接入。

### 15.3 阿里云容器服务

❑ 简单易用：一键创建容器集群，全兼容Docker Compose模板编排应用，支持图形化界面和Open API，一站式网络、存储、日志、监控、调度、路由和持续发布管理；

### 15.4 时速云介绍

1．企业级容器PaaS平台
基于容器技术打造云原生的容器PaaS产品，立足企业开发、测试及IT管理需求，提供一站式容器云平台，从而帮助企业IT数字化转型，为企业提供轻量、快速、高效、更友好的服务运行及开发环境。

2．开发运维一体化DevOps
提供自动化的持续集成能力（包括代码构建、代码分析、自动测试、编译环境、文档生成、事件通知、定时器、人工审核等），帮助用户尽早发现集成错误，实现人工干预，让开发运维协调一致，优化企业应用交付流程。

3．微服务治理
时速云微服务治理平台是基于Spring Cloud和Pinpoint等开源组件开发的面向企业的容器化微服务架构应用托管平台，帮助企业简化部署、监控、运维、治理与微服务生命周期的管理，并实现不同环境之间的跨系统、跨协议的服务互通。

### 17.4 联合文件系统

联合文件系统（UnionFS）是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，应用看到的是挂载的最终结果。联合文件系统是实现Docker镜像的技术基础。

❑ AUFS：最早支持的文件系统，对Debian/Ubuntu支持好，虽然没有合并到Linux内核中，但成熟度很高；

❑ overlay 2:Docker 1.12后推出，原生支持128层，效率比OverlayFS高，较新版本的Docker支持，要求内核大于4.0；

### 17.5 Linux网络虚拟化

Docker的本地网络实现其实就是利用了Linux上的网络命名空间和虚拟网络设备（特别是veth pair）。熟悉这两部分的基本概念有助于理解Docker网络的实现过程。

Docker中的网络接口默认都是虚拟接口。虚拟接口的最大优势就是转发效率极高。这是因为Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发，即发送接口的发送缓存中的数据包将被直接复制到接收接口的接收缓存中，而无须通过外部物理网络设备进行交换。对

Docker容器网络就很好地利用了Linux虚拟网络技术，它在本地主机和容器内分别创建一个虚拟接口veth，并连通（这样的一对虚拟接口叫做veth pair）

1）创建一对虚拟接口，分别放到本地主机和新容器的命名空间中；

❑ --net=host：告诉Docker不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程跟主机其他root进程一样可以打开低范围的端口，可以访问本地网络服务（比如D-bus），还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步使用--privileged=true参数，容器甚至会被允许直接配置主机的网络栈；

### 20.1 启动与配置参数

Docker服务启动时会首先在主机上自动创建一个docker0虚拟网桥，实际上是一个Linux网桥。网桥可以理解为一个软件交换机，负责挂载其上的接口之间进行包转发。

docker0接口。比如典型的172.17.0.0/16网段，掩码为255.255.0.0。此后启动的容器内的网口也会自动分配一个该网段的地址。

当创建一个Docker容器的时候，同时会创建了一对veth pair互联接口。当向任一个接口发送包时，另外一个接口自动收到相同的包。互联接口的一端位于容器内，即eth0；另一端在本地并被挂载到docker0网桥，名称以veth开头（例如vethAQI2QT）。通过这种方式，主机可以与容器通信，容器之间也可以相互通信。如此一来，Docker就创建了在主机和所有容器之间一个虚拟共享网络，

### 20.3 容器访问控制

容器的访问控制主要通过Linux上的iptables防火墙软件来进行管理和实现。iptables是Linux系统流行的防火墙软件，在大部分发行版中都自带。

### 20.4 映射容器端口到宿主主机的实现

映射是通过iptables的源地址伪装操作实现的。查看主机nat表上POSTROUTING链的规则。该链负责网包要离开主机前，改写其源地址：

其中，上述规则将所有源地址在172.17.0.0/16网段，且不是从docker0接口发出的流量（即从容器中出来的流量），动态伪装为从系统网卡发出。MASQUERADE行动与传统SNAT行动相比，好处是能动态地从网卡获取地址。

其实也是在本地的iptable的nat表中添加相应的规则，将访问外部IP地址的包进行目标地址DNAT，将目标地址修改为容器的IP地址。

### 27.4 控制器抽象对象

Daemon集的应用会确保在指定类型的每个节点上都运行一个该应用的Pod。可能是集群中所有节点，也可能是指定标签的一类节点。

### 27.9 网络设计

其实Docker默认采用iptables实现NAT的方式（后来也支持overlay模式，但所提出的CNM规范未被Kubernetes接纳）已经通过借用主机地址组成了简单的网络了。但Kubernetes认为NAT方式实现跨节点通信就需要占用本地端口映射，这会给服务层面的访问带来麻烦。

可以有两种设计思路：直接路由和Overlay网络。

这种思路最简单，所有Pod直接暴露在物理网络上，大家彼此的地址可见，不能有地址冲突，不同子网之间通过路由机制进行三层转发。此时，各个Node上会创建cbr0网桥，并且需要在开启本地转发支持：
￼
        $ sysctl net.ipv4.ip_forward=1
另外，配置Docker服务的默认网桥，并且取消Docker对iptables的自动修改：
￼
        DOCKER_OPTS="--bridge=cbr0--iptables=false --ip-masq=false"

为了让Pod可以通过Node地址来访问外网（因为Pod的私有数据地址是无法路由到外部的），可以配置SNAT：
￼
        $ iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8-o eth0-j MASQUERADE
这种实现的最大优势是简洁，可以直接复用底层的物理设备。目前，包括Google的GCE和微软的容器云都支持这种模式。

### 28.3 编程开发

由于Docker服务端提供了REST风格的API，通过对这些API进一步的封装，可以提供给各种开发语言作为Docker的SDK。这里以docker-py项目为例，介绍在Python语言中对Docker相关资源进行操作。

### 28.4 网络支持

该工具封装了底层通过ip、brctl等网络设备操作的命令，可以简化在比较复杂的场景中对容器连接的操作命令。

使用该工具，可以轻松地配置容器的IP地址、为容器划分VLan等功能

Flannel采用了典型的覆盖网络的思路，在每个主机上添加一个隧道端点，所有跨主机的流量会经过隧道端点进行隧道封包（典型为VXLAN协议，Docker Swarm也支持），直接发送到对端

与传统的基于覆盖网络的网络虚拟化方案类似，这种设计的优势在于有很好的扩展性，只要IP连通的主机即可构成同一个虚拟网络，甚至可以跨数据中心。问题也很明显，一个是隧道协议目前还比较难追踪，另一个是解包和封包处理负载重，如果没有硬件进行处理则往往性能会有损耗。另外，当中间路径存在负载均衡设备时，要避免均衡失效。

解决容器网络跨主机问题的思路主要是打通跨主机容器之间的通信，手段无非是用覆盖网络建立隧道，或者通过更改包头进行转发。

Calico的设计则更为直接，干脆不支持网络虚拟化，直接采用传统的路由转发机制，也是在每个节点上配置一个vRouter，负责处理跨主机的流量。vRouter之间通过BGP自动学习转发策略，如图28-12所示。

由于Calico不采用隧道格式，而是依赖于传统的IP转发，这就限制了它的应用场景，无法跨数据中心，无法保障中间路径安全。但反之带来了容易管理、转发性能会好的一些优势。

### 附录

．本地的镜像文件都存放在哪里？
答：与Docker相关的本地资源（包括镜像、容器）默认存放在/var/lib/docker/目录下。以aufs文件系统为例，其中container目录存放容器信息，graph目录存放镜像信息，aufs目录下存放具体的镜像层文件。

❑ 清理编译生成文件、安装包的缓存等临时文件；
❑ 安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；
❑ 从安全角度考虑，应用要尽量使用系统的库和依赖；

❑ 区分编译环境容器和运行时环境容器，使用多阶段镜像创建。

8．碰到网络问题，无法pull镜像，命令行指定http_proxy无效，怎么办？
答：在Docker配置文件中添加export http_proxy="http://<PROXY_HOST>:<PROXY_PORT>"，之后重启Docker服务即可。

1．容器退出后，通过docker ps命令查看不到，数据会丢失么？
答：容器退出后会处于终止（exited）状态，此时可以通过docker ps -a查看。其中的数据也不会丢失，还可以通过docker [container] start命令来启动它。只有删除掉容器才会清除所有数据。

4．如何获取某个容器的PID信息？
答：可以使用docker [container] inspect --format '{{ .State.Pid }}'<CONTAINER ID or NAME>命令。
5．如何获取某个容器的IP地址？
答：可以使用docker [container] inspect --format '{{ .NetworkSettings. IPAddress }}' <CONTAINER ID or NAME>命令。

1. Docker与LXC（Linux Container）有何不同？
答：LXC利用Linux上相关技术实现了容器支持；Docker早期版本中使用了LXC技术，后期演化为新的libcontainer，在如下的几个方面进行了改进：
❑ 移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台；
❑ 镜像系统：基于AUFS的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；
❑ 版本管理：类似于Git的版本管理理念，用户可以更方便地创建、管理镜像文件；

Vagrant是一套虚拟机的管理环境。Vagrant可以在多种系统上和虚拟机软件中运行，启动一个完整的操作系统环境，可以在Windows、Mac等非Linux平台上为Docker提供支持，自身具有较好的包装性和移植性

Docker则面向应用层隔离，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。

简单说：Vagrant适合用来管理虚拟机，而Docker适合用来管理应用环境。

2．如何将一台宿主主机的Docker环境迁移到另外一台宿主主机？
答：停止Docker服务。将整个Docker存储文件夹（如默认的/var/lib/docker）复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。


        1234
2）在/proc目录下，把对应的网络命名空间文件链接到/var/run/netns目录：
￼
        $ sudo ln -s /proc/1234/ns/net /var/run/netns/
3）在宿主主机上就可以看到容器的网络命名空间信息。例如：
￼
        $ sudo ip netns show￼
        1234

此时，用户可以通过正常的系统命令来查看或操作容器的命名空间了。例如修改容器的IP地址信息为172.17.0.100/16：
￼
        $ sudo ip netns exec 1234 ifconfig eth0172.17.0.100/16