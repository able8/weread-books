## 疯狂Java讲义（第2版）
> 李刚编著

### 第1章 Java语言概述

Java语言是一门非常纯粹的面向对象编程语言，它吸收了C++语言的各种优点，又摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。

### 1.1 Java语言的发展简史

1990年年末，Sun公司预料嵌入式系统将在未来家用电器领域大显身手。于是Sun公司成立了一个由JamesGosling领导的“Green计划”，准备为下一代智能家电（如电视机、微波炉、电话）编写一个通用控制系统。该团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家Bill Joy，发现C++和可用的API在某些方面存在很大问题。而且工作小组使用的是嵌入式平台，可用的系统资源极其有限。并且很多成员都发现C++太复杂，以致很多开发者经常错误使用。而且C++缺少垃圾回收系统、可移植性、分布式和多线程等功能。

### 1.3 Java程序运行机制

Java语言比较特殊，由Java语言编写的程序需要经过编译步骤，但这个编译步骤并不会生成特定平台的机器码，而是生成一种与平台无关的字节码（也就是*.class文件）。当然，这种字节码不是可执行性的，必须使用Java解释器来解释执行。因此，我们可以认为：Java语言既是编译型语言，也是解释型语言。或者说，Java语言既不是纯粹的编译型语言，也不是纯粹的解释型语言。Java程序的执行过程必须经过先编译，后解释两个步骤，

Java语言里负责解释执行字节码文件的是Java虚拟机，即JVM（Java Virtual Machine）。JVM是可运行Java字节码文件的虚拟计算机。所有平台上的JVM向编译器提供相同的编程接口，而编译器只需要面向虚拟机，生成虚拟机能理解的代码，然后由虚拟机来解释执行。在一些虚拟机的实现中，还会将虚拟机代码转换成特定系统的机器码执行，从而提高执行效率。

当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体平台，只面向JVM。不同平台上的JVM都是不同的，但它们都提供了相同的接口。JVM是Java程序跨平台的关键部分，只要为不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。显然，相同的字节码程序需要在不同的平台上运行，这几乎是“不可能的”，只有通过中间的转换器才可以实现，JVM就是这个转换器。JVM是一个抽象的计算机，和实际的计算机一样，它具有指令集并使用不同的存储区域。它负责执行指令，还要管理数据、内存和寄存器。

### 1.4 开发Java的准备

JDK的全称是Java SE Development Kit，即Java标准版开发包，是Sun提供的一套用于开发Java应用程序的开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。

Java运行时环境，它的全称是Java Runtime Environment，因此也被称为JRE，它是运行Java程序的必需条件。

简单地说，JRE包含JVM。JVM是运行Java程序的核心虚拟机，而运行Java程序不仅需要核心虚拟机，还需要其他的类加载器、字节码校验器以及大量的基础类库。JRE除了包含JVM之外，还包含运行Java程序的其他环境支持。

如果需要开发Java程序，则应该选择安装JDK；当然，安装了JDK之后，就包含了JRE，也可以运行Java程序。但如果只是运行Java程序，则需要在计算机上安装JRE

[插图] jre：该路径下安装的就是运行Java程序所必需的JRE环境。

### 1.5 第一个Java程序

java命令后的参数是Java类名，而不是字节码文件的文件名，也不是Java源文件名。

### 1.6 Java程序的基本规则

Java程序是一种纯粹的面向对象的程序设计语言，因此Java程序必须以类（class）的形式存在，类（class）是Java程序的最小程序单位。Java程序不允许可执行性语句、方法等成分独立存在，所有的程序部分都必须放在类定义里。

Java解释器规定：如需某个类能被解释器直接解释执行，则这个类里必须包含main方法，而且main方法必须使用public staticvoid来修饰，且main方法的形参必须是字符串数组类型（String[] args是字符串数组的形式）。也就是说，main方法的写法几乎是固定的。Java解释器就从这个main方法开始解释执行，因此，main方法是Java程序的入口

如果Java程序源代码里定义了一个public类，则该源文件的主文件名必须与该public类（也就是该类定义使用了public关键字修饰）的类名相同。

由于Java程序源文件的文件名必须与public类的类名相同，因此，一个Java源文件里最多只能定义一个public类。

### 1.7 垃圾回收机制

显式进行垃圾回收主要有如下两个缺点。[插图] 程序忘记及时回收无用内存，从而导致内存泄漏，降低系统性能。[插图] 程序错误地回收程序核心类库的内存，从而导致系统崩溃。

Java语言不需要程序员直接控制内存回收，Java程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收（Garbage Collection，也被称为GC）。通常JRE会提供一个后台线程来进行检测和控制，一般都是在CPU空闲或内存不足时自动进行垃圾回收，而程序员无法精确控制垃圾回收的时间和顺序等。

### 2.1 面向对象

采用面向对象方式开发的软件系统，其最小的程序单元是类，这些类可以生成系统中的多个对象，而这些对象则直接映像成客观世界的各种事物。

面向对象的语言不仅使用类来封装一类事物的内部状态数据，这种状态数据就对应于图2.7中的Field；而且类会提供操作这些状态数据的方法，还会为这类事物的行为特征提供相应的实现，这种实现也是方法。

在面向过程的程序世界里，一切以函数为中心，函数最大，因此这件事情会用如下语句来表达：[插图]在面向对象的程序世界里，一切以对象为中心，对象最大，因此这件事情会用如下语句来表达：[插图]

对比两条语句不难发现，面向对象的语句更接近自然语言的语法：主语、谓语、宾语一目了然，十分直观，因此程序员更易理解。

### 2.3 Java的面向对象特征

在Java语言中，除了8个基本数据类型值之外，一切都是对象，而对象就是面向对象程序设计的中心。对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。

具有相同或相似性质的一组对象的抽象就是类，类是对一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称为实例（instance）。

### 3.1 注释

将双斜线（//）放在需要注释的内容之前，就可以了；多行注释是指一次性地将程序中多行代码注释掉，在Java语言中，使用“/*”和“*/”将程序中需要注释的内容包含起来，“/*”表示注释开始，而“*/”表示注释结束。

### 3.2 标识符和关键字

Java语言采用分号（;）作为语句的分隔，因此每个Java语句必须使用分号作为结尾。Java程序允许一行书写多个语句，每个语句之间以分号隔开即可；一个语句也可以跨多行，只要在最后结束的地方使用分号结束即可。

### 3.3 数据类型分类

引用类型包括类、接口和数组类型，还有一种特殊的null类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种

空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个null值赋给基本数据类型的变量。

### 3.4 基本数据类型

字符常量必须使用单引号（'）括起来。Java语言使用16位的Unicode字符集作为编码方式，而Unicode被设计成支持世界上所有书面语言的字符，包括中文字符，因此Java程序支持各种语言的字符。

字符型常量有如下3种表示形式。[插图] 直接通过单个字符来指定字符型常量，例如'A'、'9'和'0'等。[插图] 通过转义字符表示特殊字符型常量，例如'\n'、'\t'等。[插图] 直接使用Unicode值来表示字符型常量，格式是'\uXXXX'，其中XXXX代表一个十六进制的整数。

字符型常量也可以采用十六进制编码方式来表示，范围是'\u0000'～'\uFFFF'，一共可以表示65535个字符，其中前256个（'\u0000'～'\u00FF'）字符和ASCII码中的字符完全重合。不仅如此，char类型的值也可直接作为整数类型的值来使用，但它是一个16位的无符号整数，即全部是正数，表数范围是0～65535。

### 3.6 直接量

[插图] boolean类型的直接量：这个类型的直接量只有true和false。

[插图] String类型的直接量：一个用双引号括起来的字符序列就是String类型的直接量。

[插图] null类型的直接量：这个类型的直接量只有一个值，即null。

由于String类是一个典型的不可变类，因此String对象创建出来就不可能被改变，因此无须担心共享String对象会导致混乱。

### 3.7 运算符

[插图] &：按位与。[插图] |：按位或。[插图] ~：按位非。[插图] ^：按位异或。

[插图]==：等于，如果进行比较的两个操作数都是数值类型，即使它们的数据类型不相同，只要它们的值相等，也都将返回true。例如97=='a'返回true，5.0==5也返回true。如果两个操作数都是引用类型，那么只有当两个引用变量引用相同类的实例时才可以比较，而且这两个引用必须指向同一个对象才会返回true。Java也支持两个boolean类型的值进行比较，例如，true==false将返回false。

[插图] &&：与，前后两个操作数必须都是true才返回true，否则返回false。[插图] &：不短路与，作用与&&相同，但不会短路。[插图] ||：或，只要两个操作数中有一个是true，就可以返回true，否则返回false。[插图] |：不短路或，作用与||相同，但不会短路。[插图] !：非，只需要一个操作数，如果操作数为true，则返回false；如果操作数为false，则返回true。[插图] ^：异或，当两个操作数不同时才返回true，如果两个操作数相同则返回false。

### 4.2 分支结构

在case标签后的每个代码块后都有一条break;语句，这个break;语句有极其重要的意义，Java的switch语句允许case后代码块没有break;

使用switch语句时，有两个值得注意的地方：第一个地方是switch语句后的expression表达式的数据类型只能是byte、short、char、int四个整数类型和枚举类型；第二个地方是如果省略了case后代码块的break；将引入一个陷阱。

### 4.5 数组类型

Java的数组要求所有的数组元素具有相同的数据类型。因此，在一个数组中，数组元素的类型是唯一的，即一个数组里只能存储一种数据类型的数据，而不能存储多种数据类型的数据。

一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。即使把某个数组元素的数据清空，但它所占的空间依然被保留，依然属于该数组，数组的长度依然不变。

Java语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。

String类型是Object类型的子类，即字符串是一种特殊的Object实例。

 数组元素的类型是基本类型中的字符类型（char），则数组元素的值是'\u0000'。[插图] 数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是false。[插图] 数组元素的类型是引用类型（类、接口和数组），则数组元素的值是null。

Java提供了一种更简单的循环：foreach循环，这种循环遍历数组和集合（关于集合的介绍请参考本书第8章）更加简洁。使用foreach循环遍历数组和集合元素时，无须获得数组和集合长度，无须根据索引来访问数组元素和集合元素，foreach循环自动遍历数组和集合的每个元素。

type是数组元素或集合元素的类型，variableName是一个形参名，foreach循环将自动将数组元素、集合元素依次赋给该变量。

使用foreach循环迭代数组元素时，并不能改变数组元素的值，因此不要对foreach的循环变量进行赋值。

### 4.6 深入数组

当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁。因此，所有在方法中定义的局部变量都是放在栈内存中的；当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（在方法的参数传递时很常见），则这个对象依然不会被销毁。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会在合适的时候回收它。

### 5.1 类和对象

Field用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。

static修饰的方法和Field，既可通过类来调用，也可通过实例来调用；没有使用static修饰的普通方法和Field，只可通过实例来调用。

从Person类定义来看，Person对象应包含两个Field，而Field是需要内存来存储的。因此，当创建Person对象时，必然需要有对应的内存来存储Person对象的Field。图5.1显示了Person对象在内存中的存储示意图。

类也是一种引用数据类型，因此程序中定义的Person类型的变量实际上是一个引用，它被存放在栈内存里，指向实际的Person对象；而真正的Person对象则存放在堆（heap）内存中。

栈内存里的引用变量并未真正存储对象的Field数据，对象的Field数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度来看，引用变量与C语言里的指针很像，它们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针，只是Java语言把这个指针封装起来，避免开发者进行烦琐的指针操作。

当一个对象被创建成功以后，这个对象将保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。也就是说，不管是数组还是对象，都只能通过引用来访问它们。

如图5.2所示，p引用变量本身只存储了一个地址值，并未包含任何实际数据，但它指向实际的Person对象，当访问p引用变量的Field和方法时，实际上是访问p所引用对象的Field和方法。注意：不管是数组还是对象，当程序访问引用变量的Field或方法时，实际上是访问该引用变量所引用的数组、对象的Field或方法。

Java提供了一个this关键字，this关键字总是指向调用该方法的对象。根据this出现位置的不同， this作为对象的默认引用有两种情形：[插图] 构造器中引用该构造器正在初始化的对象；[插图] 在方法中引用调用该方法的对象。

### 5.4 隐藏和封装

对一个类或对象实现良好的封装，可以实现以下目的。[插图] 隐藏类的实现细节。[插图] 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对Field的不合理访问。[插图] 可进行数据检查，从而有利于保证对象信息的完整性。[插图] 便于修改，提高代码的可维护性。为了实现良好的封装，需要从两个方面考虑。[插图] 将对象的Field和实现细节隐藏起来，不允许外部直接访问。[插图] 把方法暴露出来，让方法来控制对这些Field进行安全的访问和操作。因此，封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。

 private（当前类访问权限）：如果类里的一个成员（包括Field、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在当前类的内部被访问。

default访问控制的成员或外部类可以被相同包下的其他类访问。关于包的介绍请看5.4.3节。

但外部类只能有两种访问控制级别：public和默认，外部类不能使用private和protected修饰，因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此private和protected访问控制符对外部类没有意义。

[插图] java.lang：这个包下包含了Java语言的核心类，如String、Math、System和Thread类等，使用这个包下的类无须使用import语句导入，系统会自动导入这个包下的所有类。

### 5.5 深入构造器

构造器是一个特殊的方法，这个特殊方法用于创建实例时执行初始化。

构造器最大的用处就是在创建对象时执行初始化。前面已经介绍过了，当创建一个对象时，系统为这个对象的Field进行默认初始化，这种默认的初始化把所有基本类型的Field设为0（对数值型Field）或false（对布尔型Field），把所有引用类型的Field设为null。如果想改变这种默认的初始化，想让系统创建对象时就为该对象的Field显式指定初始值，就可以通过构造器来实现。

### 5.6 类的继承

Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类被称为父类，有的也称其为基类、超类。父类和子类的关系，是一种一般和特殊的关系。例如水果和苹果的关系，苹果继承了水果，苹果是水果的子类，则苹果是一种特殊的水果。因为子类是一种特殊的父类，因此父类包含的范围总比子类包含的范围要大，所以可以认为父类是大类，而子类是小类。

只需在原来的类定义上增加extends SuperClass即可，即表明该子类继承了SuperClass类。

Java使用extends作为继承的关键字，extends关键字在英文中是扩展，而不是继承！这个关键字很好地体现了子类和父类的关系：子类是对父类的扩展，子类是一种特殊的父类。从这个意义上来看，使用继承来描述子类和父类的关系是错误的，用扩展更恰当。因此这样的说法更加准确：Apple类扩展了Fruit类。为什么国内把extends翻译为“继承”呢？除了与历史原因有关之外，把extends翻译为“继承”也是有其理由的：子类扩展了父类，将可以获得父类的全部Field和方法，这与汉语中的继承（子辈从父辈那里获得一笔财富称为继承）具有很好的类似性。值得指出的是，Java的子类不能获得父类的构造器。

如果需要在子类方法中调用父类被覆盖的实例方法，则可使用super限定来调用父类被覆盖的实例方法。为上面的Ostrich类添加一个方法，在这个方法中调用Bird类中被覆盖的fly方法。

### 6.4 final修饰符

final关键字可用于修饰类、变量和方法，final关键字有点类似C#里的sealed关键字，用于表示它修饰的类、方法和变量不可改变。

### 6.9 对象与垃圾回收

[插图] 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库连接、网络IO等资源）。[插图] 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收它所占的内存。

### 6.11 使用JAR文件

JAR文件的全称是Java Archive File，意思就是Java档案文件。通常JAR文件是一种压缩文件，与我们常见的ZIP压缩文件兼容，通常也被称为JAR包。JAR文件与ZIP文件的区别就是在JAR文件中默认包含了一个名为META-INF/MANIFEST.MF的清单文件，这个清单文件是在生成JAR文件时由系统自动创建的。

Java虚拟机就可以自动在内存中解压这个JAR包，把这个JAR文件当成一个路径，在这个路径中查找所需要的类或包层次对应的路径结构。使用JAR文件有以下好处。[插图] 安全。能够对JAR文件进行数字签名，只让能够识别数字签名的用户使用里面的东西。[插图] 加快下载速度。在网上使用Applet时，如果存在多个文件而不打包，为了能够把每个文件都下载到客户端，需要为每个文件单独建立一个HTTP连接，这是非常耗时的工作。将这些文件压缩成一个JAR包，只要建立一次HTTP连接就能够一次下载所有的文件。[插图] 压缩。使文件变小，JAR的压缩机制和ZIP完全相同。[插图] 包封装。能够让JAR包里面的文件依赖于统一版本的类文件。[插图] 可移植性。JAR包作为内嵌在Java平台内部处理的标准，能够在各种平台上直接使用。

把一个JAR文件添加到系统的CLASSPATH环境变量中后，Java将会把这个JAR文件当成一个路径来处理。实际上JAR文件就是一个路径，JAR文件通常使用jar命令压缩而成，当使用jar命令压缩生成JAR文件时，可以把一个或多个路径全部压缩成一个JAR文件。

1.创建JAR文件：jar cf test.jar test

5.查看JAR包内容：jar tf test.jar

把应用程序压缩成JAR包来发布是比较典型的做法，如果开发者把整个应用制作成一个可执行的JAR包交给用户，那么用户使用起来就方便了

### 第7章 与运行环境交互

Oracle为Java提供了丰富的基础类库，Java 7提供了4000多个基础类（包括第8章介绍的集合框架），通过这些基础类库可以提高开发效率，降低开发难度。对于合格的Java程序员而言，至少要熟悉Java SE中70%!以(MISSING)上的类（当然，笔者并不是让读者去背诵Java API文档），但在反复查阅API文档的过程中，大脑会自动记住大部分类的功能、方法，因此程序员一定要多练，多敲代码。

### 7.1 与用户互动

下面详细讲解main方法为什么采用这个方法签名。[插图] public修饰符：Java类由JVM调用，为了让JVM可以自由调用这个main方法，所以使用public修饰符把这个方法暴露出来。[插图] static修饰符：JVM调用这个主方法时，不会先创建该主类的对象，然后通过对象来调用该主方法。JVM直接通过该类来调用主方法，因此使用static修饰该主方法。[插图] void返回值：因为主方法被JVM调用，该方法的返回值将返回给JVM，这没有任何意义，因此main方法没有返回值。

根据方法调用的规则：谁调用方法，谁负责为形参赋值。也就是说，main方法由JVM调用，即args形参应该由JVM负责赋值。

### 7.2 系统相关

System类代表当前Java程序的运行平台，程序不能创建System类的对象，System类提供了一些类Field和类方法，允许直接通过System类来调用这些Field和方法。System类提供了代表标准输入、标准输出和错误输出的类Field，并提供了一些静态方法用于访问环境变量、系统属性的方法，还提供了加载文件和动态链接库的方法。下面程序通过System类来访问操作的环境变量和系统属性。

上面程序通过调用System类的getenv()、getProperties()、getProperty等方法来访问程序所在平台的环境变量和系统属性

System类还有两个获取系统当前时间的方法：currentTimeMillis()和nanoTime()，它们都返回一个long型整数。实际上它们都返回当前时间与UTC 1970年1月1日午夜的时间差，前者以毫秒作为测量单位，后者以纳秒作为测量单位

除此之外，System类的in、out和err分别代表系统的标准输入（通常是键盘）、标准输出（通常是显示器）和错误输出流，并提供了setIn、setOut和setErr方法来改变系统的标准输入、标准输出和标准错误输出流。

Runtime类代表Java程序的运行时环境，可以访问JVM的相关信息，如处理器数量、内存信息等。如下程序所示。

Runtime提供了一系列exec()方法来运行操作系统命令，关于它们之间的细微差别，请读者自行查阅API文档。

### 7.3 常用类

Object类是所有类、数组、枚举类的父类，也就是说，Java允许把任何类型的对象赋给Object类型的变量。当定义一个类时没有使用extends关键字为它显式指定父类，则该类默认继承Object父类。

为了避免两个Random对象产生相同的数字序列，通常推荐使用当前时间作为Random对象的种子，如下代码所示。[插图]

Java的double类型会发生精度丢失，尤其在进行算术运算时更容易发生这种情况。不仅是Java，很多编程语言也存在这样的问题。为了能精确表示、计算浮点数，Java提供了BigDecimal类，该类提供了大量的构造器用于创建BigDecimal对象，包括把所有的基本数值型变量转换成一个BigDecimal对象，也包括利用数字字符串、数字字符数组来创建BigDecimal对象。

### 7.5 正则表达式

String类里也提供了如下几个特殊的方法。[插图] boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。[插图] String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成replacement。[插图] String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配regex的子串替换成replacement。[插图] String[] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。上面这些特殊的方法都依赖于Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。

Pattern对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为Pattern对象，然后再利用该Pattern对象创建对应的Matcher对象。执行匹配所涉及的状态保留在Matcher对象中，多个Matcher对象可共享同一个Pattern对象。

Pattern是不可变类，可供多个并发线程安全使用。

### 7.6 国际化与格式化

SimpleDateFormat可以非常灵活地格式化Date，也可以用于解析各种格式的日期字符串。创建SimpleDateFormat对象时需要传入一个pattern字符串，这个pattern不是正则表达式，而是一个日期模板字符串。

### 第8章 Java集合

Java集合类是一种特别有用的工具类，可以用于存储数量不等的多个对象，并可以实现常用的数据结构，如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。Java集合大致可分为Set、List和Map三种体系，其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。从Java 5以后，Java又增加了Queue体系集合，代表一种队列集合实现。

### 8.3 Set集合

HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。

### 8.5 Queue集合

Queue用于模拟队列这种数据结构，队列通常是指“先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素，队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。

PriorityQueue是一个比较标准的队列实现类。之所以说它是比较标准的队列实现，而不是绝对标准的队列实现，是因为PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排序。因此当调用peek()方法或者poll()方法取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素

上面运行Java命令时设置了Xms和Xmx两个选项，这两个选项的意义如下。
￼ -Xms是设置JVM的堆内存初始大小。
￼ -Xmx是设置JVM的堆内存最大大小（最好不要超过物理内存大小）。

[插图] -Xms是设置JVM的堆内存初始大小。[插图] -Xmx是设置JVM的堆内存最大大小（最好不要超过物理内存大小）。

### 8.6 Map

Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。

### 8.8 操作集合的工具类：Collections

Java提供了一个操作Set、List和Map等集合的工具类：Collections，该工具类里提供了大量方法对集合元素进行排序、查询和修改等操作，还提供了将集合对象设置为不可变、对集合对象实现同步控制等方法。

### 9.1 泛型入门

Java集合有个缺点——当我们把一个对象“丢进”集合里后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。

上面程序创建了一个List集合，而且只希望该List集合保存字符串对象——但我们没有办法进行任何限制，如果程序在①处“不小心”把一个Integer对象“丢进”了List集合中，这将导致程序在②处引发ClassCastException异常，因为程序试图把一个Integer对象转换为String类型。

写作：List<String>。我们说List是带一个类型参数的泛型接口，在本例中，类型参数是String。在创建这个ArrayList对象时也指定了一个类型参数。上面程序将在②处引发编译异常，因为strList集合只能添加String对象，所以不能将Integer对象“丢进”该集合。而且程序在③处不需要进行强制类型转换，因为strList对象可以“记住”它的所有集合元素都是String类型。上面代码不仅更加健壮，程序再也不能“不小心”地把其他对象“丢进”strList集合中；而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。这一切，都是因为Java 5提供的泛型支持。

从Java 7开始，Java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号（<>）即可，Java可以推断尖括号里应该是什么泛型信息。即上面两条语句可以改写为如下形式：

### 第10章 异常处理

Java的异常机制主要依赖于try、catch、finally、throw和throws五个关键字，其中try关键字后紧跟一个花括号扩起来的代码块（花括号不可省略），简称try块，它里面放置可能引发异常的代码。catch后对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块。多个catch块后还可以跟一个finally块，finally块用于回收在try块里打开的物理资源，异常机制会保证finally块总被执行。throws关键字主要在方法签名中使用，用于声明该方法可能抛出的异常；而throw用于抛出一个实际的异常，throw可以单独作为语句使用，抛出一个具体的异常对象。

### 10.4 使用throw抛出异常

当程序出现错误时，系统会自动抛出异常；除此之外，Java也允许程序自行抛出异常，自行抛出异常使用throw语句来完成（注意此处的throw没有后面的s，与前面声明抛出的throws是有区别的）。

### 10.6 异常处理规则

但因为try块里的代码过于庞大，业务过于复杂，就会造成try块中出现异常的可能性大大增加，从而导致分析异常原因的难度也大大增加。而且当try块过于庞大时，就难免在try块后紧跟大量的catch块才可以针对不同的异常提供不同的处理逻辑。同一个try块后紧跟大量的catch块则需要分析它们之间的逻辑关系，反而增加了编程复杂度。正确的做法是，把大块的try块分割成多个可能出现异常的程序段落，并把它们放在单独的try块中，从而分别捕获并处理异常。

### 第11章 AWT编程

Java使用AWT和Swing类完成图形用户界面编程，其中AWT的全称是抽象窗口工具集（Abstract WindowToolkit），它是Sun最早提供的GUI库，这个GUI库提供了一些基本功能，但这个GUI库的功能比较有限，所以后来又提供了Swing库。通过使用AWT和Swing提供的图形界面组件库，Java的图形用户界面编程非常简单，程序只要依次创建所需的图形组件，并以合适的方式将这些组件组织在一起，就可以开发出非常美观的用户界面。

### 13.1 JDBC基础

JDBC的全称是JavaDatabase Connectivity，即Java数据库连接，它是一种可以执行SQL语句的JavaAPI。程序可通过JDBC API连接到关系数据库，并使用结构化查询语言（SQL，数据库标准的查询语言）来完成对数据库的查询、更新。

JDBC可以完成以下三个基本工作。（1）与数据库建立连接。（2）执行SQL语句。（3）获得SQL语句的执行结果。通过JDBC的这三个功能，应用程序就可以使用JDBC来操作数据库系统了。

### 13.9 使用连接池管理连接

对于共享资源的情况，有一个通用的设计模式：资源池（Resource Pool），用于解决资源的频繁请求﹑释放所造成的性能下降。为了解决数据库连接的频繁请求、释放，JDBC 2.0规范引入了数据库连接池技术。数据库连接池是Connection对象的工厂。数据库连接池的常用参数如下：[插图] 数据库的初始连接数；[插图] 连接池的最大连接数；[插图] 连接池的最小连接数；[插图] 连接池每次增加的容量。

### 14.1 基本Annotation

Java提供的4个基本Annotation的用法——使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。

@Override就是用来指定方法覆载的，它可以强制一个子类必须覆盖父类的方法。如下程序中使用@Override指定子类Apple的info()方法必须重写父类方法。

### 15.6 Java虚拟机读写其他进程的数据

在第7章介绍Runtime类时，我们知道使用Runtime对象的exec()方法可以运行平台上的其他程序，该方法产生一个Process对象，Process对象代表由该Java程序启动的子进程。Process类提供了如下3个方法，用于让程序和其子进程进行通信。[插图] InputStream getErrorStream()：获取子进程的错误流。[插图] InputStream getInputStream()：获取子进程的输入流。[插图] OutputStream getOutputStream()：获取子进程的输出流。

### 15.8 对象序列化

对象序列化的目标是将对象保存到磁盘中，或允许在网络中直接传输对象。对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种二进制流（无论是从磁盘中获取的，还是通过网络获取的），都可以将这种二进制流恢复成原来的Java对象。

### 15.9 NIO

从JDK 1.4开始，Java提供了一系列改进的输入/输出处理的新功能，这些功能被统称为新IO（New IO，简称NIO），新增了许多用于处理输入/输出的类，这些类都被放在java.nio包以及子包下，并且对原java.io包中的很多类都以NIO为基础进行了改写，新增了满足NIO的功能。

Channel（通道）和Buffer（缓冲）是新IO中的两个核心对象，Channel是对传统的输入/输出系统的模拟，在新IO系统中所有的数据都需要通过通道传输；Channel与传统的InputStream、OutputStream最大的区别在于它提供了一个map()方法，通过该map()方法可以直接将“一块数据”映射到内存中。如果说传统的输入/输出系统是面向流的处理，则新IO则是面向块的处理。Buffer可以被理解成一个容器，它的本质是一个数组，发送到Channel中的所有对象都必须首先放到Buffer中，而从Channel中读取的数据也必须先放到Buffer中。此处的Buffer有点类似于前面介绍的“竹筒”，但该Buffer既可以像“竹筒”那样一次次去Channel中取水，也允许使用Channel直接将文件的某块数据映射成Buffer。

### 16.1 线程概述

几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个运行中的程序就是一个进程。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。

[插图] 并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响

对于一个CPU而言，它在某个时间点只能执行一个程序，也就是说，只能运行一个进程，CPU不断地在这些进程之间轮换执行。那么为什么我们感觉不到任何中断现象呢？这是因为CPU的执行速度相对我们的感觉来说实在是太快了（当然，如果启动的程序足够多，我们依然可以感觉到程序的运行速度下降），所以虽然CPU在多个进程之间轮换执行，但我们感觉到好像有多个进程在同时执行。

线程在程序中是独立的、并发的执行流，与分隔的进程相比，进程中线程之间的隔离程度要小。它们共享内存、文件句柄和其他每个进程应有的状态。因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

[插图] 进程之间不能共享内存，但线程之间共享内存非常容易。[插图] 系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。[插图] Java语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。

### 16.2 线程的创建和启动

Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流（一段顺序执行的代码）。Java使用线程执行体来代表这段程序流。

### 16.3 线程的生命周期

在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead） 5种状态。尤其是当线程启动以后，它不可能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。

### 16.8 线程池

系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。

### 17.5 使用代理服务器

从Java 5开始，Java在java.net包下提供了Proxy和ProxySelector两个类，其中Proxy代表一个代理服务器，可以在打开URLConnection连接时指定Proxy，创建Socket连接时也可以指定Proxy；而ProxySelector代表一个代理选择器，它提供了对代理服务器更加灵活的控制，它可以对HTTP、HTTPS、FTP、SOCKS等进行分别设置，而且还可以设置不需要通过代理服务器的主机和地址。通过使用ProxySelector，可以实现像在Internet Explorer、Firefox等软件中设置代理服务器类似的效果。

[插图] Proxy.Type.HTTP：表示支持高级协议代理，如HTTP或FTP。[插图] Proxy.Type.SOCKS：表示SOCKS（V4 或V5）代理。一旦创建了Proxy对象之后，程序就可以在使用URLConnection打开连接时，或者创建Socket连接时传入一个Proxy对象，作为本次连接所使用的代理服务器。

### 第18章 类加载机制与反射

绍java.lang.reflect包下的接口和类，包括Class、Method、Field、Constructor和Array等，这些类分别代表类、方法、Field、构造器和数组，Java程序可以使用这些类动态地获取某个对象、某个类的运行时信息，并可以动态地创建Java对象，动态地调用Java方法，访问并修改指定对象的Field值。

### 18.1 类的加载、连接和初始化

当我们调用Java命令运行某个Java程序时，该命令将会启动一个Java虚拟机进程，不管该Java程序有多么复杂，该程序启动了多少个线程，它们都处于该Java虚拟机进程里。正如前面介绍的，同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。