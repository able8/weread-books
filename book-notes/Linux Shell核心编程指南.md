## Linux Shell核心编程指南
> 丁明一

### 作者简介

达内集团云计算教学研发总监、开源技术推广者；红帽认证架构师（RHCA）、红帽认证高级讲师（RHCI）；曾任职于中国电信、鹏博士等多家IT企业，并创办多个企业，有十余年IT行业经验；

### 推荐序1

Shell可以将Linux中的每条专注而高效的任务命令组合起来，从而完成复杂而美妙的事务。

Shell可以很简单，更可以很高效。类似于所有编程语言，如想掌握Shell编程的精华，一是要非常熟悉Linux中的各种命令参数，二是要勤于实践，三是要参考大师写的代码实例。

### 1.2 脚本文件的各种执行方式

一般可以通过pstree命令来查看进程树，了解进程之间的关系。

而bash命令开启子进程的方式执行脚本文件却不受任何影响，

### 1.3 如何在脚本文件中实现数据的输入与输出

因为没有-e选项，不支持\字符，所以屏幕会将原始内容\t直接输出。

# printf  "|%!d(MISSING)|\n"  12        #右对齐输出12，字符宽度为10|       12|￼

### 1.4 输入与输出的重定向

＜＜符号（也被称为Here Document）代表你需要的内容在这里。

使用＜＜将数据导入程序时，如果内容里面有缩进，则连同缩进的内容都会传递给程序。而此时的Tab键仅仅起缩进的作用，我们并不希望传递给程序。如果需要，可以使用＜＜-符号重定向输入的方式实现，这样系统会忽略掉所有数据内容及分隔符（EOF）前面的Tab键。使用这种方式仅可以忽略Tab键，如果Here Document的正文内容有空格缩进，则无效。

### 1.5 各种引号的正确使用姿势

为了解决这些问题，人们又设计了$（）组合符号，功能也是命令替换，而且支持嵌套功能，

需要读取变量值时，需要在变量名前添加一个美元符号“$”；而当变量名与其他非变量名的字符混在一起时，需要使用{}分隔。

因为Shell变量名称仅可以由字母、数字、下画线组成，不可能包括特殊符号（如横线、冒号、空格等），所以系统不会把特殊符号当作变量名的一部分，

因为“$*”将所有参数视为一个整体，因此创建了一个名称为“A C 8 D”的文件，空格也是文件名的一部分。而“$@”将所有参数视为独立的个体，因为touch名称创建了4个文件，

### 1.7 数据过滤与正则表达式

用法：grep [选项]匹配模式[文件]。
常用选项：-i忽略字母大小写。
-v取反匹配。
-w匹配单词。
-q静默匹配，不将结果显示在屏幕上。

表1-7列出了扩展正则表达式及其含义。
表1-7 扩展正则表达式及其含义
￼


\s表示任意空白字符（空格、制表符等）, \S表示任意非空白字符。

Shell支持多种算术运算，可以使用$（（表达式））、$[表达式]、let表达式进行整数的算术运算，注意这些命令无法执行小数运算；使用bc命令可以进行小数运算。

echo $[x>y?2:3]         #如果x大于y，返回2，否则返回33￼
[root@centos7～]# echo $[y>x?2:3]         #如果y大于x，返回2，否则返回32￼

[root@centos7～]# echo $[x++]           #先调用x，屏幕显示1，再对x自加11

Bash仅支持对整数的四则运算，不支持对小数的运算。如果我们需要在脚本中对任意精度的小数进行运算甚至编写计算函数，则可以使用bc计算器实现。bc计算器支持交互和非交互两种执行方式。

### 2.2 字符串的判断与比较

在Shell中进行条件测试时一定要注意空格问题。使用[]测试时，左方括号右边和右方括号左边都必须有空格。而且测试的比较符号两边也必须都有空格。
￼
[root@centos7～]# [test == beijing]            #前后括号都缺少空格，系统报错bash: [test: command not found...

下面这个例子==符号两边没有空格，无论怎么测试结果都为真，编写脚本时这种Bug系统不会提示语法错误，但程序结果有可能是错误的。

我们还可以使用-z测试一个字符串是否非空（变量值不为空）。但是在实际应用时最好将测试对象使用双引号引起来。

为了防止类似这种错误，可以将变量使用双引号￼引起来。

grep命令使用-o选项可以仅显示匹配内容，而不显示全行所有内容。

2.4 文件属性的判断与比较

下面这个测试，假设系统中有某个磁盘设备，使用-b测试该设备是否存在，且当该设备为块设备时返回值为真，否则返回值为假。

链接创建后，如果源文件被删除，则硬链接依然可以正常使用、正常读写数据，但硬链接不可以跨分区或磁盘创建。另外，硬链接与源文件使用的是相同的设备、相同的inode编号。

两者的主要差异是：test或[]是符合POSIX标准的测试语句，兼容性更强，几乎可以运行在所有Shell解释器中，相比较而言[[]]仅可运行在特定的几个Shell解释器中（如Bash、Zsh等）。事实上，目前支持使用[[]]进行条件测试的解释器已经足够多了。使用[[]]进行测试判断时甚至可以使用正则表达式。

[[ ]]中的表达式如果使用＜或＞进行排序比较，使用的是本地的locale语言顺序。

虽然[]也支持同时进行多个条件的逻辑测试，但是在[]中需要使用-a和-o进行逻辑与和逻辑或的比较操作，而[[]]中可以直接使用&&和||进行逻辑比较操作，更直观，可读性更好。


需要注意的还有==比较符，在[[]]中==是模式匹配，模式匹配允许使用通配符。例如，Bash常用的通配符有*、? 、[…]等。而==在test语句中仅代表字符串的精确比较，判断字符串是否一模一样。

### 2.7 实战案例：单分支if语句

虽然在[]中不允许使用&&和||符号进行多个条件的测试判断，但是，可以使用多次[]测试，中间使用&&和||进行逻辑判断。


if语句后面的条件测试语句不一定非要是test或[]测试语句，任何有返回值的命令都可以写在if语句后面，命令返回值为0代表执行成功（即为真），返回值非0代表执行失败（即为假）。下面看案例。

### 2.9 实战案例：如何监控HTTP服务状态

尽管目前绝大多数服务都使用TCP协议，但依然有不少服务在使用UDP协议。比如DNS（53端口）、DHCP（67、68端口）、TFTP（69端口）、NTP（123端口）等。

### 3.1 玩转for循环语句

变量name没有定义取值的范围，这个循环语句到底会循环多少次呢？如果变量name没有定义取值范围，则默认取值为$@，也就是所有位置变量的值。这样有几个位置变量，该for循环语句就循环几次。下面通过一个示例演示效果。

echo {x, y{i, j}{1,2,3}, z}  

还可以使用seq命令生成数字序列，并且可以调用其他变量，但该命令不支持生成字母序列。默认输出序列的分隔符是\n换行符，也可以使用-s选项自定义分隔符。


### 3.5 非常重要的IFS

在Shell中使用内部变量IFS（Internal Field Seprator）来决定项目列表或值列表的分隔符，IFS的默认值为空格、Tab制表符或换行符

因为空格、Tab制表符和换行符都属于ASCII码表中的控制字符，是不可显示的内容，所以正常使用echo命令显示该变量的值时，是看不到内容的，但是可以通过od命令将数据转换为八进制数据后再查看。

printf命令输出IFS值，就不会有两个空白行的情况发生，因为printf打印完内容后默认不换行

# printf "%!s(MISSING)" "$IFS" | od -b0000000 040 011 012
输出结果中的040是空格键、011是Tab制表符、012是换行符。因为IFS的原始值不容易设置，所以当需要修改IFS值时，最好提前备份其原始值。

那么，系统默认将IFS变量的值设置为空格、Tab制表符或换行符是如何实现的呢？下面这行命令可以将IFS变量的值再次还原为系统预设的默认值。
￼
[root@centos7～]# IFS=$' \t\n'                   #注意\t前面有个空格

### 3.7 Shell小游戏之猜随机数字

使用while true或while ：来实现功能。在Shell中，true和：都是固定返回退出码0的空命令，这两个命令都不会进行任何实际的操作。与true相反的另一个命令为false, false命令是一个退出码为非0的空命令。

### 3.9 until和select循环

使用select循环的主要目的是方便地创建菜单，其基本语法格式如下。

### 4.1 强悍的数组

索引可以不连续。

echo ${name[＊]}              #查看数组中所有元素的值Jacob Rose Vicky Rick Tin￼
[root@centos7～]# echo ${name[-1]}              #数组中最后一个元素的值Tin
￼
[root@centos7～]# echo ${name[-2]}              #数组中倒数第二个元素的值Rick￼
[root@centos7～]# echo ${#name[＊]}             #统计数组中所有元素的个数5￼

在使用数组时，数组的索引也可以是变量，这个功能Shell脚本中的普通变量是不可能实现的。

没有明确指定索引，但系统会默认使用以0为起始值的有序数字为索引。所有数组元素的值之间使用空格符分隔。

使用$（）或``也可以将命令的执行结果赋值给数组变量。
￼
[root@centos7～]# df /文件系统         1K-块    已用    可用已用%!挂(MISSING)载点/dev/sda2     123723328 61519688 55895800   53%!/(MISSING)￼
[root@centos7～]# df / | tail -n +2                #删掉标题，从第二行开始显示/dev/sda2     123723328 61519688 55895800   53%!/(MISSING)￼
[root@centos7～]# root=（$（df / | tail -n +2））￼

echo ${root[＊]}/dev/sda2 123723328 61519688 55895800 53%!/(MISSING)￼
[root@centos7～]# echo ${root[1]}123723328￼
[root@centos7～]# echo ${root[2]}61519688

需要先使用“declare -A数组名称”才可以定义一个关联数组。其他的语法与普通数组一致。需要注意的是，普通的索引数组无法转换为关联数组。

### 4.5 启动进程的若干种方式

使用fork方式开启的子进程是父进程的一个副本，因此会自动单向继承父进程的环境，如环境变量、位置变量、资源权限、内存中的数据、信号等。但是，父进程无法继承子进程的环境。

3）source方式
使用source命令或．（点）可以不开启子Shell，而在当前Shell环境中将需要执行的命令加载进来，执行完加载的命令后，继续执行脚本中后续的指令。

如果需要取消函数，可以使用unset命令取消函数的定义。
￼
[root@centos7～]# unset mymkdir                        #取消函数定义

### 4.8 实战案例：多进程的ping脚本

我们可以继续优化上面的脚本，在脚本最后添加一个wait命令，这样可以在所有的后台子进程都结束，也就是所有的ping测试都结束后，再退出脚本。

### 4.9 控制进程数量的核心技术——文件描述符和命名管道

创建文件描述符语法格式如下。
exec文件描述符 <> 文件名
调用文件描述符语法格式如下。
￼
&文件描述符
关闭文件描述符语法格式如下。
￼
exec文件描述符<&-

使用cat命令可以通过文件描述符读取文件的全部内容。另外，read命令后跟-u选项也可以通过文件描述符读取文件内容，但不同的是，read命令每次仅读取一行数据。

● FIFO文件由命令创建（mknod或mkfifo命令），可以在文件系统中直接看到。
● 写入管道的数据一旦被读取后，就不可以再重复读取。
● 进程往命名管道中写数据时，如果没有其他进程读取数据，则写进程会被阻塞

有了这样的技巧可以控制进程数量后，就可以再次修改前面的ping测试脚本，实现一个可以任意控制进程数量的多进程ping测试脚本。

### 5.1 Shell八大扩展功能之花括号

使用花括号扩展时在花括号前面和后面都可以添加可选的字符串，且花括号扩展支持嵌套。

### 5.4 Shell八大扩展功能之命令替换

进程替换则将进程的返回结果通过命名管道的方式传递给另一个进程。
进程替换的语法格式为：＜（命令）或者＞（命令）。一旦使用了进程替换功能，系统将会在/dev/fd/目录下创建文件描述符文件，通过该文件描述符将进程的输出结果传递给其他进程。

paste命令会逐行读取多个文件的内容并将多个文件合并。
￼
[root@centos7～]#paste  <（cut-d:-f1,6/etc/passwd）  <（cut-d:-f2/etc/shadow）

### 5.10 Shell解释器的属性与初始化命令行终端

使用set -o和shopt命令可以分别查看各自命令支持的所有属性及是否开启的标志。set命令可以通过选项开启或关闭特定的Bash属性，

默认Bash是支持花括号替换功能的，这样我们就可以使用简单的命令快速生成一个数据序列，比如字母序列表、数字序列表等。该功能可以使用braceexpand属性来开启或关闭。

有时在脚本的开始位置设置一个set -e（errexit）是非常必要的。如果我们编写一个脚本，该脚本的主要功能是创建账户、设置账户密码，最后输出一条提示信息，而账户已经存在或有其他原因导致创建账户失败时，默认脚本依然会坚持执行完所有的脚本命令，很显然，这样会出现雪崩一样的错误提示。类似这样的脚本还有很多，向安装软件、修改配置文件、启动服务这些有关联性的脚本，都有可能因为前面的一个小小错误，而导致整个脚本大面积出错，设置set -e就可以在第一条命令出错时就将整个脚本停止运行。

使用kill命令不指定信号时，默认信号为SIGTERM，该信号默认会终止进程。SIGINT信号等同于使用Ctrl+C组合键，默认会中断进程。

最后需要说明的是，在Shell脚本中并不能捕获所有信号，像TERM、KILL之类的信号是无法被捕获的。

### 5.14 实战案例：脚本排错技巧

使用-x跟踪脚本执行过程，这是非常重要的一种排错方式。可以使用bash -x执行脚本，也可以通过为脚本中第一行解释器添加-x选项来实现相同功能的跟踪功能。如果输出结果以双加号开头（++）则表示命令是在子Shell中执行的。

### 5.15 实战案例：Shell版本的进度条功能

我们做一个最简单的不控制数量的进度条，我们只需要在屏幕上不停地显示某种进度指示符号或色块即可，直到脚本的任务执行完成，再将进度条杀死（kill）。

除了使用#符号作为进度条，还可以使用背景色块作为进度条。

printf命令支持%!进(MISSING)行格式控制，%!s(MISSING)、代表输出字符，实际数据有多少就输出多少字符。%!s(MISSING)可以指定输出宽度，当实际数据宽度不足10个宽度时系统自动补空格，而如果实际数据宽度大于10个宽度时，则按实际数据宽度显示字符。另外，也可以使用%!s(MISSING)指定仅显示实际数据中的2个字符。

### 5.16 再谈参数传递之xargs

默认xargs读取参数时以空格、Tab制表符或者回车符为分隔符和结束符，但是有些文件名本身可能就包含有空格，此时xargs会理解一个文件有多个参数。

对于这样的问题，find提供了一个print0选项，设置find在输出文件名后自动添加一个NULL来替代换行符，而xargs也提供了一个-0（数字零）选项，指定使用NULL而不是空格、Tab制表符或者换行符作为结束符。这样的话对于xargs来说空格就变成了一个普通字符，只有NULL才被识别为参数的结束符。
￼
[root@centos7～]# find ./ -name "＊.txt" -print0 | xargs -0 rm

xargs命令可以通过-d选项指定任意字符为分隔符，默认以空格、Tab制表符或换行符为分隔符。

### 第6章 上古神兵利器sed

sed是贝尔实验室的Lee E. McMahon在1973年到1974年开发的流编辑器，sed是基于交互式行编辑器ed开发的软件，sed与ed一样也是行处理编辑器，在sed中搞清楚你需要编辑的是哪一行内容很重要，同时sed是最早开始支持正则表达式的工具之一。我们可以使用sed非常轻松地完成非交互式的文件编辑工作，包括但不限于对文件的增、删、改、查等操作。

### 6.1 sed基本指令

sed会逐行扫描输入的数据，并将读取的数据内容复制到缓冲区中，我们称之为模式空间，然后拿模式空间中的数据与给定的条件进行匹配，如果匹配成功则执行特定的sed指令，否则sed会跳过输入的数据行，继续读取后续的数据。默认情况下sed会把最终的数据结果通过标准输出显示在屏幕上。

sed指令执行前需要先根据条件定位需要处理的数据行，如果没有指定定位条件，则默认sed会对所有数据行执行特定的指令。

当没有指定条件时，默认会匹配所有的数据行，

所以p指令数据行被打印显示了一次，接着sed默认又将读取的数据行再显示了一次，最终每行显示了两次。可以使用-n选项屏蔽sed默认的输出功能。关闭默认的输出功能后，所有的数据行将仅显示一次。

除了直接使用行号，sed还支持使用正则表达式定位特定的数据行。上

默认sed不支持扩展正则，如果希望使用扩展正则匹配数据，可以使用-r参数。
￼

sed程序使用=指令可以显示行号，结合条件匹配，可以显示特定数据行的行号。

在sed中支持使用感叹号（!）对匹配的条件进行取反操作。


通过a指令添加新的数据行后，虽然在屏幕的输出结果中我们确实看到了添加的新数据，但是查看源文件后就会发现/tmp/hosts并没有实际发生变化，默认sed仅仅是在缓存区中修改了数据并显示在屏幕上，而源文件不会发生变化

为了解决类似的问题，sed支持使用任何其他字符作为替换符号。

使用sed时可以使用分号或者-e选项两种方式在一行中编写多条指令。可以直接使用分号将多个指令分隔，或者在多个-e参数后面添加sed指令，sed支持一个或多个-e参数。如果将分号放到花括号中还可以实现对指令进行分组。

仅当我们使用特定的指令时（如h、g、x等）才会用到保留空间中的数据，注意在保留空间中默认包含一个回车符。模式空间与保留空间的关系如图6-2所示。

当我们使用h指令时，sed就会把模式空间中的所有内容复制到保留空间，并将保留空间中原有的回车符覆盖，而如果使用的是H指令，则sed会把模式空间中的所有内容追加到保留空间中回车符的后面，保留空间中的回车符不会被覆盖。反向操作时使用g指令，sed就会把保留空间中的所有数据复制到模式空间，此时模式空间中原有的所有数据都将被覆盖。

如果需要将模式空间与保留空间中的数据直接交换则可以使用x指令。

通过多次使用h指令可以将多个数据行都复制到保留空间以备后用，但是多次使用h指令复制数据时，需要使用大写H以防止后面复制的数据将前面复制的数据覆盖。

但是如果使用n（next）指令，则会改变这样的正常流程，sed遇到n指令会立刻输出当前模式空间中的内容，直接读取输入文件的下一行数据到模式空间。

因为没有匹配条件因此指令对所有数据行都有效，先是读取test.txt的第一行到模式空间，然后执行n会导致打印当前行的数据内容（显示第一行hello the world），接着读取文件下一行数据到模式空间（go spurs go），

数据删除（删除go spurs go这行），最后当n和d指令都执行完毕了，接着sed继续读取文件下一行数据（读取第3行进入模式空间），依此类推，最终输出的效果就是将偶数行全部删除，屏幕仅显示奇数行的内容。

sed支持多种替换操作，c以行为单位替换，s以关键词为单位替换，y以字符为单位替换，单个字符是sed中的最小处理单位。

首先我们需要明确定义标签需要使用冒号（:）开始，后面跟任意标签字符串（标签名称），冒号与标签字符串之间不能有空格，而如果字符串最后有空格，则空格也被理解为标签名称的一部分。

则sed直接跳转至命令结束位置。区别是b为无条件跳转，t为有条件跳转。t需要根据前面的s替换指令的结果决定是否跳转。需要注意的是，这里的跳转只影响sed指令的执行顺序，对输入的数据行没有影响。

上面这条命令在打印行号（=）和打印当前行数据内容（p）之前定义了一个名称为top的标签，并在读取文件第4行数据时将sed指令跳转至top，循环执行=和p指令。针对test.txt文件指令的执行流程如下。

（1）读取文件的第1行数据，定义名称为top的标签，执行=和p指令，屏幕输出行号1和第1行的数据内容"1:hello the world."，因为第1行的行号不等于4，所以此时不会执行b跳转指令。

第4行的行号与b指令前面的行号条件匹配，因此在这里就会执行b跳转指令，将指令跳转至top，等于做了一次循环。回到top后，再按顺序执行=和p指令，因为跳转影响的仅仅是指令的执行顺序，不会导致数据行的跳转变化，所以当前行始终都是第4行，4b的条件匹配始终满足，b指令会反复跳转至top导致死循环

（2）读取文件的第2行，因为该行数据包含go字符串，因此b指令被触发执行，sed直接跳过=指令，跳转到了名称为label的位置，也就是p指令前面，这样对于第2行而言最终仅仅是显示该行的数据内容："2:go spurs go."，不会再多显示一次行号。

与branch无条件跳转有所不同，test是一种有条件的跳转，使用时必须和s替换操作配合使用。当s替换操作成功时则执行test跳转，如果跳转的目标标签不存在，则跳转到指令的结束位置，反之，如果s替换操作不成功，则不执行test跳转操作。

最后test有条件跳转，如果前面的s替换操作成功则执行t跳转指令，否则不执行t跳转指令。针对contact.txt数据文件其执行流程如下。

[root@centos7～]# echo fe54008f2592 | sed -r':loop; s/（[^:]+）（[0-9a-f]{2}）/\1:\2/; t loop'fe:54:00:8f:25:92
不使用循环时仅能在最后一组MAC前添加一个冒号分隔符，使用循环后就可以为所有MAC分组之间添加冒号分隔符。

### 6.3 实战案例：自动化配置vsftpd脚本

动态主机设置协议（Dynamic Host Configuration Protocol，简称DHCP）是一种局域网协议，在工作中搭建DHCP服务器的主要目的是为局域网内部的其他客户端自动分配IP地址、网关、DNS等网络参数，DHCP使用UDP协议传输数据。

DHCP采用客户端/服务器模型，一台DHCP服务器可以为多台客户端同时提供服务，客户端可以是电脑，也可以是手机或其他智能设备。简单DHCP拓扑结构如图6-3所示。

DHCP数据通信流程如下。（1）客户端通过广播发送DHCP DISCOVER数据包，询问网络环境中谁是DHCP服务器。（2）如果有DHCP服务器接收到DISCOVER数据包，该服务器会向客户端发送DHCP OFFER数据包，数据包中包括可以为客户端提供的IP地址、网关、DNS、租期[插图]网络参数。

（4）服务器收到客户端发送的REQUEST数据包后，向客户端发送一个DHCP ACK的确认数据包，完成整个DHCP过程。

### 6.7 实战案例：自动化配置SSH安全策略脚本

默认SSH服务会监听整个计算机所有网卡IP的端口，通过ListenAddress参数可以设置其仅监听特定的IP地址，如仅监听内网IP地址，这样也可以有效降低被攻击的可能性。
默认SSH是允许超级管理员root远程登录的，这对于线上服务器来说是非常危险的事情，通过修改PermitRootLogin参数的值可以禁止root登录。

在生产环境中特别是Linux系统通常使用的都是字符界面管理服务器，甚少有使用特性的情况，而默认SSH服务开启了图形转发功能，通过设置X11Forwarding可以禁止图形转发。

通过AllowUsers和AllowGroups可以设置用户和组的白名单列表，这样以后仅允许在白名单列表中的用户或组远程登录SSH服务器，其他用户和组默认拒绝登录。白名单配置的语法格式为：AllowUsers用户名1用户名2用户名3@IP或网段．

### 第7章 不可思议的编程语言awk

awk在20世纪70年代诞生于贝尔实验室，其名称源于该软件三名开发者的姓氏￼。awk有很多版本，在1985—1988年被大量修订与重写并于1988年发布的Gnu awk，是目前应用最广泛的版本，在CentOS7系统中默认使用的就是Gnu awk。

### 7.1 awk基础语法

awk可以通过-v（variable）选项设置或者修改变量的值，我们可以使用-v定义新的变量，也可以使用该选项修改内置变量的值。

有时编写awk命令需要系统变量的值，我们也可以通过-v选项或者组合多个引号实现这样的功能。
￼
[root@centos7～]# x="hello"                             #自定义系统变量￼
[root@centos7～]# awk -v i=$x '{print i}' 


我们还可以使用[]定义分隔符集合，同时设置多个分隔符。比如使用[:, -]表示以冒号（:）、逗号（,）或者横线（-）为分隔符。
提示

在awk中变量不需要定义就可以直接使用，作为字符处理时未定义的变量默认值为空，作为数字处理时未定义的变量默认值为0。

### 7.2 awk条件判断

awk的单分支if判断语法格式如下，if判断后面如果只有一个动作指令，则花括号{}可以省略，如果if判断后面的指令为多条指令则需要使用花括号{}括起来，多个指令使用分号分隔。

### 7.3 awk数组与循环

1）关联数组
awk支持关联数组，数组的索引下标可以不是连续的数字，索引下标可以是任意字符或数字，当使用数组作为索引时awk会自动将数字转换为字符，如果直接使用字符作索引则需要使用引号括起来。

4）中断循环
与Shell脚本类似awk提供了continue、break和exit循环中断语句，方便我们在特定环境下对循环进行中断操作。

### 7.4 awk函数

system（命令）函数可以让我们在awk中直接调用Shell命令。awk会启动一个新的Shell进程执行命令。

toupper（str）函数可以将字符串转换为大写。

### 7.5 实战案例：awk版网站日志分析

另外，在做一些统计工作时，上一版脚本普遍都在循环中定义关联数组，然后通过对数组元素值的累加进行统计。而使用awk的数组重写这些代码会让脚本更简洁、执行效率更高。

● awk读取日志文件的第1行，定义关联数组，数组名称为IP，使用该行第1列数据作为数组的索引下标（即172.40.58.114），而IP['172.40.58.114']++则是对该数组元素进行自加一运算，因为默认该数组元素的值为0￼，所以自加一后的值为1，也可以理解为172.40.58.114的访问次数为1次。

### 7.6 实战案例：监控网络连接状态

首先，我们需要学习的是UDP, UDP（User Datagram Protocol）的中文名称是用户数据报协议，属于OSI参考模型的4层（传输层）协议，它是一种非面向连接的协议，使用UDP通信时，发送数据方不需要与接收数据方建立连接，不需要经对方的同意，甚至不需要确认对方是否存在，就可以随时将数据直接传输给对方，因为不需要烦琐的三次握手，所以其通信效率非常高

使用TCP通信前，发送数据方与接收数据方必须先通过三次握手建立连接才可以发送数据，通信结束后，还需要进行四次断开。像我们打电话一样，通话前必须先拨号，与对方建立一个连接通道，连接通道建立后才可以通话，彼此传递信息，通话结束后需要挂断电话。