## Terraform：多云、混合云环境下实现基础设施即代码（第2版）
> 叶夫根尼·布里克曼

### 内容简介

这本书介绍了如何通过Terraform在多云和混合云的环境下使用基础设施即代码，把软件工程的优秀实践应用于硬件的管理。

### O'ReillyMedia, Inc.介绍

O'Reilly以“分享创新知识、改变世界”为己任。40多年来我们一直向企业、个人提供成功所必需之技能及思想，激励他们创新并做得更好。

### 译者序

DevOps关注如何通过对工具、文化和流程的改进，提升部署自动化和发布的效率。DevOps兴起到成熟的过程，也是软件开发团队和产品运维团队间直接协作与融合的过程。

### 前言

Terraform（见参考资料文前[1]）是一个由HashiCorp公司创建的开源工具，它可以让用户使用简单的声明性语言将基础设施定义为代码，并通过一些命令来部署和管理基于各种公有云（例如Amazon Web Service、Microsoft Azure、Google Cloud Platform、DigitalOcean）、私有云和虚拟化平台（例如OpenStack、VMWare）的基础设施。例

由于其简单、易用且功能强大，Terraform已成为DevOps领域中的一个关键角色。它可以自动化那些烦琐而脆弱的手动工作，使用户拥有一整套坚实的基础设施，并在此基础之上继续构建其他的DevOps实践（如自动测试、持续集成、持续交付）和工具（如Docker、Chef、Puppet）。

在代码编写完成之后还需要对代码负责的任何人，都适合阅读本书。其中包括系统管理员、运营工程师、发布工程师、站点可靠性工程师、DevOps工程师、基础设施开发人员、全栈开发人员、工程经理和CTO。无论头衔是什么，如果你的职责是管理基础设施、部署代码、配置服务器、管理服务器集群的缩放、备份数据、监控应用程序，并需要在凌晨3点响应任何系统报警，本书就是写给你的。

随着云计算和DevOps变得无处不在，几乎每个开发人员都需要了解运维技术，同样每个系统管理员也需要学习编码技能。

你将充分了解现代开发和运维的最关键技术之一：将基础设施作为代码进行管理。

读者不仅可以学习如何通过Terraform将基础设施作为代码进行管理，还会了解如何让它适用于整个DevOps领域。

我的目标是：通过与你分享这些经验和教训，缩短这个漫长的学习过程，使你能够在几天之内熟练掌握Terraform。

还可以通过Terraform
将云平台之外的系统作为代码进行管理：包括版本控制系统（例如GitHub、GitLab或BitBucket）、数据存储系统（例如MySQL、PostreSQL或InfluxDB）、监视和警报系统（例如DataDog、New Relic或Grafana）、平台工具（例如Kubernetes、Helm、Heroku、Rundeck或Rightscale），等等。另一方面，每个服务提供商的API接口覆盖率都有了显著提高，例如，Terraform的AWS服务提供商现在涵盖了大多数重要的AWS服务，甚至当新功能出现时，其对Terraform的支持早于AWS自有的CloudFormation！


### 第1章 为什么使用Terraform

仅仅能够在本地计算机上正常运行软件的代码并不算完工，即使通过了测试和代码评审也不算完成，软件只有最终交付给用户才标志着项目的结束。

### DevOps的崛起

运

维团队有时也会犯错，最终会导致环境中的每个服务器的配置，多多少少与其他服务器有所不同（此问题被称为configuration drift，即配置漂移），而非标准化配置的雪花服务器（snowflake server）的出现，导致更多的错误发生。有时开发人员只是耸耸肩说：“同样的代码在我的机器上运行没有问题！”，故障和停机只会变得更加频繁。

在这种一年两次发布的节奏下，团队往往直到发布前的最后几周才开始尝试将所有项目代码合并到一起，这种不经常的合并自然会导致巨大的代码冲突。团队里没有人可以解决全部冲突、稳定发布分支。成员之间开始互相指责，隔阂加重。公司的业务逐渐陷入停顿。

运维团队的主要任务也逐渐从硬件管理转移到软件管理之上（使用如Chef、Puppet、Terraform和Docker等工具），系统管理员的工作也从架设服务器和插拔网线，转变为编写代码。

DevOps的目标是极大地提高软件交付效率。

团队应该构建弹性的、能够自我修复的系统，使用监控和警报机制发现那些无法自动解决的问题，而不是响应频繁的故障和系统停机。

DevOps有四大核心价值：文化（culture）、自动化（automation）、度量（measurement）和共享（sharing），

DevOps自动化的目标是将软件交付过程自动化。所以落实到管理基础设施方面，也要尽可能多地通过代码来进行，减少点击网页或手动执行Shell命令的方式。这种概念通常被称为：基础设施即代码（IaC）。

### 什么是基础设施即代码

基础设施即代码背后的想法是，通过编写和执行代码来定义、部署、更新和销毁基础设施。这代表着一种观念上的重要转变：将运维的各个工作都视为与软件相关，甚至包括那些明显针对硬件的工作（如设置物理服务器）。

DevOps的一个重要观点是，用户应该将所有事物都在代码中进行管理，包括服务器、数据库、网络、日志文件、应用程序配置、文档、自动测试、部署过程等。

IaC工具分为5大类。• 专项脚本• 配置管理工具• 服务器模板工具• 编排工具• 服务开通工具

如果你曾经维护过一个大型的Bash脚本存储库，就会知道它最终会变成一堆无法维护的代码，就像一锅混乱的意大利面条。总而言之，专项脚本对那些小规模的、一次性的任务很有效，但如果计划把基础设施作为代码进行管理，那么你应该使用专业的IaC工具。


配置管理工具
Chef、Puppet、Ansible和SaltStack都属于配置管理工具，它们的目的是在现有服务器上安装和管理软件。

编写需要单次运行的专项脚本并不困难，但是编写一个在反复运行后仍能正常工作的专项脚本就没有那么简单了。每次通过脚本创建一个文件夹，都需要检查该文件夹是否已经存在；每次向文件中添加一行配置，都需要检查该行内容是否已经存在；每次要运行应用程序时，都需要检查该应用程序是否已经在运行。

另一方面，大多数Ansible函数在默认情况下已经是幂等的。例如在web-server.yml中，Ansible角色只有在服务器尚未安装Apache的情况下才进行安装，并且仅在尚未运行Apache的服务器上才会尝试启动相应进程。


专项脚本适用于单一、本地计算机的运行。Ansible和其他配置管理工具则适用于管理大量的远程服务器，可以同时在众多服务器上同步执行代码，如图1-2所示。


图1-2：Ansible这样的配置管理工具可以同时在众多服务器上同步执行代码

服务器模板工具（如Docker、Packer和Vagrant）是最近非常流行的一种工具，有替代配置管理工具的趋势。其背后的设计理念是：与其创建一堆服务器，然后在服务器上运行相同的代码来配置它们，不如使用诸如Packer之类的服务器模板工具，将完全独立的服务器“快照”创建为映像（包括操作系统、软件、文件，以及所有其他相关的详细信息）。然后，使用其他IaC工具（如Ansible）在所有服务器上统一安装该映像，如图1-3所示。

虚拟机（VM）来模拟包括硬件在内的整个计算机系统。利用下层运行的管理程序（hypervisor），如VMWare、VirtualBox、Parallels来虚拟（模拟）底层的CPU、内存、硬盘和网络。

缺点是硬件的虚拟化和每个虚拟机中运行的独立操作系统，都会导致大量的CPU、内存和启动时间方面的开销。用户可以使用Packer和Vagrant等工具将虚拟机映像定义为代码。

容器引擎上运行的任何容器只能看到自己的用户空间，它从主机层面上和其他容器进行分离。容器将在所有环境（例如，你的本地计算机、QA服务器、生产服务器）中以完全相同的方式运行。缺点是，在一台服务器上运行的所有容器都共享该服务器操作系统的内核和硬件，因此在隔离度和安全性方面比虚拟机技术差很多

Vagrant通常用于创建在开发环境中运行的映像，例如，在Mac或Windows笔记本电脑上运行的VirtualBox。Docker通常用于创建单个应用程序的映像。Docker可以在生产环境或开发计算机上运行，只要求该计算机已经预安装了Docker引擎即可。

用于处理这些任务的都可以算作编排工具（orchestration tools），包括Kubernetes

kubectl apply -f example-app.yml命令，指示Kubernetes部署你的应用程序。也可以通过更改YAML文件并运行kubectl apply命令，再次进行更新。
服务开通工具

实际上，用户不仅可以使用服务开通工具来创建服务器，还可以创建数据库、缓存、负载均衡器、队列、监控程序、子网配置、防火墙设置、路由规则、安全套接字层（SSL）证书，以及涉及基础设施的所有其他部分，如图1-5所示。

图1-5：使用服务开通工具，通过云服务提供商提供的接口，来创建服务器、数据库、负载均衡器，以及基础设施的所有其他部分

user_data
这个参数指定了在Web服务器启动时，需要执行的Bash脚本。上面代码示例中的脚本，用来启动Apache服务。

内核空间通常留给操作系统底层的、最受信任的功能（通常这被称为内核）。在用户空间中运行的代码无法直接访问硬件，而必须使用操作系统内核公开的API。这些API可以加强安保限制（如用户权限）和安全限制（如用户空间中的应用程序崩溃通常只影响该应用程序），因此几乎所有应用程序代码都运行在用户空间中。

### 基础设施即代码的好处

：代码的功能是极其强大的。通过早期投入将手动工作转化为代码，你的软件交付能力将得到显著改善。根据2016年DevOps状况报告（见参考资料第1章[2]），使用DevOps实践（例如IaC）的组织，部署频率提高了200倍，从故障中恢复的速度提高了24倍，交付周期缩短为原来的1/2555。

自助服务
大多数手动部署代码的团队，只有极少数的系统管理员（通常只有一个人）知道部署过程的全部细节，并且是唯一有权限访问生产环境的人。随着公司的发展，这将成为一个主要的瓶颈。如果你的基础设施是通过代码定义的，整个部署过程可以自动化，开发人员可以在必要时自己启动部署过程。

速度和安全性
自动化将大大加速部署过程，因为计算机可以比人更快、更安全地执行部署步骤，所以自动化的过程将更加一致，更具可重复性，并且不易出现人为错误。

文档
避免将基础设施的细节遗忘在系统管理员的记忆中。将基础设施定义为代码之后，就可以将其状态保存并显示在任何人都可以读取的源文件中。换句话说，IaC同时具备文档功能，即使系统管理员休假，也允许组织中的其他人了解部署的运行方式。

版本控制
将IaC源文件存储在版本控制系统中，基础设施的历史变更记录将在提交日志中被完整保留。这将成为强大的调试工具，任何时候一旦出现故障，第一步就是检查提交日志并找出基础设施发生了什么变化，第二步是通过简单地还原IaC代码到之前已知的正常版本来解决问题。

重用
基础设施可以打包成可重用的模块，这样针对每个新产品、新环境，可以避免从头编写部署代码，通过利用已知的、经过实战测试的模块[1]，达到快速开发的目的

IaC提供了一种更好的选择，让计算机处理擅长的事情（自动化），让开发人员从事擅长的任务（代码开发）。

### Terraform的工作原理

Terraform使用Go语言编写，是由HashiCorp公司创建的开源工具。Go语言代码被编译成一个叫Terraform的二进制文件。更准确地说，对于每个支持Terraform的操作系统，都存在一个特定的二进制文件。

Terraform的语法（将在第2章学到）非常简单，可以在多云环境下进行互相关联的部署。

terraform命令将对代码进行解析，将代码转化为云服务提供商的一系列API调用，并在此过程中优化API调用。

当团队成员需要对基础设施进行更改时，他们不需要在服务器上手动更新基础设施。正确做法是，首先更改Terraform配置文件，然后通过自动测试和代码评审来验证变更的正确性，之后将代码更新提交到版本控制系统，最后运行terraform apply命令，由Terraform进行必要的API调用来正式部署变更。

Terraform的方法是允许用户编写针对每个云服务提供商的特定代码，从而利用该提供商的独特功能和特性，但对所有提供商使用统一的语言、工具集和IaC实践。

### Terraform与其他IaC工具的比较

过程性程序代码限制可重用性
过程性的程序代码的重用性是十分有限的，因为你必须考虑基础设施的当前状态。由于状态不断变化，一周前使用的代码可能现在已经失效，因为设计它时针对的基础设施状态已经发生改变。过程性代码的存储库会随着时间的推移而变得庞大而复杂。

使用Terraform的声明性语言，代码始终代表基础设施的最新状态。通过阅读代码，你可以确定当前环境的部署内容及配置细节，不必担心历史记录或时间顺序。

Terraform使用云服务提供商的API与云平台进行通信，从某种意义上讲，API服务器就扮演着主控服务器的角色，只是它们不需要任何额外的基础设施或额外的身份验证机制（只需要使用已有的API密钥）。Ansible通过SSH直接连接到每个服务器来工作，因此，不需要运行任何额外的基础设施或管理额外的身份验证机制（只需要使用已有SSH密钥即可）。

代理方式与无代理方式对比
Chef、Puppet和SaltStack都要求在被管理的每台服务器上安装代理软件（如Chef Client、Puppet Agent、Salt Minion）。这些客户端代理软件运行在服务器的后台，负责安装配置管理系统中的更新。

关于自举
如何首次进行服务开通并在服务器上安装代理软件？一些配置管理工具只是在回避这个问题，而假设某些外部过程会解决这些问题

需要维护
你需要定期细心地更新代理软件，并使其与主控服务器（如果有的话）保持同步。你还需要监控这些代理软件，在它们崩溃时重新启动。

Terraform使用无主控服务器模式和无代理软件的架构（如图1-8所示）。只需要运行Terraform客户端，就可以通过云服务提供商（例如AWS）的API来完成其余的工作了。

Terraform和Ansible正在经历爆炸性增长。贡献者、得星评级、开放源代码库、StackOverflow帖子和职位数量的增加都是史无前例的。[3]这两个工具在当今都有庞大而活跃的社区，从这些趋势来看，它们在未来会更加壮大。

搭配使用Terraform和Ansible，如图1-9所示。你可以使用Terraform部署所有基础设施，包括网络拓扑（如虚拟私有云VPC、子网、路由表）、数据存储（如MySQL、Redis）、负载均衡器和服务器。然后使用Ansible将应用程序部署在这些服务器之上。

主要缺点是，使用Ansible通常意味着正在对可变服务器编写大量过程性代码，随着代码库、基础设施和团队的增长，维护会变得更加困难。

### 设置AWS账户

需要使用AWS身份和访问管理（IAM，Identify and Access Management）服务。

如果要授予IAM用户执行某项操作的权限，需要将一个或多个IAM策略与该用户的账户相关联。IAM策略是一个JSON文档，用于定义用户的权限。你可以创建自己的IAM策略，也可以使用一些预定义的IAM托管策略。[2]

### 安装Terraform

为了使Terraform能够对你的AWS账户进行直接操作，需要将环境变量AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY设置为之前创建的IAM用户的访问ID和密钥。

除了通过环境变量进行身份验证，Terraform也支持与所有AWS命令行工具和SDK工具相同的身份验证机制，使用$HOME/.aws/credentials文件中的密钥，密钥信息可以通过在AWS命令行或IAM角色上运行configure命令自动生成。

### 部署单个服务器

Terraform代码是以HashiCorp配置语言（HashiCorp Configuration Language，HCL）编写的，扩展名为.tf。[1]HCL是一种声明性语言，目标是描述所需的基础设施，Terraform将自动计算生成创建它的方法。Terraform可以跨各种平台和提供商（包括AWS、Azure、Google Cloud、DigitalOcean等）创建基础设施。

使用Terraform的第一步通常是配置要使用的提供商。

这里告诉Terraform将使用AWS作为服务提供商，并且要将基础设施部署到us-east-2区域。AWS的数据中心遍布世界各地，位于相同地理区域的多个数据中心，被统一命名为一个区域（region）。

每个区域包括多个相互隔离的数据中心，称为可用区（Availability Zones，AZ），例如us-east-2a、us-east-2b等。[2]

其中PROVIDER是提供商的名称（例如aws）。TYPE是在该提供商中创建的资源类型（例如instance）。NAME是一个标识符，你可以在整个Terraform代码块范围内通过这个标识符引用该资源（例如my_instance）。CONFIG包括一个或多个特定于该资源的参数或参数组。

terraform可执行文件包含Terraform的基本功能，但它并不包含任何服务提供商（例如AWS提供商、Azure提供商、GCP提供商等）的代码，所以第一次开始使用Terraform时，需要运行terraform init命令，指示Terraform扫描代码，找出用到的提供商，并下载它们需要使用的代码库。在默认情况下，提供商代码将被下载到.terraform文件夹中，该文件夹是Terraform的临时目录（用户或许需要将其添加到.gitignore，以防止将这个临时目录上传到版本控制系统）。

### 部署单个Web服务器

当在一个资源内引用另一个资源时，会创建隐式依赖关系。Terraform可以通过分析这些依赖关系，构建依赖关系图，并使用该关系图自动确定资源的创建顺序。

可以通过运行terraform graph命令显示依赖关系图。

### 部署可配置的Web服务器

Web服务器代码中安全组和用户数据配置被同时配置为8080端口。这违反了不要重复自己（Don’t Repeat Yourself，DRY）的原则：每条知识在系统中必须具有唯一、明确、权威的表示形式。[1]如果将端口号配置在两个地方，则很容易在一个地方进行了更新，而忘记在另一个地方进行相同的更改。

如果未指定类型，那么Terraform会设置默认约束类型为any。

类型约束也可以搭配使用。例如，这是一个列表输入变量，要求所有的列表值为数字。

也可以通过环境变量来设置输入变量初始值。命名规范是TF_VAR_<name>，其中<name>是你要设置的输入变量的名称。

运行terraform output <OUTPUT_NAME>命令来查看名为<OUTPUT_NAME>的特定输出变量的取值。

输入变量和输出变量，也是创建可配置和可重用的基础设施代码的重要组成部分，在第4章中会进一步介绍该主题。

### 部署Web服务器集群

幸运的是用户可以使用AWS的Auto Scaling Group（ASG）来实现自动管理，即使用ASG运行Web服务器集群来代替单个Web服务器，

一个数据源代表在每次运行Terraform时，从服务提供商（在本例中为AWS）获取的只读信息。将数据源添加到Terraform配置中，并不会创建任何新内容。这只是提供一种手段，通过服务提供商的API，读取数据并使该数据对于其余Terraform代码可见、可用。每个Terraform服务提供商都会公开各种数据源。

对于数据源来说，传入的参数可以被理解为一种搜索过滤器，用于向数据源指示你要查找的信息。使用aws_vpc数据源时，通过将过滤器设置为default=true，可以指示Terraform在AWS账户中查找默认的VPC。
要从数据源中读取数据，请使用属性引用语法。

### 部署负载均衡器

AWS提供了3种不同类型的负载均衡器。
应用程序负载均衡器（ALB）
适合HTTP和HTTPS流量的负载均衡，工作在OSI模型的应用层（第7层）。

适合TCP、UDP和TLS流量的负载均衡，可以比ALB更快地响应向上或向下扩展（NLB每秒可以处理千万级请求），在OSI模型的传输层（第4层）上运行。

经典负载均衡器（CLB）
这是早于ALB和NLB的“传统”负载均衡器，可以处理HTTP、HTTPS、TCP和TLS流量，但功能与ALB或NLB相比少了很多。同时在OSI模型的应用程序层（第7层）和传输层（第4层）上运行。

### 清理工作

Terraform将首先构建依赖关系图，以正确的顺序删除所有资源，同时使用尽可能多的并行处理机制。

### 什么是Terraform的状态

plan命令的输出是：计算机上存储的代码与现实世界中部署的基础设施之间的区别

锁定状态文件
一旦共享了状态文件，又会遇到一个新问题：如何锁定。如果没有锁定机制，那么当两个团队成员同时运行Terraform时会发生竞争状况，而若多个Terraform进程对状态文件进行并发更新，则会导致写入冲突、数据丢失和状态文件损坏。

### 共享存储状态文件

但是至少数据在静态存储状态中（Amazon S3使用AES-256支持服务器端加密）和传输状态中（Terraform使用SSL加密数据在Amazon S3中的读取和写入）处于加密状态。

• 它支持通过DynamoDB来锁定（稍后将对此进行详细介绍）。

### Terraform后端的局限性

另一个解决方案是使用开源工具Terragrunt，Terragrunt试图填补Terraform功能上的一些空白，遵循DRY（不要重复自己）原则，可以将backend中所有基本后端设置（bucket名称、区域、DynamoDB表名）定义在一个文件中，并将key参数自动设置为模块的相对路径

### 隔离状态文件

通过文件布局隔离
文件布局隔离法适用于需要严格隔离的生产环境用例。

使用单独的文件夹，你可以十分清楚地了解到正在部署哪一个环境。使用单独的状态文件和独立的认证机制，将会大大地降低一个环境中的部署过程影响其他环境的可能性。

因此，我建议为每个环境（预发布环境、生产环境等）和每个组件（VPC、服务、数据库）使用单独的Terraform文件夹（并因此使用单独的状态文件）。

每一个组件中，都会有相应的Terraform的配置文件，其命名规则如下。
variables.tf
输入变量。
outputs.tf
输出变量。
main.tf
资源定义。

对于单一环境，如果一个Terraform配置文件保存所有组件的定义，你可以通过运行一次terraform apply命令，创建完整环境。但是，如果所有组件都分别保存在单独的文件夹中，那么你需要在每个文件夹中多次运行terraform apply（请注意，使用Terragrunt，可以通过apply-all命令来自动执行此过程[2]）。

如果使用我推荐的方法将应用程序代码和数据库代码存放在不同的文件夹中，则无法使用属性引用。幸运的是，Terraform的terraform_remote_state数据源为这个问题提供了一个解决方案。

### terraform_remote_state数据源

注意，该变量故意没有设置默认值。因为你不应以纯文本格式存储数据库密码或任何敏感信息。你将使用环境变量来进行赋值。

该机密信息将以纯文本形式存储在Terraform状态文件中。

数据库的所有输出变量都存储在状态文件中，通过terraform_remote_state数据源读取其属性引用的方式如下。

template参数指向user_data.sh脚本，vars参数包括3个User Data脚本中需要的变量：服务器端口、数据库地址和数据库端口。要使用这些变量，你需要按以下方式更新stage/services/webserver-cluster/user-data.sh脚本。

将User Data中的脚本提取到外部文件的好处是，你可以为其编写单元测试。测试代码甚至可以使用环境变量来填充内置插入变量，因为Bash语法的环境变量与Terraform的内插语法相同。你可以按照以下几行代码为user-data.sh编写自动测试。

### 第4章 使用Terraform模块创建可重用基础设施

模块化是编写可重用、可维护和可测试的Terraform代码的关键要素。一旦开始使用，你一定会喜欢上模块并开始尝试：将所有代码功能模块化，在公司中创建模块共享库，使用网上发现的模块，甚至将整个基础设施看成可重复使用的模块的集合。

### 模块基础知识

整个Terraform代码中可以通过使用该标识符来引用此模块（如web-service），SOURCE是模块代码的路径（如modules/services/webserver-cluster），CONFIG包括一个或多个该模块的特有参数。

### 模块的输入

设置模块的输入变量的语法与设置资源的输入变量的语法是相同的。输入变量可以看作模块的API，控制模块在不同环境中的行为。

### 模块的局部变量

所以除了使用输入变量，你还可以将它们定义为局部变量，放在locals模块中。
￼
本地变量允许用户为任何Terraform表达式分配名称，并在整个模块中引用该名称。这些名称仅在模块中可见，因此它们对其他模块没有影响，并且不能从模块外部改写这些值。要读取本地的值，需要使用本地引用，该引用使用以下语法。

本地变量使你的代码更易于阅读和维护，因此请经常使用它们。

### 模块的输出

在Terraform中，使用已知的机制—输出变量，模块也可以返回值。你可以按如下所示，在modules/services/webserver-cluster/outputs.tf文件中将ASG名称添加为输出变量。
￼
你可以使用以下语法访问模块输出变量。

### 模块版本控制

这种耦合性，使得在不影响生产环境的情况下，测试预发布环境变得十分困难。一种更好的方法是使用版本化的模块（versioned modules），这样可以在预发布环境中使用一个版本（如v0.0.2），在生产环境中使用另一个版本（如v0.0.1）

其实除文件路径外，Terraform还支持其他类型的模块源，例如Git URL、Mercurial URL和任意的HTTP URL。[1] 创建版本化模块的最简单方法是将模块代码放在单独的Git存储库中，并设置source参数为该存储库的URL。这意味着你的Terraform代码将（至少）分散在两个存储库中。

modules
这个存储库定义可重用模块。将每个模块视为定义基础设施特定部分的“蓝图”。

MAJOR版本，当进行了不兼容的API更改时
• MINOR版本，当以向后兼容的方式添加新功能时
• PATCH版本，当进行向后兼容的错误修复时

### 第5章 Terraform技巧和窍门：循环、if表达式、部署和陷阱

Terraform是一种声明性语言。如第1章中所述，使用声明性语言的IaC工具，可以提供比过程性语言更为准确的实际部署视图，推理起来更容易，代码库体积也更小。

### 循环

为了解决这两个限制，Terraform 0.12引入了for_each表达式。
使用for_each表达式循环
for_each表达式可以循环遍历列表、集合和映射，用于创建整个资源的多个副本，或资源内的内联块的多个副本。

现在只删除了需要被删除的资源，而不会移动其他资源。这就是为什么应该优先使用for_each而不是count来创建多个资源副本的原因。

### 有条件的判断

• 如果在资源上将count设置为1，可获得该资源的一个副本。如果将count设置为0，则不会创建该资源。

### Terraform陷阱

• 你无法在count或for_each中引用任何资源输出
• 你不能在module配置中使用count或for_each
让我们深入研究一下。

Terraform要求在plan阶段计算count和for_each，这发生在任何资源创建或修改之前。意味着count和for_each可以引用预先设定的固定值、变量、数据源，甚至可以引用资源列表（只要列表的长度在plan阶段可以被确定），但不能使用执行阶段计算生成的资源输出。

对已经存在的基础设施，请使用import命令。

将aws_security_group的标识符从instance更改为cluster_instance，从Terraform的角度来看，是删除了旧资源并添加了一个全新的资源。如果apply这些更改，Terraform将删除旧的安全组并创建一个新的安全组，在这期间服务器将拒绝所有网络流量。

在销毁前创建
如果确实要替换资源，请仔细考虑是否需要在删除之前先进行创建。如果需要这样，你可以通过create_before_destroy参数来实现。或者，也可以通过两个手动步骤来实现相同的效果：首先，将新资源添加到配置中，运行apply命令；接下来，从配置中删除旧资源，再次运行apply命令。

在重命名标识符时，需要运行terraform state mv命令，该命令具有以下语法。

一些参数是不可变的
许多资源的参数都是不能被更改的。如果更改它们，Terraform将删除旧资源并创建一个新资源来替换它。每个资源的文档通常会说明如果你更改参数会发生什么，因此请养成查阅文档的好习惯。再次强调，请始终使用plan命令，并考虑是否应使用create_before_ destroy策略。

### 小结

当然编写代码时也不要太过疯狂，因为仍然需要其他人来阅读和维护你的代码。恰到好处的灵感，可以为模块创建干净而漂亮的API。

### 第6章 生产级Terraform代码

生产级基础设施（production-grade infrastructure）

• 生产级基础设施模块特点
➢ 模块要小型化
➢ 可组合的模块
➢ 可测试的模块
➢ 可发布的模块
➢ Terraform模块之外的内容

### 为什么构建生产级基础设施需要漫长的过程

软件项目的时间估计都是非常不准确的，DevOps项目的时间估算只会更糟糕。以为只需要5min的快速修改，往往会占用一整天的时间；估计需要一天完成的简单功能却持续了两个星期；认为两周后就会投入生产的应用程序，在6个月之后尚未完成。

所有这些相对较新的工具和技术都在迅速地变化着。这也意味着它们并不是特别成熟，缺乏经验丰富的从业人员，因此项目花费时间比预期时间更长，也就不足为奇了。

“剪牦牛毛”这个俗语，泛指所有细微的，看似无关的任务，但是你必须先完成这些任务，才能执行本来想做的事情。如果开发软件，尤其是在DevOps行业工作，那么你可能已经看到过上千次这样的情况了。

部分原因是DevOps技术和现代系统设计不成熟的结果，系统通常与基础设施存在过于紧密的耦合和重复。

### 生产级基础设施检查清单

表6-2：生产级基础设施检查清单

安全任务，例如使用TLS进行数据传输加密、处理身份验证，以及存储机密信息，通常也要等到最后一刻才会被提起。

每次在新的基础设施上工作时，请务必根据这个清单进行检查。并非每个基础设施都需要列表中的所有条目，但是你应该有意识地、明确地记录已经实施的条目、决定跳过的条目，以及跳过的原因。

### 生产级基础设施模块特点

大型模块很慢如果所有基础设施都定义在一个Terraform模块中，那么运行任何命令都将花费很长的时间。我曾经看到过很庞大的模块，每次运行terraform plan命令，都需要5到6min才能完成！

大型模块有风险如果将所有鸡蛋都放在一个篮子里，则任何局部的错误都可能破坏所有物品。例如，在预发布环境中，为了对前端应用程序做细微的改动，你不小心拼写错误或运行了错误的命令，这都会导致意外删除生产环境数据库的发生。

大型模块很难评审评审由几十行代码组成的模块很容易。但评审包含数千行代码的模块是几乎不可能的。而且，terraform plan命令不仅运行时间会更长，plan命令的输出结果也会多达几千行，这意味着没有人会去仔细阅读它。例如，没有人会注意到一条小红线表示你的数据库将要被删除。

简而言之，应该使用小模块来构建代码，每个模块各自完成一个功能。

更好的方法是将其重构为多个小而且独立的函数，每个函数只做一件事。

modules/cluster/asg-rolling-deploy一个通用的、可重用的独立模块，用于部署一个可以进行零停机、滚动部署的ASG。

modules/networking/alb一个通用的、可重用的独立模块，用于部署一个ALB。

modules/services/hello-world-app一个专门用于部署“Hello, World”应用的模块。

UNIX的哲学思想是：每个程序只做一件事并做得很完美，再编写程序让它们协同工作。函数组合（function composition）是达到这一点的一种方法。在函数组合中，可以将一个函数的输出，作为输入传递给另一个函数。例如，如果你在Ruby中具有如下的简单函数。

“副作用最小化”是函数式编程的核心宗旨之一，它使代码更易于推理、测试和重用。重用的特性特别引人注目，因为函数组合允许你通过使用简单的函数来逐步构建更复杂的函数。

尽管在编写基础设施代码时无法完全避免副作用，但是仍然可以在Terraform模块中遵循相同的基本原则：通过输入变量传递内容，通过输出变量返回内容，并通过组合简单的模块来构建更复杂的模块。

这里创建的模块不是直接可以部署的根模块。为了测试部署它们，需要编写一些Terraform代码，处理插入所需的参数、设置provider、配置backend等工作。一种清晰的方法是，创建一个example文件夹。顾名思义，该文件夹将展示如何使用这个模块的示例。让我们尝试一下。

你在modules文件夹中拥有的每个Terraform模块，都应该在examples文件夹中有一个相对应的示例，并且examples文件夹中的每个示例都应该在test文件夹中有一个相对应的测试。实

发布模块的另一种方法是，将它们发布到Terraform注册中心。公共的Terraform注册中心位于参考资料第6章[6]，其中包括数百个可重复使用的、社区维护的开源模块，适用于AWS、Google Cloud、Azure和许多其他提供商。将模块发布到公共的Terraform注册中心有以下要求。[3]

• 该模块必须存放在公共GitHub存储库。• 存储库必须遵循命名规范terraform-<PROVIDER>-<NAME>，其中PROVIDER指定模块的目标提供商（如aws），而NAME是模块的名称（如vault）。• 模块必须遵循特定的文件结构，包括在存储库的根目录中定义Terraform代码、提供README.md、使用main.tf、variables.tf和outputs.tf等约定文件名。• 代码库必须使用遵循语义版本规则的Git标签（x.y.z）来进行发布。

通过Terraform预配器，Terraform可以执行本地计算机或远程计算机上的脚本，通常用于执行引导、配置管理或清理工作。几种不同的预配器包括local-exec（在本地计算机上执行脚本）、remote-exec（在远程资源上执行脚本）、chef（在远程资源上运行Chef Client）和file（复制文件到远程资源）。[4]

预配器仅有的优点如下。• 用户数据脚本的长度限制为16 KB，而预配器脚本的长度没有限制。• Chef、Puppet和Salt预配器分别在服务器上自动安装、配置和运行Chef、Puppet和Salt客户端。这样可以更轻松地使用配置管理工具，代替临时脚本来配置服务器。

预配器只能定义在资源内部，但是有时我们会希望执行无须绑定到特定资源的预配器。使用名为null_resource的资源可以达到这个目的。null_resource类似于普通的Terraform资源，但它不会创建任何内容。

null_resource资源甚至有一个很方便的参数叫作triggers，这个参数接受键值对的映射类型。每当数值发生更改时，null_resource将被重新创建，所有预配器也将被再次执行。例如，想在每次运行terraform apply命令时都执行一次null_resource中的预配器，可以在triggers参数中使用uuid()内置函数，该函数每次返回一个新的随机生成的UUID。

有时，你真正想要做的是：通过执行脚本来获取一些数据，并使这些数据对Terraform代码本身可用。这时应该使用external数据源，该数据源允许通过外部命令实现特定协议，从而充当数据源。协议如下。

### 小结

2. 创建一个examples文件夹并首先编写示例代码，定义模块的最佳用户体验和最简洁的API。为模块的每个重要使用方法创建一个示例，并包括足够的文档和合理的默认值，使示例尽可能易于部署。

3. 创建一个modules文件夹，通过编写一组小型化的、可重用的、可组合的模块，开始实施之前定义的API。通过Terraform和其他工具（如Docker、Packer和Bash）的配合，来实现这些模块。确保锁定Terraform和提供商程序版本。

### 手动测试

强烈建议为每个团队设置一个隔离的沙箱环境，允许开发者按需求创建和删除基础设施，而不必担心影响其他人。实际上，为了减少多个开发人员之间发生冲突的机会（例如，两个开发人员试图创建一个同名的负载均衡器），黄金法则是每个开发人员都拥有完全隔离的沙箱环境。例如，如果开发针对AWS的Terraform代码，黄金法则是每个开发人员都拥有自己的AWS账户，可以用来测试他们想要的任何东西。[1]

### 自动测试

单元测试可以验证单个的、小型代码的功能。单元（unit）的定义各不相同，在通用编程语言中，单元通常是指单个函数或类。所有外部依赖项（例如数据库、Web服务，甚至文件系统）都将被测试替身（test doubles）或模拟（mocks）代替，从而使用户可以很好地控制依赖项的行为

集成测试
集成测试用来验证多个单元是否可以正常协同工作。在通用编程语言中，集成测试可以验证多个功能或类是否正确地协同工作。集成测试通常会使用真实依赖项和模拟的混合：例如，如果要测试应用程序中与数据库通信的部分，你可能想要使用真实数据库进行测试，但是模拟其他依赖项，例如应用程序的身份验证系统。

端到端测试
端到端测试涵盖整个运行体系架构（例如，你的应用程序、数据存储、负载平衡器），验证系统是否可以整体工作。这些测试是从最终用户的角度进行的，例如使用Selenium通过浏览器自动与产品交互。

每种类型的测试都有不同的用途，可以捕获不同类型的错误，因此需要将这3种类型的测试同时使用。单元测试的目的是快速运行测试，迅速获得关于更改的反馈，并验证各种不同参数的排列组合，增强对代码基本构建模块（各个单元）能够按预期工作的信心。但是，仅仅验证单个单元在隔离状态下可以正常工作，并不意味着它们组合在一起时仍然可以正常工作，所以需要进行集成测试，确保基本构建模块能够正确地组合在一起。仅仅因为系统的不同部分可以一起正常工作，并不意味着它们在实际环境中部署后仍然可以正常工作，因此需要进行端到端测试，验证代码在近似生产环境下的行为是否符合预期。

在Terraform中，与单个函数或类最接近的是单个通用模块

这意味着编写Terraform单元测试的基本策略如下。
1. 创建一个通用的独立模块。
2. 为该模块创建一个易于部署的示例。
3. 运行terraform apply命令，将示例部署到实际环境中。
4. 验证刚刚部署的内容是否按预期工作。此步骤特定于进行测试的基础设施类型。例如对于ALB，可以通过发送HTTP请求，并检查是否收到了预期的响应来进行验证。

自动测试的下一步，要运行terraform init和terraform apply命令来部署代码。Terratest有方便的辅助工具来实现这些。

实际上，同时运行init和apply命令，是Terratest一个很常用的操作，所以还有一个更方便的方法将两个命令一起运行。


端到端测试可能包括部署Web服务器及依赖的任何数据库，然后使用Selenium之类的工具从Web浏览器进行测试。Terraform基础设施的端到端测试是十分类似的：将所有内容部署到模拟生产的环境中，从最终用户的角度进行测试。

测试金字塔表达的思想是，应该进行大量单元测试（金字塔的底部）、较少数量的集成测试（金字塔的中间）和更少数量的端到端测试（金字塔的顶部）。因为随着金字塔的上升，编写测试的成本、复杂性、测试的脆弱性，以及测试的运行时间都在增加。

太慢
从头开始部署整个体系设施，然后再全部销毁，可能会持续非常长的时间—大约几个小时。花费大量时间的测试套件提供的价值相对较小，因为反馈回路太慢了。只能在夜间运行这样长时间的测试套件，意味着你将在早上收到有关测试失败的报告，再经过一段时间调查，提交新的修复，然后等待第二天查看修复是否有效。这样一来，每天只能尝试进行一次错误修复。这种情况下，开发人员开始相互指责，说服管理人员即使在测试失败的情况下也要进行部署，最终会完全忽略测试失败

静态分析
有几种工具可以在不运行Terraform代码的情况下对其进行分析，具体如下所示。
terraform validate
这是Terraform内置的命令，可用于检查Terraform语法和类型（有点像编译器）。
tflint（见参考资料第7章[10]）
这是一种专门用于Terraform的“lint”工具，它可以根据一组内置规则，扫描Terraform代码并捕获常见错误和潜在错误。

### 小结

较小的模块测试起来更简单、更快速
这也是第6章的主要内容之一，在本章中有必要重复：较小的模块更易于创建、维护、使用和测试

### 在团队中实施IaC

• 说服老板
• 逐步开展工作
• 给团队学习的时间

与其谈论Terraform是支持多云环境的，不如描述一下，如果有一天迁移云环境时，老板不需要担心潜在的工具变更。与其向老板解释Terraform是开源的，不如帮助老板了解，从一个活跃的大型开源社区中，可以很容易地为团队雇用开发人员。

但是最好的销售人员知道一个更有效的策略：关注问题。当你观察一位出色的销售员与客户交谈时，会发现实际上大部分的谈话是由客户进行的。销售人员将主要时间用于倾听和寻找一个答案：客户试图解决的关键问题是什么？最大的痛点是什么？最好的销售人员不会尝试销售某种功能或收益，而是尝试解决其客户的问题。

当与老板交谈时，不要只是谈论Terraform的功能或好处，请用以下方式开始对话：“我有一个方法可以将停机次数减少一半”。我保证这会引起老板的注意。利用这个好机会，向老板描绘一个全自动的、可靠的、可重用的部署过程是如何避免手动错误，将错误率降低一半的，并描绘当部署自动化后，可以继续添加自动测试，进一步减少潜在的停机错误，使整个公司的部署频率提高两倍。

如果想成功部署IaC，或者在任何其他类型的迁移项目上取得成功，唯一可行的方法就是逐步增量地开展工作。

因此，增量主义至关重要。项目的每个部分都应该提供一定的价值，这样即使项目没有完成，无论实现到了哪一步，仍然可以输出一定的价值。最好的方法是，每一次集中解决单一的、小规模的、具体的问题。例如，不要试图做“大爆炸”式的云迁移，而是找出一个存在痛点的、小规模的、特定的应用或团队，只是去迁移它们。

### 部署应用程序代码的工作流程

通过设置提交拦截脚本（commit hooks），可以对推送到版本控制系统的每个提交运行自动测试。最常见的方法是使用一个持续集成（Continuous Integration，CI）服务器，

下一步是发布代码。如果使用不可变的基础设施实践（如第1章的“服务器模板工具”中所述），则发布应用程序代码意味着要将该代码打包到新的不可变的版本化工件。根据打包和部署应用程序的方式，工件可能是新的Docker映像、新的虚拟机映像（如新的AMI）、新的.jar文件、新的.tar文件等。无论采用哪种格式，都要确保工件是不可变的（永远都不能对其进行更改），并且具有唯一的版本号（可以将该工件与其他工件区分开）。

提交ID的缺点是不容易阅读或记忆。另一种方法是创建一个Git标签。


标签是指向特定Git提交的指针，但具有更友好的名称。可以在Docker映像上使用此Git标签。

在调试时，根据特定的标签，检出相应的代码。

Docker编排工具
市场上有许多用于部署和管理Docker化应用程序的编排工具，包括Kubernetes（最受欢迎）、

### 部署基础设施代码的工作流程

如果建立了这样的模块库（或购买了现成的库[1]），公司的所有团队将能够使用这些模块（有点像服务目录）来部署和管理自己的基础设施，而不需要每个团队花费数月的时间，从无到有组装基础设施，或让运维团队成为瓶颈，因为它需要部署和管理每一个团队的基础设施。取而代之的是，运维团队可以将大部分时间花费在编写基础设施模块的代码上，所有其他团队都独立工作，使用这些模块来完成他们的工作。而

针对生产环境的部署，应该在master分支上运行terraform apply命令

Terraform后端锁定机制可以锁定Terraform状态文件，但无法锁定Terraform代码本身。如果两个团队成员将相同的代码从不同的分支部署到相同的环境中，那么将陷入锁定机制也无法避免的冲突。

Terraform后端的锁定机制在这里无能为力，因为这里的冲突与状态文件的并发修改无关。Bill和Anna即使相隔数周部署各自的更改，问题还是相同的。造成这个问题的原因是，分支和Terraform不是好的组合。Terraform的一个隐含属性是，Terraform代码和真实世界中部署的基础设施之间存在着1:1的映射。因为真实世界只有一个，所以多个分支的Terraform代码并没有太大的意义。因此，对于任何共享环境（如Stage、Prod），请始终从单个分支进行部署。

一个测试包括以下步骤：部署数据库、部署应用程序、验证两者正常工作、销毁应用程序和销毁数据库。

文件布局
团队应该约定Terraform代码的存储位置，并定义如何使用文件布局。因为Terraform的文件布局会改变Terraform状态文件的存储方式，所以需要特别注意文件布局对隔离能力的影响，

Terraform甚至有一个内置的fmt命令，可以自动地重新格式化代码风格。
￼
你可以将这个命令作为提交拦截脚本的一部分来运行，确保所有进入版本控制系统的代码拥有一致的风格。

将plan命令集成到代码评审流程中。例如，Atlantis（见参考资料第8章[7]）是一个开源工具，它会在提交时自动运行terraform plan命令，并将 plan命令的输出添加到pull request的注释中，如图8-3所示。


在这种情况下，Terraform会将状态文件保存在磁盘上名为errored.tfstate的文件中。请确保CI服务器不会删除这些文件（例如，在构建后销毁工作空间时）！如果在失败的部署后仍然可以访问此文件，一旦Internet连接恢复，可以通过state push命令，将该文件推送到远程后端（如Amazon S3），以免出现状态信息丢失。

还是有大量的样板需要在每个环境之间进行复制，包括：
• 提供商配置
• 后端配置
• 设置所有该模块的输入变量
• 从模块输出所有的输出变量

每个模块中，多达数十行或数百行几乎相同的代码，要被复制/粘贴到每个环境。为了使代码更加简洁，并使环境之间推广Terraform代码更容易，可以使用前面提到的名为Terragrunt（见参考资料第8章[9]）的开源工具。

Terragrunt将使用指定的命令去调用Terraform，会在基于terragrunt.hcl文件的配置上，增加一些额外的行为。其基本思想是，modules存储库中定义所有相同的Terraform代码，而在实时存储库中，通过terragrunt.hcl文件，提供一种简洁方式来配置和部署每个环境中的各个模块。如图8-5所示为使用Terragrunt后的文件布局，这将大量降低实时存储库中的文件和代码行数。

当运行terragrunt apply命令时，代码会找到在terragrunt.hcl文件中的source参数，接下来Terragrunt将执行以下操作。
1. 检出source中指定的URL的代码到一个临时文件夹。source的参数支持与Terraform模块相同的URL语法，因此你可以使用本地文件路径、Git URL、版本化的Git URL（通过ref参数，如上例所示）等。

2. 在临时文件夹中运行terraform apply命令，将inputs = { … }代码块中定义的输入变量传递给它。

这种方法的好处在于，实时存储库中的代码将被减少到每个模块仅包含一个terragrunt.hcl文件，该文件包含指向要使用的模块的指针（指向特定的版本），以及为特定环境设置的输入变量。这是所能获得的最简洁的代码。

Terragrunt还可以保持backend配置的简洁。不必为每个模块重复定义bucket、key、dynamodb_table等参数。而是在每个环境下的terragrunt.hcl文件中进行定义。例如，live/stage/terragrunt.hcl文件。

key值中使用Terragrunt内置函数path_relative_to_include()。这个函数返回此terragrunt.hcl根文件到包含这个文件的任何子模块之间的相对路径。例如，将这个根文件包含在live/stage/data-stores/mysql/terragrunt.hcl中，只需添加一个include代码块。

在include代码块中，通过使用Terragrunt内置函数find_in_parent_folders()找到根目录的terragrunt.hcl文件。自动从该父文件中继承所有设置，包括remote_state配置。结

可以在日志输出中看到Terragrunt读取了terragrunt.hcl文件，下载了指定的模块，运行terraform init命令来配置backend（如果尚不存在，它甚至会自动创建S3 bucket和DynamoDB表），然后运行terraform apply命令部署所有内容。


该模块使用include代码块从根目录的terragrunt.hcl文件中继承相同的backend设置，而key值正如所期望的那样，将被自动更新为services/hello-world-app/terraform.tfstate。

[1]Gruntwork基础设施代码库是具有30多万行生产级的、商业化支持的、可重复使用的基础设施代码。已经在数百家企业的生产环境中被成功应用和证明见参考资料第8章[4]。

2]首先编写README自述文件的开发方式称为自述驱动开发（见参考资料第8章[6]）。

### 小结

包括如何编写Terraform码；如何管理Terraform状态；如何使用Terraform创建可重用的模块；如何执行循环、if表达式和部署；如何编写生产级Terraform代码；如何测试Terraform代码；以及如何以团队形式使用Terraform。

### 附录A 推荐阅读资料

• Infrastructure as Code: Managing Servers in the Cloud，作者：Kief Morris，O'Reilly出版

• Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation，作者：Jez Humble和David Farley，Addison-Wesley Professional出版


• Effective DevOps，作者：Jennifer Davis和Katherine Daniels，O'Reilly出版

### 关于作者

Yevgeniy（Jim）Brikman喜欢编程、写作、演讲、旅行和举重。他是Gruntwork公司的联合创始人，该公司提供DevOps服务。