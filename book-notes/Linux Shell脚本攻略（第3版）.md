## Linux Shell脚本攻略（第3版）
> 克里夫·弗林特 萨拉特·拉克什曼 山塔努·图沙尔

### 前言

系统管理员和集群管理员则能够学会利用容器、虚拟机和云来简化自己的工作。

### 1.1 简介

单个报表。没有操作系统，也没有图形化显示器，甚至连交互式提示符都没有。
到了20世纪60年代，计算机开始支持使用交互式终端（通常是电传打字设备或高级打字机）来调用命令。

Unix刚开始只支持一种交互式shell，它是由Stephen Bourne所编写的Bourne Shell（sh）。
1989年，GNU项目的Brian Fox吸收了大量其他用户界面的特性，编写出了一种全新的shell：Bourne Again Shell（bash）。bash shell与Bourne Shell完全兼容，同时又增添了一些来自csh、ksh等的功能。
随着Linux成为最流行的类Unix操作系统实现，bash shell也变成了Unix和Linux中既成事实的标准shell。

### 1.2 在终端中显示输出

当启动一个交互式shell时，它会执行一组命令来初始化提示文本、颜色等设置。这组命令来自用户主目录中的脚本文件~/.bashrc（对于登录shell则是~/.bash_profile）。Bash shell还维护了一个历史记录文件~/.bash_history，用于保存用户运行过的命令。

另一个可用于终端打印的命令是printf。该命令使用的参数和C语言中的printf函数一样。例如：

printf命令接受引用文本或由空格分隔的参数。我们可以在printf中使用格式化字符串来指定字符串的宽度、左右对齐方式等

使用echo和printf的命令选项时，要确保选项出现在命令中的所有字符串之前，否则Bash会将其视为另外一个字符串。

使用转义序列时，需要使用echo -e"包含转义序列的字符串"这种形式。例如：
￼
        echo -e "1\t2\t3"￼
        1   2   3

### 1.3 使用变量与环境变量

常用的惯例是在脚本中使用大写字母命名环境变量，使用驼峰命名法或小写字母命名其他变量。

每一个变量以name=value的形式来描述，彼此之间由null字符（\0）分隔。形式上确实不太易读。
要想生成一份易读的报表，可以将cat命令的输出通过管道传给tr，将其中的\0替换成\n：
￼
        $ cat /proc/12501/environ   | tr '\0' '\n'

环境变量是从父进程中继承而来的变量。例如环境变量HTTP_PROXY，它定义了Internet连接应该使用哪个代理服务器。

环境变量UID中保存的是用户ID。它可以用于检查当前脚本是以root用户还是以普通用户的身份运行的。例如：
￼
        If [$UID -ne 0]; then￼
          echo Non root user. Please run as root.￼
        else￼
          echo Root user￼
        fi


❏ 查看设置变量PS1的那一行：
￼
            $ cat~/.bashrc | grep PS1￼
            PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '


### 1.5 使用shell进行数学运算

也可以使用操作符(())。出现在(())中的变量名之前需要加上$：
￼
          result=$(( no1+50 ))
expr同样可以用于基本算术操作：
￼
          result=`expr 3+4`￼
          result=$(expr $no1+5)

以上这些方法不支持浮点数，只能用于整数运算。

3）bc是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数：

### 1.6 玩转文件描述符与重定向

文件描述符是与某个打开的文件或数据流相关联的整数。文件描述符0、1以及2是系统预留的。
❏ 0 —— stdin（标准输入）。
❏ 1 —— stdout（标准输出）。
❏ 2 —— stderr（标准错误

你可以将stderr和stdout分别重定向到不同的文件中：
￼
        $ cmd 2>stderr.txt 1>stdout.txt
下面这种更好的方法能够将stderr转换成stdout，使得stderr和stdout都被重定向到同一个文件中：
￼
          $ cmd 2>&1 alloutput.txt
或者这样
￼
          $ cmd &> output.txt

tee命令从stdin中读取，然后将输入数据重定向到stdout以及一个或多个文件中。
￼

默认情况下，tee命令会将文件覆盖，但它提供了一个-a选项，可用于追加内容。
￼
        $ cat a＊ | tee -a out.txt | cat -n


要发送输入内容的两份副本给stdout，使用-作为命令的文件名参数即可：
￼
        $ cmd1 | cmd2 | cmd -

1．将文件重定向到命令
借助小于号（<），我们可以像使用stdin那样从文件中读取数据：
￼
          $ cmd < file


          $ exec 3<input.txt     #使用文件描述符3打开并读取文件

### 1.7 数组与关联数组

数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。

（3）以列表形式打印出数组中的所有值：
￼
            $ echo ${array_var[＊]}￼
            test1 test2 test3 test4 test5 test6

关联数组从Bash 4.0版本开始被引入。当使用字符串（站点名、用户名、非顺序数字等）作为索引时，关联数组要比数字索引数组更容易使用。

### 1.8 别名

（2）alias命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名在所有的shell中都可用，可以将其定义放入~/.bashrc文件中。每当一个新的交互式shell进程生成时，都会执行~/.bashrc中的命令。
￼

### 1.11 调试脚本

我们可以利用Bash内建的调试工具或者按照易于调试的方式编写脚本，方法如下所示。
（1）使用选项-x，启用shell脚本的跟踪调试功能：

❏ set -x：在执行时显示参数和命令。
❏ set+x：禁止调试。
❏ set -v：当命令进行读取时显示输入。
❏ set+v：禁止打印输入。

把shebang从#!/bin/bash改成 #!/bin/bash -xv，这样一来，不用任何其他选项就可以启用调试功能了。
如果每一行前面都加上+，那么就很难在默认输出中跟踪执行流程了。可以将环境变量PS4设置为'$LINENO:'，显示出每行的行号：
￼
        PS4='$LINENO: '

### 1.12 函数和参数

❏ "$@"被扩展成"$1" "$2" "$3"等。
❏ "$＊"被扩展成"$1c$2c$3"，其中c是IFS的第一个字符。
❏ "$@"要比"$＊"用得多。由于"$＊"将所有的参数当作单个字符串，因此它很少被使用。
比较别名与函数

可以通过修改配置文件/etc/security/limits.conf中的nproc来限制可生成的最大进程数，进而阻止这种攻击。

那么，它有如下几种执行方式：
❏ $ command -p -v -k 1 file
❏ $ command -pv -k 1 file
❏ $ command -vpk 1 file
❏ $ command file -pvk 1

更为常见的处理方式是迭代所有的命令行参数。shift命令可以将参数依次向左移动一个位置，让脚本能够使用$1来访问到每一个参数。下面的代码显示出了所有的命令行参数：
￼
          $ cat showArgs.sh￼
          for i in `seq 1 $#`￼
          do￼
          echo $i is $1￼
          shift￼
          done￼

### 1.13 将一个命令的输出发送给另一个命令

子shell本身就是独立的进程。可以使用()操作符来定义一个子shell

所有的改变仅限于该子shell内。例如，当用cd命令改变子shell的当前目录时，这种变化不会反映到主shell环境中。

2．通过引用子shell的方式保留空格和换行符
假设我们使用子shell或反引用的方法将命令的输出保存到变量中，为了保留输出的空格和换行符（\n），必须使用双引号

### 1.15 持续运行命令直至执行成功

函数repeat()中包含了一个无限while循环，该循环执行以函数参数形式（通过$@访问）传入的命令。如果命令执行成功，则返回，进而退出循环。

大多数现代系统中，true是作为/bin中的一个二进制文件来实现的。这就意味着每执行一次之前提到的while循环，shell就不得不生成一个进程。为了避免这种情况，可以使用shell的内建命令：，该命令的退出状态总是为0：

尽管可读性不高，但是肯定比第一种方法快。

### 1.16 字段分隔符与迭代器

内部字段分隔符（Internal Field Separator，IFS）是shell脚本编程中的一个重要概念。在处理文本数据时，它的作用可不小。

我们可以使用echo命令生成各种值序列：
￼
      echo {1..50};     #生成一个从1~50的数字序列￼
      echo {a..z} {A..Z};     #生成大小写字母序列

### 1.17 比较与测试

和else语句能够嵌套使用。if的条件判断部分可能会变得很长，但可以用逻辑运算符将它变得简洁一些：
❏ [condition] && action; # 如果condition为真，则执行action
❏ [condition] || action; # 如果condition为假，则执行action

❏ 文件系统相关测试
我们可以使用不同的条件标志测试各种文件系统相关的属性。
● [-f $file_var]：如果给定的变量包含正常的文件路径或文件名，则返回真

● [-d $var]：如果给定的变量包含的是目录，则返回真。
● [-e $var]：如果给定的变量包含的文件存在，则返回真。

测试空串。
● [[-z $str1]]：如果str1为空串，则返回真。
● [[-n $str1]]：如果str1不为空串，则返回真。

### 1.18 使用配置文件定制bash

当用户登出会话时，会执行下列文件：
￼
        $HOME/.bash_logout
例如，远程登录的用户需要在登出的时候清屏：

### 2.1 简介

类Unix系统享有最棒的命令行工具。这些命令的功能并不复杂，都能够简化我们的工作。简单的功能可以通过相互结合来解决复杂的问题。简单命令的组合是一门艺术，实践得越多，收益就越大。

### 2.2 用cat进行拼接

cat命令是一个经常会用到的简单命令，它本身表示conCATenate（拼接）。

1．去掉多余的空白行
有时候文本文件中可能包含多处连续的空白行。如果你想删除这些额外的空白行，可以这样做：
￼
        $ cat -s file

cat命令的-n选项会在输出的每一行内容之前加上行号

cat命令不允许使用相同的文件作为输入和重定向后的输出。利用管道并重定向输出会清空输入文件。

### 2.4 查找并列出文件

print选项使用\n（换行符）分隔输出的每个文件或目录名。而-print0选项则使用空字符'\0'来分隔。-print0的主要用法是将包含换行符或空白字符的文件名传给xargs命令。

find命令有一个选项-iname（忽略字母大小写），该选项的作用和-name类似，只不过在匹配名字时会忽略大小写。

find命令支持逻辑操作符。-a和-and选项可以执行逻辑与（AND）操作，-o和-or选项可以执行逻辑或（OR）操作。

find也可以用！排除匹配到的模式：
￼
        $ find . ! -name "＊.txt" -print

只列出所有的目录（包括子目录）：
￼
        $ find . -type d -print


只列出符号链接：
￼
        $ find . -type l -print

❏ 访问时间（-atime）：用户最近一次访问文件的时间。
❏ 修改时间（-mtime）：文件内容最后一次被修改的时间。
❏ 变化时间（-ctime）：文件元数据（例如权限或所有权）最后一次改变的时间。

-atime、-mtime以及-ctime都是以“天”为单位来计时的。find命令还支持以“分钟”为计时单位的选项。这些选项包括：
❏ -amin（访问时间）；
❏ -mmin（修改时间）；
❏ -cmin（变化时间）。

除了k之外，还可以用其他文件大小单位。
❏ b：块（512字节）。
❏ c：字节。
❏ w：字（2字节）。
❏ k：千字节（1024字节）。
❏ M：兆字节（1024K字节）。
❏ G：吉字节（1024M字节）

find命令的-delete选项可以删除所匹配到的文件。下面的命令能够从当前目录中删除.swp文件：
￼
            $ find . -type f -name "＊.swp" -delete

注意该命令结尾的\;。必须对分号进行转义，否则shell会将其视为find命令的结束，而非chown命令的结束。

-name ".git" -prune是命令中负责进行修剪的部分，它指明了.git目录应该被排除在外。-type f -print描述了要执行的操作

### 2.5 玩转xargs

Argument list too long。xargs命令可以解决这个问题。
xargs命令从stdin处读取一系列参数，然后使用这些参数来执行指定命令。它能将单行或多行输入文本转换成其他格式，例如单行变多行或是多行变单行。

xargs的-n选项可以限制每次调用命令时用到的参数个数。下面的命令将输入分割成多行，每行N个元素：

xargs命令接受来自stdin的输入，将数据解析成单个元素，然后调用指定命令并将这些元素作为该命令的参数。

我们可以定义一个用来分隔参数的分隔符。-d选项可以为输入数据指定自定义的分隔符：

如果文件系统的有些文件名中包含空格，find命令的-print0选项可以使用0（NULL）来分隔查找到的元素，然后再用xargs对应的-0选项进行解析。

使用find命令的-print0选项生成以空字符（'\0'）作为分隔符的输出，然后将其作为xargs命令的输入。


        $ cmd0 | ( cmd1;cmd2;cmd3) | cmd4
如果cmd1是cd /，那么就会改变子shell工作目录，然而这种改变仅局限于该子shell内部。cmd4则不受工作目录变化的影响

### 2.6 用tr进行转换

tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。在这则攻略中，我们会看到如何使用tr进行基本的集合转换。

在tr中利用集合的概念，可以轻松地将字符从一个集合映射到另一个集合中。下面来看一个用tr进行数字加密和解密的例子：

2．字符组补集
我们可以利用选项-c来使用set1的补集。下面的命令中


        tr -s '[需要被压缩的一组字符]'

得到了字符串1+2+3+..5+，但是在字符串的尾部多了一个操作符+。为了抵消这个多出来的操作符，我们再追加一个0。
$[operation]执行算术运算，因此就形成了以下命令：
￼
        echo $[1+2+3+4+5+0]

### 2.7 校验和与核实

校验和（checksum）程序用来从文件中生成相对较小的唯一密钥。

md5sum校验和计算的方法如下：
￼
        $ md5sum file1 file2 file3 ..
当使用多个文件时，输出中会在每行中包含单个文件的校验和：

### 2.8 加密工具与散列

加密技术主要用于防止数据遭受未经授权的访问。

❏ gpg（GNU privacy guard，GNU隐私保护）是一种应用广泛的工具，它使用加密技术来保护文件，以确保数据在送达目的地之前无法被读取。

用gpg加密文件：
￼
            $ gpg -c filename
命令会采用交互方式读取口令并生成filename.gpg。使用以下命令解密gpg文件：
￼
            $ gpg filename.gpg
上述命令读取口令并解密文件。

### 2.9 行排序

（4）按照月份排序（依照一月、二月、三月……）：
￼
            $ sort -M months.txt


-k指定了排序所依据的字符。如果是单个数字，则指的是列号。-r告诉sort命令按照逆序进行排序。例如：

### 2.10 临时文件命名与随机数

mktemp命令可以为临时文件或目录创建唯一的名字。
（1）创建临时文件：
￼
            $ filename=`mktemp`￼
            $ echo $filename￼
            /tmp/tmp.8xvhkjF5fH

❏ 如果仅仅是想生成文件名，不希望创建实际的文件或目录，可以这样：
￼
              $ tmpfile=`mktemp -u`￼
              $ echo $tmpfile￼

### 2.16 利用并行进程加速命令执行

但除非软件能够善加利用多核，否则它们毫无用武之地。例如，一个需要进行大量运算的程序可能仅运行在其中一个核心上，而其他的核心都处于闲置状态。如果想提高速度，软件必须留意并充分利用多核。

            PIDARRAY+=("$!")￼
          done￼
          wait ${PIDARRAY[@]}

我们利用了Bash的操作符&，它使得shell将命令置于后台并继续执行脚本。这意味着一旦循环结束，脚本就会退出，而md5sum进程仍在后台运行。为了避免这种情况，我们使用$!来获得进程的PID，在Bash中，$!保存着最近一个后台进程的PID。我们将这些PID放入数组，然后使用wait命令等待这些进程结束。

对于少量任务，Bash的操作符&效果很好。如果你有数以百计的文件要计算校验和，那么脚本就会生成上百个进程，这有可能会强迫系统执行换页操作（swapping），拖慢执行速度。


### 3.2 生成任意大小的文件

❏ bs指定了以字节为单位的块大小（block size）；

dev/zero是一个特殊的字符设备，它会返回0值字节（\0）。

使用dd命令也能够用来测量内存操作的速度，这可以通过向/dev/null传输大量数据并观察命令输出来实现（例如，在前一个例子中显示出的1048576 bytes (1.0 MB) copied, 0.00767266 s, 137 MB/s）。

### 3.5 文件权限、所有权与粘滞位

接下来的9个字符可以划分成三组，每组3个字符（--- --- ---）。第一组的3个字符对应用户权限（所有者），第二组对应用户组权限，第三组对应其他用户权限

❏ 其他用户（权限序列：------rwx）：最后3个字符是其他用户权限。如果设置了相应的权限，其他用户也可以访问特定的文件或目录。作为一种规则，通常将这组权限设置为---。

❏ u：指定用户权限。
❏ g：指定用户组权限。
❏ o：指定其他用户权限

1．更改所有权
可以使用chown命令更改文件或目录的所有权：
￼
        $ chown user:group filename
例

### 3.6 将文件设置为不可修改

（1）使用chatter将文件设置为不可修改：
￼
            # chattr+i file

### 3.14 只列出目录的各种方法

可以依据下列方法列出当前路径下的目录。
（1）使用ls -d：
￼
            $ ls -d ＊/
（2）使用grep结合ls -F：
￼
            $ ls -F | grep "/$

### 4.3 使用grep在文件中搜索文本

（5）grep命令默认使用基础正则表达式。这是先前描述的正则表达式的一个子集。选项-E可以使grep使用扩展正则表达式。也可以使用默认启用扩展正则表达式的egrep命令：

选项-v能够反转（invert）匹配结果。

如果需要在多级目录中对文本进行递归搜索，可以使用下列命令：[插图]

选项-e可以指定多个匹配模式：[插图]

使用--include选项在目录中递归搜索所有的 .c和 .cpp文件：[插图]

### 4.4 使用cut按列切分文件

们也可以用 --complement选项显示出没有被-f指定的那些字段。下面的命令会打印出除第3列之外的所有列：

选项--output-delimiter可以指定输出分隔符。在显示多组数据时，该选项尤为有用：

### 4.5 使用sed替换文本

/#g标记可以使sed替换第N次出现的匹配：

．已匹配字符串标记（&）

在sed中，我们可以用&指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹配的内容：

这个例子中，正则表达式\w\+匹配每一个单词，然后我们用[&]替换它。&对应于之前所匹配到的单词。

子串匹配标记（\1）&指代匹配给定模式的字符串。我们还可以使用\#来指代出现在括号中的部分正则表达式（注：子模式）所匹配到的内容：

可以利用管道组合多个sed命令，多个模式之间可以用分号分隔，或是使用选项-e PATTERN：[插图]它等同于[插图]或者[插图]

sed表达式通常用单引号来引用。不过也可以使用双引号。shell会在调用sed前先扩展双引号中的内容。如果想在sed表达式中使用变量，双引号就能派上用场了。

### 4.6 使用awk进行高级文本处理

❏ NR：表示记录编号，当awk将行作为记录时，该变量相当于当前行号。❏ NF：表示字段数量，在处理当前记录时，相当于字段数量。默认的字段分隔符是空格。

借助选项-v，我们可以将外部值（并非来自stdin）传递给awk：

还有另一种灵活的方法可以将多个外部变量传递给awk。例如：[插图]

[插图]

在上面的方法中，变量以键-值对的形式给出，使用空格分隔（v1=$var1 v2=$var2），作为awk的命令行参数紧随在BEGIN、{}和END语句块之后。

awk默认读取文件中的所有行。如果只想读取某一行，可以使用getline函数。它可以用于在BEGIN语句块中读取文件的头部信息，然后在主语句块中处理余下的实际数据。

6．从awk中读取命令输出awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：[插图]

7．awk的关联数组除了数字和字符串类型的变量，awk还支持关联数组。关联数组是一种使用字符串作为索引的数组。你可以通过中括号中索引的形式来分辨出关联数组：

awk有很多内建的字符串处理函数。❏ length(string)：返回字符串string的长度。❏ index(string, search_string)：返回search_string在字符串string中出现的位置。❏ split(string, array, delimiter)：以delimiter作为分隔符，分割字符串string，将生成的字符串存入数组array。

### 4.9 按列合并多个文件

cat命令可以按行依次合并两个文件。但有时候我们需要按列合并多个文件，也就是将每一个文件的内容作为单独的一列。

### 4.15 对目录中的所有文件进行文本替换

使用-print0打印出以\0作为分隔符的文件列表（这可以避免文件名中的空格所带来的麻烦）。

### 5.1 简介

我们可以用脚本满足大量的Web自动化需求。

### 5.2 Web页面下载

你可以通过选项-O指定输出文件名。

也可以用选项-o指定一个日志文件，这样日志信息就不会被打印到stdout了。

由于不稳定的互联网连接，下载有可能被迫中断。选项-t可以指定在放弃下载之前尝试多少次：[插图][插图]将-t选项的值设为0会强制wget不断地进行重试：[插图]

2．断点续传如果wget在下载完成之前被中断，可以利用选项-c从断点开始继续下载：[插图]

### 5.4 cURL入门

和wget不同，并非所有的Linux发行版中都安装了cURL，你得使用包管理器自行安装。cURL默认会将下载文件输出到stdout，将进度信息输出到stderr。如果不想显示进度信息，可以使用--silent选项。

### 5.7 图片爬取器及下载工具

while循环会一直处理完所有的参数。shift用来向左移动参数，这样$2的值就会被赋给 $1，$3的值被赋给 $2，往后以此类推。因此通过 $1就可以求值所有的参数。

### 6.5 使用git创建与合并分支

如果合并完分支之后不再需要该分支，可以使用选项-d进行删除：[插图]

### 6.7 推送分支

git pull命令会获取并合并变更到工作代码。

### 6.8 检查git仓库状态

如果用于提交的身份信息不对，可以使用下面的命令修正：[插图]

### 6.11 快照标签

git支持轻量标签（仅为快照打标签）以及注解标签。git标签仅在本地范围内有效。git push默认不会推送标签。要想把标签发送到origin仓库，必须加上选项--tags：[插图]

### 6.12 提交信息规范

 不要写成Fix bug，甚至是Fix bugzilla bug #1234，应该写作Remove silly messages that appear each April 1。随后的段落可以描述具体的细节，这对于希望跟随你工作成果的用户非常重要。代码中用到的全局变量、副作用等都要在此提及。如果其中还描述了你解决的问题，记得加上bug报告或特性请求的URL。

### 8.1 简介

TCP/IP网络的运作过程就是在节点之间传递分组（packet）[插图]。每一个分组中都包含了目标的IP地址以及处理分组中数据的应用程序端口号。当节点接收到分组时，它会查看自己是否就是该分组的目的地。如果是，节点会再检查端口号并调用相应的应用程序来处理分组数据。如果不是，节点则根据已知的网络配置，将分组发送到离最终目的地更近的下一个节点。

### 8.2 网络设置

用tr -s 'n'压缩多个换行符以生成接口名称列表。

操作系统维护着一个叫作路由表的表格，它包含了分组如何转发的信息。route命令可以显示路由表：

-n指定以数字形式显示地址。默认情况下，route命令会将IP地址映射为名字。

如果系统不知道如何分组到目的地的路由，它会将其发送到默认网关。默认网关可以连接到Internet或部门内部的路由器。route add命令可以添加默认网关：

### 8.3 ping！

ping命令如果执行顺利，会返回退出状态0；否则，返回非0。执行顺利意味着目标主机可达，执行失败意味着目标主机不可达。

### 8.10 实现SSH的无密码自动登录

SSH采用了非对称加密技术，认证密钥包含两部分：一个公钥和一个私钥。ssh-keygen命令可以创建这一对认证密钥。要想实现自动化认证，公钥必须放置在服务器中（将其加入文件~/.ssh/authorized_keys），与公钥对应的私钥应该放入用户所在客户机的~/.ssh目录中。另一些与SSH相关的配置（例如，authorized_keys文件的路径与名称）可以通过修改文件 /etc/ssh/sshd_config来完成。

ssh-keygen程序会生成两个文件：~/.ssh/id_rsa.pub和~/.ssh/id_rsa。其中前者是公钥，后者是私钥。公钥必须添加到想要自动登入的远程服务器的~/.ssh/authorized_keys文件中。


### 8.11 使用SSH实现端口转发

端口转发可以将来自某台主机的IP连接重定向到另一台主机。如果你使用Linux/Unix系统作为防火墙，你可以将端口1234上的连接重定向到其他内部地址（如192.168.1.10:22），从而为外部提供一个可以抵达内部主机的ssh隧道。
8.1

你可以将本地主机端口上的流量转发到另一台主机上，也可以将远程主机端口上的流量转发到其他主机。按照下面的方法，一旦端口转发设置完毕，你会得到一个shell提示符。在进行端口转发的过程中，这个shell必须保持打开状态，什么时候想停止转发，只需要退出该shell就可以了

（2）下列命令会将远程主机端口8000上的流量转发到www.kernel.org的端口80上：
￼
            ssh -L 8000:www.kernel.org:80 user@REMOTE_MACHINE
将上述命令中的REMOTE_MACHINE替换成远程主机的主机名或IP地址，将user替换成使用SSH进行访问的用户名。

如果你只是想设置端口转发，而不希望在端口转发时有一个总是保持打开状态的shell，那么可以像下面这样使用ssh：
￼
        ssh -fL8000:www.kernel.org:80 user@localhost -N
-f指定ssh在执行命令前转入后台运行，-N告诉ssh无需执行命令，只进行端口转发。

### 8.12 在本地挂载点上挂载远程驱动器

SSH是网络中常用的文件传输协议。sshfs利用SSH实现了在本地挂载点上挂载远程文件系统。

### 8.14 测量网络带宽

iperf必须安装在链路的两端（服务器端和客户端）。安装好之后，启动服务器端：
￼
        $ iperf -s
然后运行客户端，生成吞吐量统计：
￼
        $ iperf -c 192.168.1.36￼
        ---

### 8.15 创建套接字

netcat或nc命令都可以创建用于在TCP/IP网络上传输数据的套接字。我们需要两个套接字：一个负责侦听连接，一个负责发起连接。

1．在网络上快速复制文件
我们可以利用netcat和shell重定向在网络上复制文件。下面的命令能够向侦听主机发送文件。

### 8.16 搭建网桥

Linux系统可以作为网桥使用。
网桥是一种低层连接，它并不是基于IP地址，而是使用MAC地址传递分组。其自身需要的资源更少，效率也更高。
你可以使用网桥连接不可路由的私有网络（private, non-routed network）中的主机，或是连接公司中独立的子网，亦或是将生产子网与运送子网互联，实现产品信息共享。

如果以太网适配器加入了网桥，该适配器就不能再配置IP地址。需要配置IP地址的是网桥。


在网桥生效之前，我们需要将其加入路由表。
对于网络10.0.0.0/24中的主机，添加到网络192.168.1.0/16路由表项：

网络192.168.1.0/16中的主机需要知道如何找到网络10.0.0.0/24。如果eth0配置了IP地址192.168.1.2，则使用route命令：
￼
        route add -net 10.0.0.0/24 gw 192.168.1.2

### 8.17 Internet连接共享

大多数防火墙/路由器都能够让你的家庭或办公室设备共享Internet连接。这种技术叫作网络地址转换（Network Address Translation，NAT）

有3组不能被路由的IP地址￼。这意味着能接入Internet的网卡都不能使用这些地址。只有内部网络可以使用。这3组地址分别是10.x.x.x、192.168.x.x以及172.16.x. x-> 172.32.x.x。在这则攻略中，我们从10.x.x.x地址空间中选用了一部分作为内部网络地址。

默认情况下，Linux系统只接收或生成分组，并不会重传（echo）分组。这种行为是由in/proc/sys/net/ipv4/ip_forward的值所控制的。
将该值设置为1会使Linux转发所有无法识别的分组。

### 8.18 使用iptables架设简易防火墙

防火墙是一种网络服务，它可以过滤、阻止不需要的网络流量，允许正常的网络流量通过。Linux中的标准防火墙工具是iptables，它目前已经被集成到了内核中。

所谓链就是若干条规则的集合，在早先的例子中我们使用的是OUTPUT链，它可以控制所有的出站流量（outgoing traffic），而在上一个例子中，用到的是INPUT链，它能够控制所有的入站流量（incoming traffic）。


在第二个例子中，-p指定规则仅适用于TCP，-dport指定了对应的端口。这样我们就可以只阻止所有出站的FTP流量了

### 8.19 创建虚拟私有网络

虚拟私有网络（Virtual Private Network，VPN）是建立在公网之上的加密通道。加密能够保证个人信息的私密性。VPN可用于连接远程办公点、散布多处的生产制造站点以及远程工作人员。

确定隧道设备（/dev/net/tun）存在。在服务器和客户端上都要测试。在如今的Linux系统中，隧道应该是不会少的：
￼
        ls /dev/net/tun

### 9.2 监视磁盘使用情况

du（disk usage）和df（disk free）命令可以报告磁盘使用情况。这两个工具能够统计出文件和目录的磁盘占用情况以及可用的磁盘空间


        $ du -a DIRECTORY
选项-a递归地输出指定目录或多个目录中所有文件的统计结果。

另一个选项-s（summarize，总计）则只输出总计数据。它可以配合-h打印出人们易读的格式：

3．使用特定的单位打印文件
选项-b、-k和-m可以强制du使用特定的单位打印磁盘使用情况。注意，这些选项不能与-h一同使用：

4．从磁盘使用统计中排除部分文件
选项--exclude和--exclude-from可以让du在磁盘使用统计中排除部分文件。
（1）选项--exclude可以与通配符或单个文件名配合使用：

### 9.3 计算命令执行时间

1）time命令可以测量出应用程序的执行时间：

time命令的可执行二进制文件位于/usr/bin/time，另外还有一个bash shell的内建命令也叫作time。当执行time时，默认调用的是shell的内建命令。内建的time命令选项有限。如果需要使用额外的功能，应该使用可执行文件time的绝对路径（/usr/bin/time）。

❏ Real：指的是壁钟时间（wall clock time），也就是命令从开始执行到结束的时间。这段时间包括其他进程所占用的时间片（time slice）以及进程被阻塞时所消耗的时间（例如，为等待I/O操作完成所用的时间）。

❏ User：是指进程花费在用户模式（内核模式之外）中的CPU时间。这是执行进程所花费的时间。执行其他进程以及花费在阻塞状态中的时间并没有计算在内。

❏ Sys：是指进程花费在内核中的CPU时间。它代表在内核中执行系统调用所使用的时间，这和库代码（library code）不同，后者仍旧运行在用户空间。与“user时间”类似，这也是真正由进程使用的CPU时间。参考表9-1，其中简要描述了内核模式（也称为监督模式）和系统调用机制。

### 9.4 收集登录用户、启动日志及启动故障的相关信息

过去的1/5/15分钟内的系统平均负载。接

uptime命令输出中的平均负载（load average）是表明系统负载量的一个参数。

sed使用单词up与第二个逗号（单词users之前）之间的内容替换掉整行文本。

### 9.6 使用watch监视命令输出

我们可以用-n SECONDS指定更新输出的时间间隔。例如：

watch命令能够着重标记出连续输出之间的差异。注意，这种标记只会持续到下次更新。着重标记watch输出中的差异选项-d能够着重标记出连续的命令输出之间的差异：

### 9.8 使用syslog记录日志

logger命令可以通过syslogd记录日志。

向日志文件/var/log/messages中写入信息：[插图]

/var/log/messages是一个通用日志文件。如果使用logger命令，它默认将日志写入/var/log/messages中。

### 10.4 杀死进程以及发送和响应信号

作为一种进程间通信机制，信号可以中断进程运行并强迫进程执行某些操作。这些操作就包括以受控的方式终止进程或立刻终止进程。

信号能够中断正在运行的程序。当进程接收到一个信号时，它会执行对应的信号处理程序（signal handler）作为响应。编译型的应用程序使用系统调用kill生成信号。在命令行（或是shell脚本）中是通过kill命令来实现的。trap命令可以在脚本中用来处理所接收的信号。
每个信号都有对应的名字以及整数值。SIGKILL (9)信号会立即终止进程。Ctrl+C会发送信号中断任务￼，Ctrl+Z会发送信号将任务置入后台。

❏ SIGHUP 1：对控制进程或终端的结束进行挂起检测（hangup detection）。
❏ SIGINT 2：当按下Ctrl+C时发送该信号。
❏ SIGKILL 9：用于强行杀死进程。
❏ SIGTERM 15：默认用于终止进程。
❏ SIGTSTP 20：当按下Ctrl+Z时发送该信号。
（4）我们经常需要强行杀死进程，这样做的时候要小心。这种做法立刻生效，根本没有机会保存数据或执行通常的清理工作。应该先尝试使用SIGTERM，将SIGKILL留作最后一招：


设计良好的程序在接收到SIGTERM信号时会保存好数据，然后放心地结束（shut down cleanly）。trap命令在脚本中用来为信号分配信号处理程序。一旦使用trap将某个函数分配给一个信号，那么当脚本运行收到该信号时，就会执行相应的函数。
命令语法如下：
￼
        trap 'signal_handler_function_name' SIGNAL_LIST

### 10.5 向用户终端发送消息

write和wall命令只能作用在单个系统。talk命令可以连接网络上的用户。

### 10.6 /proc文件系统

/proc是一种存在于内存中的伪文件系统（pseudo filesystem），它的引入是为了可以从用户空间中读取Linux内核的内部数据结构。其中大多数伪文件都是只读的，不过有一些，比如/proc/sys/net/ipv4/forward（在第8章中讲过），可用于微调系统行为。
实战演练

系统中每一个运行的进程在/proc中都有一个对应的目录，目录名和进程ID相同。


### 10.8 使用cron进行调度

很多命令需要正确地设置环境变量才能够运行。cron命令会将SHELL变量设置为/bin/sh，还会根据/etc/passwd设置LOGNAME和HOME。

### 10.9 数据库的形式及用法

Linux支持很多不同形式的数据库，从简单的文本文件（/etc/passwd）、低层的B树数据库（Berkey DB和bdb）、轻量级的SQL（sqlite）到全功能的关系型数据库（如Postgres、Oracle和MySQL）。选择数据库形式的一个经验法则就是选择能够满足你工作需要的最简单的那种数据库。对于字段已知且固定的小型数据库而言，文本文件加上grep就足够了。

如果数据表的读取操作远多于写操作，那么SQLite是一个不错的选择。这种数据库引擎不需要服务器，因此便于移植，易于嵌入到其他应用中（例如Firefox）。

### 10.15 集中管理多个终端

GNU screen工具可以在单个终端会话中创建多个虚拟屏幕（virtual screen）。在一个虚拟屏幕中启动的任务可以在该屏幕隐藏的情况下继续运行。

### 11.2 使用tcpdump跟踪分组

❏ Flags：分组所具有的标志如下。
S代表SYN（发起连接）。
F代表FIN（终止连接）。
P代表PUSH（推送数据）。
R代表RST（重置连接）。

❏ seq：指的是分组的序列号。这个序列号会回显（echoed）在ACK中来确认接收到的分组。
❏ ack：作用是确认已接收到某个分组。这个值是上一个分组的序列号。￼

### 11.3 使用ngrep查找分组

ngrep是grep和tcpdump的综合体。它能够监视网络端口并显示匹配特定模式的分组。你必须以root身份运行ngrep。

### 11.4 使用ip跟踪网络路由

❏ proto：该路由所使用的协议。使用内核协议的路由是内核所设置的，管理员负责设置静态路由。❏ scope：地址的有效范围。如果scope取值为link，则表明地址仅对该设备有效。

ipneighbor命令可以输出IP地址、设备与硬件MAC地址之间的已知关系。通过该命令可以了解到这种关系是最近重新建立的还是已经变得陈旧（stale）了：

3．跟踪路由第8章中讲过的命令traceroute可以跟踪分组从当前主机到目的地所经历的完整路径。route get可以输出当前主机的下一跳地址：

上面的输出显示到达虚拟机的路由需要经过地址为172.16.183.1的接口vmnet8。发往此处的分组如果大于1500字节，需要进行分片，经过64跳之后会被丢弃：

### 12.1 简介

系统调优的第一步是理解系统需求以及是否能够满足这些需求。不同类型的应用程序有各自不同的关键指标。你需要回答的问题如下。
❏ 系统的关键资源是不是CPU？从事工程模拟的系统对于CPU频率的需求要强于其他资源。
❏ 网络带宽对于系统是否重要？文件服务器不用做什么运算操作，但却能榨干网络带宽。
❏ 磁盘访问速度对于系统是否重要？相较于计算引擎，文件服务器或数据库服务器对于磁盘的要求更高。

### 12.2 识别服务

systemd如今已经取代了SysVinit系统。upstart是由Ubuntu开发并采用的，但是在14.04版中，已经改成了systemd。考虑到大多数发行版使用的都是systemd，因此本章将重点放在了该系统。

1．基于systemd的系统
systemctl命令可以启用或禁止服务。
启用服务：
￼
        systemctl enable SERVICENAME
禁止服务：
￼
        systemctl disable SERVICENAME

2．基于RedHat的系统
对于采用了SysV方式初始化脚本（/etc/rc#.d）的系统来说，可以将chkconfig作为前端工具使用。选项-del用于禁止服务，-add用于启用服务。注意，启用服务时必须有相应的初始化文件。
命令语法如下：
￼
        # chkconfig -del SERVICENAME￼

### 12.3 使用ss收集套接字数据

1．显示tcp套接字状态
每一次HTTP访问、每一个SSH会话都会打开一个tcp套接字连接。选项-t可以输出TCP连接的状态：

### 12.4 使用dstat收集系统I/O使用情况

如果不使用任何选项，dstat会每隔一秒显示出CPU占用、磁盘I/O、网络I/O、分页、中断以及上下文切换信息。

### 12.6 使用sysctl调优Linux内核

sysctl命令适用于所有的Linux系统。你必须以root的身份才能修改内核参数。
该命令可以立刻改变参数值，但除非将参数定义在/etc/sysctl.conf中，否则重启之后，修改过的值又会恢复原样。
最好是在修改sysctl.conf之前先进行测试。如果将错误的值写入/etc/sysctl.conf，会导致系统无法启动。

### 12.7 使用配置文件调优Linux系统

etc/fstab文件定义了磁盘如何挂载以及所支持的选项。

### 13.3 使用Docker

docker search命令会返回匹配指定关键字的Docker容器列表：

❏ -t：分配一个伪终端（默认不分配）。❏ i：在处于未附着状态时仍旧打开交互式会话。❏ d：以非附着方式启动容器（在后台运行）。❏ --name：为容器实例分配名称。

docker attach命令可以将输出附着在正在运行的容器中的tty会话上。你需要在容器中具备root权限。输入^P^Q，退出所附着的容器。

### 13.4 在Linux中使用虚拟机

KVM和VirtualBox是Linux中最流行的两个虚拟机引擎。KVM的性能要更好，但是要求CPU支持虚拟化（Intel VT-x）。如今大多数Intel和AMD的CPU都支持该特性。VirtualBox的优势在于跨平台：Windows和Mac OS X下也可以使用，便于将虚拟机挪到其他平台。VirtualBox不要求VT-x支持，因此既适合于遗留系统，也适合于现代系统。