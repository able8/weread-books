## Istio入门与实战
> 毛广献编著

### 前言

微服务依赖持续集成、服务注册、服务发现、负载均衡、健康检测、配置管理、服务路由、服务容错、日志收集、指标收集、调用链追踪等，而构建这一套基础设施的成本巨大。因此，微服务相关的框架逐渐露出水面，比如Java语言的Spring Cloud框架。虽然这些微服务框架为我们提供了很多便利，但由于这些框架是与编程语言绑定的，使得我们应用的技术栈受到了限制。即使后来有其他的微服务框架也支持多编程语言的技术栈，但由于这些微服务框架代码对服务代码入侵严重，给后续服务框架的bug修复和版本升级带来了一定的困难。

2018年是服务网格快速发展的一年，Istio发布的1.0.0版本标志着Istio已经成熟到可以接受生产流量的考验。2019年服务网格将会持续保持热度，作为一名技术人员，现在是时候了解一下服务网格技术了。而在所有的开源服务网格实现中，最成熟的肯定是Istio。因此，要学习和了解服务网格，首先应该学习使用Istio。

第9章介绍服务故障注入的相关功能，提前给服务注入故障，可以测试服务在故障中的稳定性，提前发现问题并修复问题。

### 第1章 服务网格与Istio

由于所有服务都依赖于底层的服务框架代码库，当框架代码需要更新时，业务开发人员可能并不能立即更新服务框架，导致服务框架整体升级困难。后来Netflix开源了自己的微服务间通信组件，之后被Spring Cloud集成到了一起，组成了Java语言的通用微服务技术栈，而其他编程语言可能并没有如此强大功能的开源组件，只能继续饱受微服务间通信的各种痛。

服务间通信出现的问题，有人开始思考：能不能把服务间的复杂通信分层并下沉到基础设施层，让应用无感知呢？答案是肯定的。于是服务网格开始渐渐浮出水面，越来越多的人看到了服务网格的价值，尝试把服务网格应用于微服务实践中。

服务网格是一个专注于处理服务间通信的基础设施层，它负责在现代云原生应用组成的复杂服务拓扑中可靠地传递请求。

在实践中，服务网格通常是一组随着应用代码部署的轻量级网络代理，而应用不用感知它的存在。

把服务间调用可能出现的超时、重试、监控、追踪等工作下沉到服务网格层处理。

微服务架构流行以后，服务的数量在不断增长。在不使用服务网格的情况下，每个服务都需要自己管理复杂的服务间网络通信，开发人员不得不使用各种库和框架来更好地处理服务间的复杂网络通信问题，这导致代码中包含很多与业务逻辑完全不相关的代码，稍有不慎就有可能给业务带来额外的复杂度和bug。
当服务规模逐渐变大，复杂度增加，服务间的通信也变得越来越难理解和管理，这就要求服务治理包含很多功能，例如：服务发现、负载均衡、故障转移、服务度量指标收集和监控等。

在使用服务网格时，我们甚至完全不需要改动现有的服务代码，服务开发完全可以使用不同的语言和技术栈，框架和库再也不是限制我们的绊脚石。

在云原生大行其道的今天，容器和Kubernetes增强了应用的伸缩能力，开发者可以基于此快速地创造出依赖关系复杂的应用；而使用服务网格，开发者不用关心应用的服务管理，只需要专注于业务逻辑的开发，这将赋予开发者更多的创造性。

Istio出自希腊语，表示“航行”的意思，官方图标为一个白色的小帆船。使用Istio可以让服务间的通信更简单、更安全，控制服务更容易，观测服务更方便。
Istio是由Google、IBM、Lyft公司主导开发的影响力最大的开源服务网格实现，使用Go语言编码，由于Go语言的性能较好，使得Istio性能不错。这个项目由众多代码贡献者完成。

Istio可以让你轻松部署一个服务网格，而不需要在服务代码中做任何改变。只需要在你的环境中部署一个特殊的代理用来拦截所有微服务间的网络通信，就可以通过控制平面配置和管理Istio。Istio的功能特性如下：

❏HTTP、g RPC、Web Socket、TCP流量的自动负载均衡。
❏细粒度的流量路由控制，包含丰富的路由控制、重试、故障转移和故障注入。
❏可插拔的访问控制策略层，支持ACL、请求速率限制和请求配额。
❏集群内度量指标，日志和调用链的自动收集，管理集群的入口、出口流量。

Istio使用Sidecar代理来捕获流量，不需要对已部署的应用程序代码进行任何改动。在Kubernetes中，代理被注入Pod中，通过编写iptables规则来捕获流量。注入Sidecar代理到Pod中并且修改路由规则后，Istio就能够拦截所有流量。这个原则也适用于性能，所有组件和API在设计时都必须考虑性能和规模。

❏控制平面负责管理和配置代理来路由流量，另外，控制平面通过配置Mixer来实施策略与遥测数据收集。

Istio的数据平面主要负责流量转发、策略实施与遥测数据上报；Istio的控制平面主要负责接收用户配置生成路由规则、分发路由规则到代理、分发策略与遥测数据收集。

Envoy是使用C++语言开发的高性能代理，它能拦截服务网络中所有服务的入口和出口流量。Istio利用了众多Envoy内置的功能特性，例如：
❏动态服务发现
❏负载均衡
❏TLS终止
❏HTTP/2和g RPC代理
❏熔断器
❏健康检查
❏基于百分比流量分隔的灰度发布
❏故障注入
❏丰富的度量指标

Istio是一个生产已经可用的开源服务网格平台实现，它提供了丰富的功能。虽然Istio是与平台无关的，但是由于许多功能是基于Kubernetes实现的，目前还是建议在Kubernetes上使用Istio。

### 第2章 实验说明

服务之间通过HTTP协议通信

❏前端调用Python实现的API接口。
❏Python服务调用后端Node实现的服务和Lua实现的服务。
❏Node服务调用Go实现的服务。

service-js服务分别使用Vue和React各实现一套Web界面，主要用于服务路由中的A/B测试，可以让不同的终端用户看到不同的前端Web界面。service-js服务主要负责根据service-python服务的响应数据，使用ECharts图表库在浏览器上展示出后端服务的具体调用关系和各个服务的调用耗时，具体的代码在实验源码根目录的service/js目录下。


    FROM node:8-alpine￼
    LABEL maintainer="will835559313@163.com"￼
    COPY . /app￼
    WORKDIR /app￼
    RUN npm i && npm run build \￼
        && rm -rf ./node_modules \￼
        && npm install -g serve￼
    EXPOSE 80￼
    CMD ["serve", "-s", "build", "-p", "80"]

service-lua服务使用Open Resty的不同版本用Lua语言分别实现了两个版本的服务。

### 第4章 创建Kubernetes集群

#配置开机自动导入IPVS相关内核模块￼
    $ sudo tee /etc/modules-load.d/k8s-ipvs.conf <<-'EOF'￼
    ip_vs￼
    ip_vs_rr￼
    ip_vs_wrr￼
    ip_vs_sh￼
    nf_conntrack_ipv4￼
    EOF￼
￼
    #查看IPVS相关内核模块配置￼
    $ sudo cat /etc/modules-load.d/k8s-ipvs.conf￼
    ip_vs￼
    ip_vs_rr￼
    ip_vs_wrr￼
    ip_vs_sh￼
    nf_conntrack_ipv4

### 第5章 Istio部署与常用命令

查看Istio组件状态，当组件全部处于Running或者Completed时再进行之后的实验，由于需要拉取较多镜像，如果网速较慢，可能需要等待很长一段时间。如果没有跟着之前的步骤配置镜像进行加速拉取，会更缓慢，强烈建议配置镜像加速

使用官方示例的方式部署Istio将部署较多的组件，占用资源多但是功能全，会包含Prometheus、Grafana、Jaeger、Service Graph等组件。

修改镜像使用国内镜像，加速部署，执行以下命令修改镜像：

如果端口命名不符合上述规则或者没有使用命名端口，该端口上的流量将会被视为TCP流量，除非Service里指明了协议是UDP。

app标签用于分布式调用链追踪，app和version标签也会用于Istio的度量指标收集。

Gateway用于配置服务网格流量的边界负载均衡器，负责接收进入服务网格和流出服务网格的HTTP/TCP连接。用

mTLS认证策略包括：Mesh Policy、Policy，主要用于服务间的流量加密和认证。

在指定的Pod中获取Envoy实例启动时的配置信息，使用形式如下：

获取Pilot到网格中每个Envoy的配置同步状态

annotations:￼
              sidecar.istio.io/inject: "false"

Istio的自动注入功能是namespace级别的，当需要在指定namespace开启自动注入功能时，只需要给该namespace打上标签名：istio-injection=enabled即可。当删除该标签时，自动注入功能就会自动关闭，但是对于已经被注入的Pod是不会自动取消注入的，这只对新部署的Pod有效。

### 第7章 让服务流量控制更简单

流量路由管理是Istio最重要的功能。我们可以通过路由规则轻松地把请求流量导入不同的服务版本中，可以很容易地实现A/B测试、灰度发布这类需要复杂技术才能实现的功能。

Envoy代理会根据路由规则把请求转发到相应服务实例的Pod上，默认情况下Enovy代理会把流量以轮询的方式转到后端服务实例的Pod上。通过设置路由规则，我们可以把对服务的请求流量按百分比转发到不同的版本上。如

通过上面的配置，我们把service-node服务的v2版本权重设置为80，而把v1版本的权重设置为20。这样设置权重比值之后，对service-node服务的请求，会有80%!的(MISSING)概率被路由到v2版本，只有20%!的(MISSING)概率被路由到v1版本。

使用Istio提供的流量镜像功能，实时复制线上真实的请求流量到我们的新版本服务上，验证新版本的服务。下面以service-go服务为例：
￼

服务网格中的服务无法访问外部的服务。要想访问外部服务，可以创建Service Entry对象，把外部服务注册到服务网格的注册中心，这样，网格中的服务就可以访问外部服务了

一般情况下使用DNS方式，设置为STATIC时需要在endpoints中配置IP地址，当应用程序自己负责解析时，使用NONE方式。

灰度发布又叫金丝雀发布，通过Istio提供的服务路由功能可以轻松实现灰度发布。当我们的服务需要上线新版本时，可以先只把部分流量引入到新版本，等到确认新版本没有问题时，再把全部流量切换到新版本上。通过调节服务版本路由的权重，就可以达到上述目的。当然，为了不浪费资源，对服务的新版本我们只需要部署很少的实例，然后确认服务没有问题后，再增加新版本的服务实例，减少旧版本的服务实例。

在真实的生产环境中，可能需要根据用户信息、应用版本等信息进行灰度发布，比如我们可能只想在安卓手机用户中挑选部分用户进行灰度测试，这时候我们就需要把灰度发布和A/B测试进行结合，来达到目的。路由配置示例

       - uri:￼
        56            prefix: /env￼
        57         headers:￼
        58            user-agent:￼
        59              regex: ".＊?(Firefox).＊?"￼
        60       route:￼
        61       - destination:￼
￼
        62            host: service-python￼
        63            subset: v1￼
        64         weight: 70￼
        65       - destination:￼
        66            host: service-python￼
        67            subset: v2￼
        68         weight: 30￼

### 第8章 让服务更具弹性

如何借助Istio提供的功能，让我们的服务更具弹性。主要包括配置服务的负载均衡策略、连接池、健康检测、熔断、超时、重试、限流等。通过上述这些配置，可以让我们服务在遇到故障时更具弹性。

❏连接池。当服务调用上游服务时，可以提前创建好到上游服务的连接，当请求到来时，通过已经创建好的连接直接发送请求给上游服务，减少连接的创建时间，从而降低请求的整体耗时。我们把这些提前创建好的连接集合称为连接池。

限流功能是当请求数过多时，直接丢掉过多的流量，防止服务被压垮，保证服务稳定。

❏重试。网络出现抖动，或者被调用的服务出现瞬时故障，这些问题都是偶发瞬时的，只需要再重新调用一次后端服务，可能请求就会成功。这种场景下就需要服务的重试功能，防止由于被调用方的服务偶发瞬时故障，导致出现服务调用不可用的情况，从而影响应用的整体稳定性与可用性。

### 第10章 让服务通信更安全可控

Istio在请求级别使用JSON Web Token（JWT）来验证并简化开发者对Auth0、Firebase、Google Auth以及自定义认证的对接工作。

### 第11章 让服务更易观测与监控

章介绍服务的观测与监控，介绍如何在Istio中收集服务的指标数据、日志数据，如何借助调用链追踪功能，更方便地排查服务调用问题。Istio默认情况下已经收集了许多服务指标数据，并使用Grafana创建了许多图表来展示服务网格的整体运行状态，利用收集到的日志数据和服务指标数据，Istio也生成了服务的调用依赖树，让我们对服务依赖关系一目了然。

为了获取服务运行时的行为，可观测性很有必要。为了让服务更易观测，我们需要收集服务的日志（logging），统计服务的运行指标数据（metrics），记录服务的调用链追踪（tracing）。这三者都有互有重叠的功能部分，关系如图11-1所示。

❏仪表盘（Gauge）：可以增加也可以减少，仪表盘只代表当前的数据状态。例如：统计CPU使用率。

❏概要（Summary）：与柱状图类似，计算一段时间内指标对象总数以及指标的总和，提供百分位的功能。例如：请求响应时间的99百分位。

❏Span：是服务调用信息的存储单位，每一次服务调用就会生成一个Span用于存储本次服务调用的信息。

Istio提供统一的“服务指标”收集功能，可以通过简单的配置就能收集服务指标，比如，收集服务的响应时间、请求次数、响应流量等。Istio使用Prometheus获取指标数据。

Istio默认情况下使用Prometheus来收集存储指标数据，并使用Grafana来可视化指标数据。当我们安装好Istio之后，Istio已经自动收集了常用的指标数据并创建了常用的仪表板来可视化指标数据。当Istio默认配置的图无法满足需求时，我们还可以自定义相关的指标数据图。

### 第12章 Istio维护

介绍Istio维护，包括如何可视化管理Istio，如何在不中断业务的情况下升级Istio，如何定制部署Istio，当出现故障时如何排查问题。本章还将展示服务调用从请求发出到收到响应的整个流程，这对深入学习Istio是很有帮助的。

Istio服务网格仪表板（Dashboard）可以用来更好地观测Istio的运行状态以及服务网格内服务的流量情况，甚至可以直接在Web上修改Istio的路由等配置。在目前的Istio服务网格仪表板中，Kiali功能最多，本节介绍如何安装Kiali并使用其功能。

❏EDS：端点发现服务，可以理解为单个服务实例发现。

❏SYNCED：表示Envoy代理已经确认收到了Pilot上一次发送的配置。
❏SYNCED（100%!）(MISSING)：表示Pilot已经将集群中全部的服务实例信息发送给了Envoy代理。
❏NOT SENT：表示Pilot没有发送任何配置给Envoy代理，通常是由于没有什么可发送的。
❏STALE：表示Pilot已经发送了更新配置给Envoy代理，但是还没有收到Envoy代理的确认，通常可能是由于Envoy代理和Pilot之前的网络连接出现了问题或者机器性能有问题。

本节展示一个请求从一个服务实例调用另一个服务的过程，分析一下请求是怎么从调用方到服务提供方的。

当service-python服务要访问service-lua服务时，需要先通过kube-dns找到要访问服务的IP地址，也就是service-lua服务的Cluster IP，执行如下的命令可以看到DNS解析得到的service-lua服务的IP地址：

当service-python服务拿到service-lua服务的IP地址后，发送请求给服务对应的IP和端口。由于Envoy代理会拦截所有流量，这个请求会最先到达service-python服务实例的Envoy代理上，查看Envoy代理监听了哪些地址和端口：

### 第13章 杂项

当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求另外一个资源时，资源会发起一个跨域HTTP请求。

出于安全原因，浏览器限制跨域HTTP请求。可以通过配置CORS头来解除这种限制。更深入的内容可以参考如下两篇文章：

Envoy Filter用于自定义Envoy代理的配置，使用时必须小心，如果出现错误，可能导致整个服务网格出现问题。

第6～7行的定义表明此规则只对包含app标签值为httpbin的pod生效。

请求后端服务时添加字段名为X-Foo、值为bar的请求头，在得到后端服务实例的响应后，添加X-Response-Body-Size响应头，并且值为服务响应内容的字节大小。

由于Istio使用Envoy作为服务网格的代理，因此我们也可以直接使用Envoy作为我们的代理服务器，代理后端的Ingressgateway

虽然我们使用了Envoy作为前端代理Ingressgateway，接收外部流量，但是我们仍然需要对外部调用方提供唯一的IP地址。我们需要在Envoy前面再加一层代理，比如，可以使用Keepalived与LVS配合，保证当集群中的节点出现问题，导致Ingressgateway部分实例出现故障或者Envoy代理部分实例出现故障时，不会改变集群外的流量入口IP地址，进而减少对服务调用方的影响。由于篇幅问题，本书不进行此部分的实验。