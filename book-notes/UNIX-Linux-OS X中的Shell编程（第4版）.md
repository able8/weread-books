## UNIX-Linux-OS X中的Shell编程（第4版）
> 斯蒂芬·G.寇肯 帕特里克·伍德

### 内容提要

本书是经典图书Unix Shell Programming时隔15年之后的全新升级版本，全面讲解了如何在POSIX标准Shell环境中开发程序，以充分发挥UNIX和类UNIX操作系统的潜在功能。

### 前言

UNIX系统为程序开发提供了既优雅又高效的环境。

UNIX系统最重要的特性之一就是各式各样的程序。超过200个基本命令会随着标准操作系统发行，Linux还对标准命令数量做了扩充，通常能达到700～1000个！这些命令（也称为工具）从统计文件行数、发送电子邮件到显示特定年份的日历，可谓无所不能。
不过UNIX真正的威力并非来自数量庞大的命令，而在于你可以非常轻松、优雅地将这些命令组合在一起完成非常复杂的任务。

UNIX的标准用户界面是命令行，其实就是Shell，它的角色是作为用户和系统最底层之间（内核）的缓冲带。Shell就是一个程序，读入用户输入的命令，将其转换成系统更易于理解的形式。它还包括了一些核心编程构件，可以做出判断、执行循环以及为变量储值。


### 1.1 基础命令

你会注意到echo将单词间多余的空白字符（blank）压缩了。这是因为在UNIX系统中，单词（word）非常重要，而空白字符就是用来分隔单词的。UNIX系统通常会忽略多余的空白字符

### 1.3 使用目录

在目录树的顶部有一个名为/（读作slash）的特殊目录，该目录称为根目录（root）。

### 1.4 文件名替换

Shell会自动将模式 *替换成当前目录下能够匹配到的所有文件名。如果你在其他命令中使用 *，相同的替换过程一样会发生。那么echo命令呢？

命令行中只要是 *出现的地方，Shell都会进行替换：
￼
        $ echo *: *￼
        chaptl chapt2 chapt3 chapt4 : chaptl chapt2 chapt3 chapt4￼
        $
*能够实现部分文件替换功能，它实际上还可以与其他字符配合使用，以限制所能够匹配到的文件名范围。

1.4.2 匹配单个字符
星号（*）能够匹配零个或多个字符，也就是说，x*能够匹配文件x，也能够匹配x1、x2、xabc等。问号（?）仅能够匹配单个字符。因此cat ？能够显示出所有文件名中只有单个字符的文件，而cat x？则会显示出文件名长度为两个字符且第一个字符是x的所有文件。我们再一次用echo来演示这种匹配行为：

如果[之后的第一个字符是！，那么所匹配的内容正好相反。也就是说，匹配中括号内容之外的任意字符。因此：
￼
        [!a–z]

### 1.5 文件名中不易察觉的部分

有两种标准的解决方法：使用反斜杠将所有的空格进行转义，或者将整个文件名放在引号中，让Shell知道这是一个包含了空格的单词，并非多个单词。

### 1.8 标准错误


        $ ls n* > foo￼
        n* not found￼
        $
你可以看到，即便是做了标准输出重定向，这条消息依然出现在了终端，并没有被添加到文件foo中。
上面的例子揭示了标准错误存在的原因：即便是标准输出被重定向到了文件中或通过管道导向了其他命令，错误消息依然能够显示在终端中。

注意，2和>之间可没有空格。所有正常情况下应该进入标准错误的错误信息都会被转入file所指定的文件中，类似于标准输出重定向。

### 2.1 内核和实用工具

UNIX系统在逻辑上被划分为两个不同的部分：内核和实用工具（Utility），如图2.1所示。或者你也可以认为是内核和其他部分，通常来说，所有的访问都要经由Shell。

内核是UNIX系统的核心所在，当打开计算机并启动（booted）之后，内核就位于计算机的内存中，直到关机为止。

Shell也是一个实用工具程序，它作为登录过程的一部分被载入到内存中执行。实际上，有必要了解当终端或终端窗口中的第一个Shell启动时所发生的一系列事件。

### 3.1 正则表达式

来看另一个正则表达式：[插图]它能够匹配长度为4到7之间的字母字符序列。

### 3.2 cut

如果字段是由制表符分隔的，可以使用cut的-f选项：

别忘了，你并不需要使用-d选项来制定分隔符，因为cut默认使用的分隔符就是制表符

该怎么知道字段是由空格还是由制表符分隔的？其中一种方法是像之前那样采用试错法。另一种方法是在终端中输入命令：
￼
        sed -n l file

### 3.3 paste

paste命令的效果和cut相反：它不是拆分行，而是合并行。该命令的一般格式为：[插图]由files指定的每个文件中对应的行被“粘贴”或合并在一起，形成了一行，然后写入到标准输出中。连接符“-”可以用在files中，将输入源指定为标准输入。

3.3.1-d选项如果你不希望使用制表符作为输出字段的分隔符，可以通过-d选项来指定：[插图]

### 3.4 sed

特定的行。这正是-n发挥作用的地方：它告诉sed默认不打印任何行。与之搭配使用的是p命令，p命令可以打印出符合指定范围或模式的所有行。例如，要打印文件的前两行：

### 3.5 tr

能处理不可打印字符吗？可以在tr中使用字符的八进制描述形式：[插图]其中nnn是字符的八进制值。这种写法用得不多，不过记住的话，还是有用处的。例如，制表符的八进制值是11，因此，将冒号转换成制表符的另一种方法就是使用下列tr命令：[插图]

在下面的例子中，tr从date命令的输出中获取输入，将所有的空格转换成换行符。结果就是date输出中的每个字段都出现在不同的行上：[插图]

3.5.1-s选项你可以使用-s选项来“压缩”（squeeze）to-chars中多次连续出现的字符。也就是说，如果转换完成后，在to-chars中出现了多个连续的字符，这些字符会被单个字符替代。例如，下面的命令将所有的冒号转换成制表符，使用单个制表符替换多个制表符：

注意，'\t’在很多时候也可以使用以代替’\11'，如果想提高可读性的话，不妨一试。

你可以使用tr中的-s选项来压缩多个空格，只需要将单个空格字符作为第一个和第二个参数即可：

该tr命令的意思是“使用空格来转换多个空格，将输出中的多个空格替换成单个空格。”

只要是在from-chars中列出字符，都会从标准输入中删除。在下面的例子中，使用tr删除了文件intro中的所有空格：

### 3.7 sort

3.7.3-o选项在默认情况下，sort会将排序结果写入标准输出。如果想将结果放在文件中，可以使用输出重定向：[插图]或者可以使用-o选项来指定输出文件。只需要把输出文件名放在-o的后面就行了：

-o选项的价值体现在什么地方了？我们经常需要对文件中的行进行排序，然后使用排序后的结果替换原始文件。但是，如果输入：[插图]该命令并不会奏效——它会将names文件的内容清空！但如果使用-o选项的话，就算是输入文件和输出文件都是同一个也没有问题：

### 3.8 uniq

[插图]其中，uniq将in_file复制为out_file，同时删除所有重复的行。uniq将重复的行定义为内容一模一样的连续行。

### 4.2 变量

要想避免这种情况，可以将整个的变量名放进花括号里，也就是这样：

只有在变量名的最后一个字符后面跟的是字母及数字字符或下划线的时候才有必要使用花括号。

### 4.3 内建的整数算术操作

所有的现代UNIX以及Linux变种（包括Mac OSX的命令Shell）中所包含的POSIX标准Shell提供了一种叫做算术扩展（arithmetic expansion）的机制，能够用于执行Shell变量的整数运算。注意，有些比较旧的Shell并不支持该特性。算术扩展的格式为：[插图]

### 5.2 双引号

因为Shell会从命令行中删除空格、制表符和换行符（空白字符），然后切分成参数交给所请求的命令。


        echo $address
这样会使得Shell删除内嵌的换行符，其处理方式和空格或制表符一样：作为参数分隔符。然后将9个参数传给echo显示。echo自始至终都没见到过换行符，Shell已经提前处理了（见图5.5）。

而在使用命令
￼
        echo "$address"
的时候，Shell和之前一样会替换变量address的值，但是双引号会告诉Shell保留所有内嵌的空白字符。因此，在这种情况下，Shell只给echo传递了一个参数，其中包含了嵌入的换行符。echo然后就将这个参数显示了出来。图5.6演示了这个过程，换行符在图中用\n表示。

双引号还可以用来保留单引号，反之亦然：
￼

### 5.4 命令替换

5.4.2 $(...)结构
所有的现代UNIX、Linux以及其他POSIX兼容的Shell都支持一种更新、更可取的命令替换写法：$(...)。其一般形式为：
￼
        $(command)

这种写法要比反引号更好。原因如下：首先，使用了单引号和反引号的复杂命令会很难阅读，尤其是当你所使用的字符无法从视觉上区分两者的时候；其次，$(...)易于嵌套，能够在命令替换中再进行命令替换。尽管使用反引号也可以实现命令替换的嵌套，但是得花点心思。

这是因为在Shell处理echo命令时，filelist中的换行符被丢弃了。双引号能够保留变量中的换行符：

### 5.5 expr命令

但是expr并不擅长解析等式，因此操作数和操作符之间必须用空格分隔，这样它才能正确理解。

Shell会将*替换成当前目录下的所有文件名，expr不知道如何对其作出处理！尤其是在乘法中，交给expr的表达式必须放在引号中，避免受到Shell的干扰，但是又不能作为单个参数，例如：

类似于Shell内建的算术功能，expr只能够求值整数算术表达式。如果要进行浮点数运算的话，那么可以使用awk或bc

### 6.1 变量$#

除了位置参数，特殊Shell变量$#包含了命令行中输入的参数个数。你在下一章中会看到，程序经常使用该变量测试用户指定的参数个数是否正确。

### 6.2 变量$*

特殊变量$*引用的是传给程序的所有参数。它通常用于能够接受可变数量参数的程序中。

### 6.4 向电话簿中添加联系人

sort命令的-o选项可以指定排序后的输出被写入何处，可以和输入文件相同：

### 6.6 shift命令

shift命令可以让你向左移动位置参数。如果你执行命令：
￼
        shift
那么之前保存在$2中的内容会分配给$1，保存在$3中的内容会分配给$2，以此类推。
而$1中的旧值也就丢失了

你可以在shift之后加上一个量词，一次移动多个位置，例如：
￼
        shift 3

### 7.2 变量$?

Shell会将变量$？自动设置为最后一条命令的退出状态。你自然可以使用echo在终端中显示该变量的值。

将字符^放在模式的前面，使其在行首进行匹配操作：
￼
        who | grep "^$user" > /dev/null

可以进一步修改模式：
￼
        "^$user "
现在就能够只匹配到指定用户的行了。两个问题都搞定了。

### 7.3 test命令

test命令所有的操作数（$name和julio）和操作符（=）都必须是独立的参数，也就是说，它们彼此之间必须使用一个或多个空白字符分隔。

如果把变量放进双引号中，就能够确保test可以识别出这个参数，因为当参数值为空的时候，引号就相当于一个“占位符”。

如果你希望将这两个值视为等同，只需要把变量引用上的双引号去掉就行了，这会使得Shell删除尾部的空格，test命令就不会再将其视为待比较字符串的一部分了：
￼
        $ day="monday"￼
        $ test $day = monday￼

在空白字符和引号这个话题上，我们看起来有些长篇大论，但你得知道这可是Shell编程中频繁出错的地方。如果真正理解了这些原理，今后能为你避免很多的麻烦。

如果操作符-n之后的参数不为空，它会返回为0的退出状态码。你可以把该操作符看做是测试作为参数的字符串长度是否不为0（nonzero）。

在表达式结尾处需要有对应的]。在[之后以及]之前必须要有空格。

在[之后以及]之前必须要有空格。

7.3.3 整数操作符
test有不少可以用来执行整数比较的操作符。表7.2总结出了这些操作符。

7.3.6 逻辑“与”操作符-a
操作符-a在两个表达式之间执行逻辑“与”运算，仅当这两个表达式均为真时，才返回真。


        [ "$count" -ge 0  -a "$count" -lt 10 ]

### 7.5 exit命令


        if [ "$#" -ne 1 ]￼
        then￼
                echo "Incorrect number of arguments."￼
                echo "Usage: rem name"￼
                exit 1￼
        fi￼

### 7.7 case命令

输入sh -x以跟踪执行过程。这会启动一个启用了-x选项的新Shell来执行指定的程序。

### 7.8 空命令：

可以利用Shell内建的空命令（null command）来实现。该命令的格式非常简单：
￼
        :

### 8.1 for命令

Shell使用$1、$2……来替换$*，但如果你使用特殊的Shell变量"$@"，那么传入程序中的值则是"$1"、"$2"……关键的不同在于$@ 两边的双引号：如果没有了双引号，该变量的效果和$*无异。

### 8.4 再谈循环

break n
可以立即退出第n层内循环，因此，在下面的代码中：

8.4.3 在后台执行循环
整个循环都可以在后台执行，这只需要在done语句后加上一个&就可以了：
￼
        $ for file in memo[1-4]￼
        > do￼
        >           run $file￼
        > done &     

也可以重定向循环的标准错误输出，只需要在done之后加上2> file就可以了：
￼
        while [ "$endofdata" -ne TRUE ]￼
        do￼
                  ...￼
        done 2> errors

2>的另一种写法常用于确保所有的错误信息都出现在终端，哪怕是脚本已经将其输出重定向到了文件或管道：
￼
        echo "Error: no file" 1>&2
在默认情况下，echo会将输出写入到标准输出（文件描述符1），而文件描述符2仍旧指向标准错误，不会受到文件重定向或管道的影

> done | wc –l￼

### 8.5 getopts命令

不过也别焦躁，Shell提供了一个叫做getopts的内建命令，可以轻松地处理命令行参数。该命令的一般形式为：
￼
        getopts options variable

这里的第一个参数air指定了可接受的命令选项（-a、-i和-r）,option是getopts用来存放每个匹配值的变量名。

getopts命令也允许选项在命令行中聚在一起或分组（be clustered or grouped together）出现。这种形式可以通过一个减号，后面跟上多个连续的选项来实现。例如，foo命令可以像这样执行：
￼
        foo -a -r -i
也可以像这样：
￼
        foo -ari

在选项字母后面加上一个冒号，以此告知getopts指定的选项后面要求有一个参数。

while循环中会进行如下处理：调用getopts，将字符m保存在变量option中，设置OPTIND为2，最后返回为0的退出状态码。

第二次执行getopts时，getopts会将字符t保存在option中，将接下来的命令行参数（600）保存在OPTARG中，设置OPTIND为3，最后返回为0的退出状态码。case命令会匹配到option中的字符t，与该分支相关联的命令会将保存在OPTARG中的值600复制到变量interval中。

对于高级Shell编程来说，getopts也值得学习，因为手动去解析一个以上的命令行参数，效率可是很低的。

### 9.1 read命令

从标准输入中读入一行，将第一个单词分配给变量x，将行中余下的内容分配给变量y。按照这种处理逻辑，下列命令：[插图]会读取并将一整行保存到Shell变量text中。

可以简单地将程序调用的唯一进程ID（PID）嵌入到文件名中来实现后一种方法。这只需要使用特殊的Shell变量$$就行了：

Shell会将$$替换成登录Shell的进程ID号。因为系统中每个进程都拥有唯一的进程ID，在文件名中使用$$就避免了不同的进程使用相同文件名的可能。要修正之前着重提到的那个问题，可以使用下面的命令来替换rem中的那两行：

这样就可以避开潜在的竞争条件了。每个使用rolo的用户都是以不同的进程来运行该程序，因此每个实例所用到临时文件名也不一样。问题解决。

注意，如果行中包含反斜线或前导空白字符，程序number就没法正常工作了。下面的例子演示了这一点。

前导空白字符会从读入的行中删除。在读入行的时候，反斜线也会由Shell进行解释。你可以使用read命令的-r选项来避免解释反斜线。如果我们将命令：[插图]修改为：[插图]

### 9.2 printf命令

格式化字符串中那些前面没有百分号（%!）(MISSING)的字符会被直接写入标准输出。按照最简单的用法，printf的效果和echo差不多（只要你记得每行末尾加上\n作为换行符，如下所示）：[插图]

前面有百分号的字符叫做格式规范（format specifications），用于告知printf如何显示对应的参数。格式化字符串中的每个百分号都应该有一个对应的参数，除了特殊规范%，它会显示出一个百分号。

%!d(MISSING)显示有符号整数，%!u(MISSING)显示无符号整数，后者也可以用来将负数按照无符号形式显示。默认情况下，显示八进制或十六进制数时并不包含起始的0或0x，但如果需要的话，可以修改这个行为，本节随后会展示具体做法。

### 10.2 导出变量

有种方法可以让子Shell获知变量的值：使用export命令将变量导出。该命令的格式很简单：[插图]

少。在Mac上，export -p生成的列表包含22个变

### 10.3 PS1和PS2

作为命令行提示符的字符序列被Shell保存在环境变量PS1中。你可以将其修改成任何内容，修改结果立刻就能呈现出来。

PS1有着一套自己的语言，可以使用特殊的字符序列来生成命令计数、当前目录、时间等。可以阅读Bash或sh手册页中Prompting一节来了解更多的相关内容。

### 第11章 再谈参数

可以一次性给多个变量赋值：variable=value variable=value ...下面的例子演示了这种用法：[插图]

### 11.1 参数替换

11.1.2 ${parameter:-value}这种写法的意思：如果parameter不为空，则使用它的值；否则，就使用value。

重要的是要注意到这种写法并不会改变变量的值，因此，如果之前EDITOR为空，执行完上面的语句之后，该变量依然为空。

11.1.3 ${parameter:=value}和上一种写法类似，但如果parameter为空的话，不仅会使用value，而且还会将其分配给 parameter（注意其中的=）。你不能使用这种方法给位置参数赋值，也就是说，parameter不能是数字。

11.1.5 ${parameter:+value}在这种写法中，如果parameter不为空，则替换成value；否则，不进行任何替换。它的效果和“:-”相反。

11.1.7 ${#variable}如何知道变量中保存了多少个字符？下面的写法可以帮你解决：

### 11.2 $0变量

有些UNIX系统会自动将$0设置成包含目录的完整路径，这会导致产生一些乱七八糟的错误信息。可以使用$(basename$0)或先前学到的那个技巧来去除路径名：[插图]

### 11.3 set命令


        set -x
可以打开跟踪模式，这意味着随后的命令会在执行完文件名替换、变量替换及命令替换，还有I/O重定向之后由Shell打印到标准错误中。被跟踪的命令前面会有一个加号。

.3.2 无参数的set如果使用set的时候不加任何参数，会输出一个按照字母顺序排列的变量列表，这些变量都是存在于当前环境中的局部变量或导出变量：

不过有一个不大为人所知的技巧：可以使用set来更改位置参数的值。如果在命令行上将若干单词作为set的参数，那么这些单词会被赋给对应的位置参数$1、$2...。位置参数之前的值也就被覆盖了。在Shell程序中，下列命令：[插图]

会将a赋给$1,b赋给$2,c赋给$3。$#的值会被设为3，以反映出参数个数。

程序读取用户输入，将输入行保存在Shell变量line中，然后执行命令：[插图]这会将line中的每个单词分配给对应的位置参数。变量$#会根据所分配的单词数来设置，这个数量也就是每行的单词数。

set还能够接受其他选项，在选项前加上-表示启用该选项，加上+表示禁止该选项。-x选项用到的次数最多，我们在附录A的表A.9中总结出了其他的选项。

### 11.4 IFS变量

我们将echo的输出通过管道传给带有-b（bytedisplay）选项的od（octal dump）命令：

### 12.1 eval命令

Shell第一次扫描命令行时，它会将pipe替换成对应的值|。然后eval会使得Shell重新扫描命令行，这时候Shell识别出了作为管道符号的|，接下来的事情就顺理成章了。

在Shell程序中，eval常用于从变量中构造命令行。如果变量中包含了任何必须由Shell解释的字符，那就必须用到eval。命令终止符（;、|、&）、I/O重定向（<、>）以及引号都属于这类字符，必须直接出现在命令行上，只有这样，Shell才能识别出它们的特殊含义。

### 12.4 trap命令

Shell程序中的信号处理是通过trap命令实现的，其一般格式为：
￼
        trap commands signals
其中，commands是接收到由signals指定的信号时要执行的一个或多个命令。

下面的例子演示了当用户尝试在终端上终止程序的时候，如何使用trap命令清除文件后再退出：
￼
        trap "rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit" INT
执行trap之后，当程序接收到SIGINT（信号编号为2），文件work1$$和dataout$$就会被自动删除。如果随后用户终止了程序执行，可以确保这两个临时文件不会留在文件系统中。rm后面的exit是必需的，如果漏写的话，程序会一直停留在接收到信号时的执行位置上。

12.4.1 不使用参数的trap
如果在执行trap时不带参数，会显示出你定义过或修改过的所有trap处理程序：

12.4.2 忽略信号
如果trap中没有列出命令，那么指定的信号会被忽略。例如，下列命令：
￼
        trap "" SIGINT
指定忽略中断信号。在执行某些不希望被打断的操作时，你可能需要去忽略某些信号。

注意，在指定信号时，trap允许使用信号编号、信号简称（INT）或者信号全称（SIGINT）。我们建议你使用助记名来提高代码的可读性，当然了，究竟使用哪种方式完全取决于你个人的喜好。

12.4.3 重置信号
如果你修改了信号的默认处理方式，还可以将其再改回原样，只需要忽略trap的第一个参数就行了：
￼
        trap HUP INT
该命令会重置SIGHUP和SIGINT信号的处理方式。

### 12.5 再谈I/O

你也许想将程序的标准输出（通常简称stdout）和标准错误（stderr）都重定向到同一个文件中。如果知道文件名，那么操作方法很直接：
￼
        command> foo 2>> foo
标准输出和标准错误都会被写入foo。
你也可以写作：
￼
        command> foo 2>&1

标准错误自然也可以重新分配：
￼
        exec 2> /tmp/errors
所有随后写入到标准错误的输出都会进入/tmp/errors。

现代Shell还理解另一种写法：如果<<后面的第一个字符是连接符（-），那么输入中的前导制表符都会被Shell删除。如果希望通过可视化缩进来提高重定向文本的可读性，但同时仍希望按照正常的左对齐形式输出，

### 12.6 函数

如果你在函数内部使用exit，不仅会终止函数的执行，而且还会使调用该函数的Shell程序退出，返回到命令行。如果你只是想退出函数，可以使用return命令，其格式如下：[插图]

### 12.7 type命令

type命令接受一个或多个命令名作为参数，可以告诉你这些命令是什么类型。下面是几个例子：

### 14.5 vi行编辑模式

要想使用行编辑器，你必须按ESCAPE或Esc键（通常是在键盘左上角）切换到命令模式。进入命令模式后，光标会向左移动一个空格，移到所输入的最后一个字符上。

### 14.11 数组

Korn和Bash Shell均提供了有限的数组功能。Bash数组对于数组元素的个数没有限制（仅受限于内存容量），而KornShell将数组元素个数限制在4096个。在这两种Shell中，数组元素都是以0作为起始。

[*]可以作为下标，用来在命令行中生成数组的所有元素，元素之间用空格分隔。

### 14.13 其他特性

如你所见，“cd –”可以毫不费力地在两个目录之间切换。

### A.11 导出变量与子Shell执行

A.11.1 (...)
小括号中可以放入一条或多条命令，这些命令会在子Shell中执行。
A.11.2 { ...; }
如果在花括号中放入一条或多条命令，那么这些命令会在当前Shell中执行。
有了(...)和{ ...; }这两种写法，I/O重定向和管道可以作用在括号中的一组命令上，在末尾加上&，就能够把这组命令置入后台执行。例如

.11.3 再谈Shell变量
可以通过在命令行上将赋值语句放在命令名之前的方式将Shell变量添加到该命令的环境中，例如：
￼
        PHONEBOOK=$HOME/misc/phone rolo
在这里，变量PHONEBOOK被赋以指定的值，然后添加到rolo的环境中。当前Shell的环境保持不变，其效果等同于：
￼
        (PHONEBOOK=$HOME/misc/phone; export PHONE BOOK; rolo)

### A.14 命令总结

可以使用-s选项来指定信号名，在这种情况下，信号名前不用加连字符（看下面的例子）。
如果没有指定signal，则使用SIGTERM(TERM)。
示例：
￼
        kill -91234￼
        kill -HUP %!￼(MISSING)
        kill –s TERM %!￼(MISSING)
        kill %!(NOVERB)