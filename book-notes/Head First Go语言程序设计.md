## Head First Go语言程序设计
> 杰伊·麦克格瑞恩

### 译者序

2020年2月25日，Go语言Go 1.14版发布。

Go语言在云计算、边缘计算、大数据、微服务、物联网、高并发领域应用得越来越广泛。越来越多的知名公司正在把Go作为开发新项目的首选语言。

### 我们知道你的大脑在想什么

一些“Head First”的学习准则：
可视化知识。图像远比文字更令人印象深刻，也使学习变得更加有效。

### 元认知：思考“何为思考”

例如，研究表明，把单词放在它们描述的图片中（而不是放在页面的其他地方，比如标题或正文中），会让你的大脑试图理解单词和图片之间的关系，这就会引起更多的神经元活动。更多的神经元活动意味着你的大脑更有可能意识到这是一件值得注意的事情，并有可能把它记录下来。

### 我们是这样做的

我们使用图片，因为你的大脑会为视觉而不是为文字做出调整。就你的大脑而言，一张图片真的胜过千言万语。当文字和图片放在一起的时候，我们将文字嵌入图片中，这样当文字在它所指的事物中，而不是在标题中或隐藏在正文中的某个地方时，你的大脑会工作得更有效。我们使用冗余，用不同的方式、不同的媒体类型和不同的感官说同样的事情，以增加内容被编码到大脑多个区域的机会。

我们使用了个性化的对话方式，因为当你的大脑认为你在谈话时会比它认为你在被动地听演讲时更加关注。即使在阅读时，你的大脑也会这样做。

⑥　大量喝水。
大脑在水分充足的时候工作效率最高。脱水（可能在你感到口渴之前就会发生）会降低认知功能。

⑨　写大量代码！学习开发Go程序只有一种方法：写大量代码。这就是你在整本书中要做的。编程是一种技能，而要想精通它，唯一的方法就是练习。

### Go Playground

Go Playground尝试Go的最简单的方法是在你的Web浏览器中访问https://play.golang.org。在那里，Go团队设置了一个简单的编辑器，你可以输入Go代码并在他们的服务器上运行，结果就显示在浏览器上。

### Println函数

打印完所有参数后，Println将跳到新的终端行。（这就是为什么“ln”在它名字的末尾。）

### 使用其他包中的函数

导入包后，我们可以通过输入包名、点和我们想要的函数名来访问它提供的任何函数。

### 字符串

你可以在代码中直接使用字符串字面量来定义字符串：双引号之间的文本，Go将把它们视为字符串。

### 符文

符文
字符串通常用于表示一系列文本字符，而Go的符文（rune）则用于表示单个字符。

字符串字面量由双引号（"）包围，但rune字面量由单引号（'）包围。

Go程序几乎可以使用地球上任何语言的任何字符，因为Go使用Unicode标准来存储rune。rune被保存为数字代码，而不是字符本身，如果你把rune传递给fmt.Println，你会在输出中看到数字代码，而不是原始字符。

与字符串字面量一样，转义序列也可以用在rune字面量中，用来表示程序代码中难以包含的字符：

### 类型

Go是静态类型的，这意味着它甚至在程序运行之前就知道值的类型是什么。

Go是静态类型的。如果你在错误的位置使用了错误的值类型，Go会告诉你。

### 类型（续）

类型（续）
你可以通过将任何值传递给reflect包的TypeOf函数，来查看它们的类型。

### 声明变量

在Go中，变量是包含值的一块存储。可以使用变量声明为变量命名。只需使用var关键字，后跟所需的名称以及变量将保存的值的类型。

### 命名规则

名称必须以字母开头，并且可以有任意数量的额外的字母和数字。

·如果变量、函数或类型的名称以大写字母开头，则认为它是导出的，可以从当前包之外的包访问它。（这就是为什么fmt.Println中的P是大写的：这样它就可以在main包或任何其他包中使用。）如果变量/函数/类型的名称是以小写字母开头的，则认为该名称是未导出的，只能在当前包中使用。

Go社区还遵循一些额外的约定：
·如果一个名称由多个单词组成，那么第一个单词之后的每个单词都应该首字母大写，并且它们应该连接在一起，中间没有空格，比如topPrice、RetryConnection，等等。（名称的第一个字母只有在你想从包中导出时才应大写。）这种样式通常称为驼峰大小写，因为大写字母看起来像驼峰。

### 转换

解决方法是使用转换，它允许你将值从一种类型转换为另一种类型。只需提供要将值转换成的类型，后面紧接着是在圆括号中的要转换的值。

### 转换（续）

在进行转换时，请注意它们可能会如何更改结果值。例如，float64变量可以存储小数值，但是int变量不能。当你将float64转换为int时，小数部分会被简单地删掉！这可能会抛弃用结果值执行的任何操作。

### 你的Go工具箱

函数调用
函数是一段代码，你可以从程序的其他位置调用它。
调用函数时，可以使用参数向函数提供数据。

■　string是一系列字节，通常表示文本字符。
■　rune表示单个文本字符。

### 调用方法

调用方法
在Go中，可以定义方法：与给定类型的值相关联的函数。Go方法有点像你可能看到的其他语言中附加到“对象”上的方法，但它们有点简单。

time.Now函数返回当前日期和时间的新Time值，我们将其存储在now变量中。然后，我们对now引用的值调用Year方法：

方法是与特定类型的值关联的函数。

### 评分

不太常用的注释形式是块注释，它跨越多行。块注释以/*开始，以*/结束，这些标记之间的所有内容（包括换行）都是注释部分。

### 函数或方法的多个返回值

Go要求声明的每个变量都必须在程序的某个地方使用。如果我们添加了一个err变量，而不检查它，我们的代码将无法编译。未使用的变量通常表示一个bug，所以这是一个Go帮助你检测和修复bug的例子！

### 选项2：处理错误

log包有一个Fatal函数，它可以同时为我们完成这两项操作：将一条消息记录到终端并停止程序运行。（在这个上下文中，“Fatal”意味着报告一个错误，并“杀死”你的程序。）

### 避免遮盖名字

命名一个error变量是一个坏主意，因为它会遮盖一个名为error的类型的名称。
声明变量时，应确保它与任何现有的函数、包、类型或其他变量的名称不同。如果在封闭范围内存在同名的东西（稍后我们将讨论作用域），则你的变量将对它进行遮盖，也就是说，优先于它。而这往往是一件坏事。

### 避免遮盖名字（续）

我们将在第3章中看到，Go有一个名为error的内置类型。这就是为什么在声明用于保存错误的变量时，我们将它们命名为err而不是error——我们希望避免用变量名来遮盖error类型的名称。

### 将字符串转换为数字（续）

strings包有一个TrimSpace函数，它将删除字符串开头和结尾的所有空白字符（换行符、制表符和常规空格）。

传递给ParseFloat一个要转换为数字的字符串，以及结果应该具有的精度位数。因为我们要转换为float64值，所以我们传递数字64。（除了float64之外，Go还提供了一个不太精确的float32类型，但是除非你有很好的理由，否则不应该使用它。）

### 块和变量的作用域（续）

我们在条件块中声明了status。（事实上，我们声明了两次，因为有两个单独的块。这就是为什么我们收到了两个status被声明了但没有被使用的错误。）然后我们试图在那些块之外访问status，但那里并不在它的作用域内。

### 包名与导入路径

math/rand包有一个Intn函数，可以生成一个随机数，所以我们需要导入math/rand。然后调用rand.Intn生成随机数。

### 生成随机数（续）

为了得到不同的随机数，我们需要向rand.Seed函数传递一个值。这将“播种”随机数生成器，也就是说，给它一个值，它将用于生成其他随机值。但如果我们一直给它相同的种子值，它就会一直给我们相同的随机值，我们会回到开始的地方。

### 初始化和标志（post）语句是可选的

循环和作用域与条件语句一样，循环块中声明的任何变量的作用域都仅限于该块（虽然初始化语句、条件表达式和标志（post）语句也可以被认为是该作用域的一部分）。

与条件语句一样，在循环之前声明的任何变量仍然在循环的控制语句和块中的作用域内，并且在循环退出后仍将在作用域内。

### 在我们的猜谜游戏中使用循环（续）

Go提供了控制循环流的两个关键字。第一个continue，立即跳转到循环的下一个迭代，而不需要在循环块中运行任何其他代码。

### 使用Printf和Sprintf格式化输出

fmt包提供了Printf函数。Printf代表“带格式的打印”。它接受一个字符串并将一个或多个值插入其中，以特定的方式进行格式化。然后打印结果字符串。

### 格式化动词（续）

%!v(MISSING)可以显示一些值，如果不使用%!v(MISSING)的话，这些值可能会在输出中被隐藏，例如，在这段代码中，%!v(MISSING)显示了一个空字符串、一个制表符和一个换行符，所有这些在用%!v(MISSING)打印时都是不可见的。在本书的后面，我们将更多地使用%!v(MISSING)！

### 格式化小数宽度

最后一种格式是"%!f(MISSING)"，将允许我们取任意精度的浮点数，并将它们四舍五入到小数点后两位。（它也不会做任何不必要的填充。）让我们在程序中尝试用极度精确的值来计算油漆量。

### 声明函数

声明以func关键字开头，后跟希望函数具有的名称、一对圆括（），然后是包含函数代码的块。

·包含多个单词的名称应该使用驼峰式大小写。

### 函数返回值（续）

如果返回值的类型与声明的返回类型不匹配，你也会收到一个编译错误。

### paintNeeded函数需要错误处理

strconv.Atoi函数试图将字符串转换为整数。如果转换成功，它将返回一个错误值nil，这意味着我们的程序可以继续进行。但如果错误值不是nil，则意味着字符串不能转换为数字。在这种情况下，我们选择打印错误值并退出程序。

### 错误值

创建错误值的最简单方法是将字符串传递给errors包的New函数，该函数将返回一个新的错误值。如果对该错误值调用Error方法，将会得到传递给errors.New的字符串。

如果要将错误值传递给fmt或log包中的函数，则可能不需要调用它的Error方法。fmt和log中的函数已经被编写成能够检查是否传递给它们的值有Error方法，如果有，则打印Error的返回值。

### 声明多个返回值

要声明函数的多个返回值，需将返回值类型放在函数声明的第二组圆括号中（在函数参数的圆括号之后），用逗号分隔。（当只有一个返回值时，返回值周围的圆括号是可选的，但如果有多个返回值，则必须使用圆括号。）

如果要使返回值的目的更清楚，你可以为每个返回值提供名称，类似于参数名称。命名返回值的主要用途是作为程序员阅读代码的文档。

### 指针

你可以使用一个&符号获取变量的地址，它是Go的“地址”运算符。

量，打印它的值，然后打印变量的地址……

表示变量地址的值称为指针，因为它指向可以找到变量的位置。

### 指针类型

指针的类型可以写为一个*符号，后面跟着指针指向的变量的类型。例如，指向一个int变量的指针的类型将被写为*int（你可以将其大声读作“指向int的指针”）。

我们可以使用reflect.TypeOf函数来显示之前程序中指针的类型：

我们可以声明保存指针的变量。指针变量只能保存指向一种类型值的指针，因此变量可能只保存*int指针，只保存*float64指针，依此类推。

### 获取或更改指针的值

（对于如何读出*没有官方的一致意见，但是我们喜欢把它读成“处的值”，所以*myIntPointer就是“myIntPointer处的值”。）

*运算符还可用于更新指针处的值：

*myIntPointer=8访问myIntPointer处的变量（即myInt变量）并为其分配一个新值。所以不仅更新了*myIntPointer的值，而且myInt的值也更新了

### 函数指针

可以从函数返回指针，只需声明函数的返回类型是指针类型。

确保只使用指针作为参数，如果函数声明它将使用指针。如果试图将值直接传递给期望指针的函数，将会收到编译错误。

### 使用包在程序之间共享代码

如果你的部分代码在多个程序之间共享，你应该考虑将它们移到包中。

### Go工作区目录保存包代码

在src中，每个包的代码都位于它自己单独的子目录中。按照惯例，子目录名应该与包名相同（因此gizmo包的代码将放在gizmo子目录中）。

### 包命名规范

包命名规范使用包的开发人员每次调用包中的函数时都需要输入包名。（想想fmt.Printf、fmt.Println、fmt.Print等）为了尽可能地使之不那么痛苦，包名应该遵循以下几个规则：·包名应全部为小写。·如果含义相当明显，名称应该缩写（如fmt）。·如果可能的话，应该是一个词。如果需要两个词，不应该用下划线分隔，第二个词也不应该大写。（strconv包就是一个例子。）

### 常量

·使用const关键字而不是var关键字。·必须在声明常量时赋值；不能像变量那样以后赋值。·变量有：=短变量声明语法，但是常量没有等效的语法。

与变量声明一样，你可以省略类型，它将从分配的值推断出来：

### 嵌套的包目录和导入路径

一些包集通过导入路径前缀，如"archive/"和"math/"分组在一起。我们说过把这些前缀视为与硬盘上目录的路径类似……这不是巧合。这些导入路径的前缀是使用目录创建的！你可以将类似的包组嵌套在Go工作区的一个目录中。然后，该目录将成为它包含的所有包的导入路径的一部分。

将包放置在greeting目录下也会影响它们的导入路径。如果dansk包直接存储在src下，它的导入路径将是"dansk"。但是将其放在greeting目录中，它的导入路径就变成了"greeting/dansk"。将deutsch包移到greeting目录下，其导入路径变为"greeting/deutsch"。原来的greeting包在"greeting"的导入路径中仍然有效，只要它的源代码文件直接存储在greeting目录（而不是子目录）下。

### 使用“go install”安装程序可执行文件

（请确保将“src”中的目录名传递给“go install”，而不是.go文件名！默认情况下，“go install”未设置成直接处理.go文件。）

当Go看到hi目录中的文件包含一个package main声明时，它会知道这是一个可执行程序的代码。它将编译一个可执行文件，并将其存储在Go工作区中名为bin的目录中。（如果bin目录不存在，则会自动创建它。）

与go build命令（其以所基于的.go文件来命名可执行文件）不同，而go install命令则以包含代码的目录来命名可执行文件。由于我们编译了hi目录的内容，所以可执行文件将被命名为hi（或在Windows上是hi.exe）。

你还可以将工作区的“bin”目录添加到系统的“PATH”环境变量中。然后，就可以从系统的任何地方运行“bin”中的可执行文件了！Mac和Windows的最新的Go安装程序将会为你更新“PATH”。

### 发布包

让我们在GitHub（一个流行的代码共享网站）上创建一个存储库来保存代码。这样，其他开发人员就可以下载并在自己的项目中使用它！我们的GitHub用户名是headfirstgo，我们将存储库命名为keyboard，所以其URL是：https://github.com/headfirstgo/keyboard我们只将keyboard.go文件上传到存储库，而不将其嵌套在任何目录中。

### 发布包（续）

我们希望通过使用域名和路径来确保包导入路径是唯一的，但是我们并没有真正做到这一点。Go社区从一开始就将其用作包命名标准。类似的想法已经在像Java这样的语言中使用了几十年。

### 使用“go get”下载和安装包

使用包所在的URL作为导入路径还有另一个好处。go工具还有一个名为go get的子命令，它可以自动为你下载和安装包。

go get后面跟着存储库URL，但是“模式”部分（“https：//”）被去掉了。go工具将连接到github.com，在/headfirstgo/greeting路径下载Git存储库，并将其保存在Go工作区的src目录中。

### 使用“go doc”阅读包文档

我们可以通过运行go doc strconv获得关于strconv包的信息。

### 使用“go doc”阅读包文档（续）

可以使用go doc strconv ParseFloat来调出它的文档。

[插图]

### 使用doc注释记录包

使用doc注释记录包
go doc工具通过检查代码，努力向其输出中添加有用的信息。为你添加包名和导入路径。函数名、参数和返回类型也是如此。

只需在代码中添加文档注释。直接出现在package子句或函数声明之前的普通Go注释被视为文档注释，将显示在go doc的输出中。

### 使用doc注释记录包（续）

添加文档注释时，需要遵循一些惯例：
·注释应该是完整的句子。
·包注释应以“Package”开头，后跟包名：

// Package mypackage enables widget management.

·函数注释应以它们描述的函数的名称开头：

// MyFunction converts widgets to gizmos.

### 你的Go工具箱

■　包名应该都是小写的，理想情况下由一个单词组成。
■　包的函数只有在导出后才能从包外部调用。如果函数的名称以大写字母开头，则该函数是可导出的。

### 数组字面量

如果数组字面量的最后一项后面跟着的是换行符，你甚至需要在其后面跟一个逗号。（这种风格刚开始看起来很别扭，但它使以后向代码中添加更多元素变得更容易。）

### “fmt”包中的函数知道如何处理数组

fmt包中有为你做格式化和打印数组的逻辑。（fmt包还可以处理切片、映射和稍后将看到的其他数据结构。）

你可能还记得Printf和Sprintf函数使用的"%!v(MISSING)"动词，它将按照在Go代码中显示的方式格式化值。当用"%!v(MISSING)"格式化时，数组在结果中显示为Go数组字面量。

### 使用“for...range”安全遍历数组

处理数组中每个元素的一种更安全的方法是使用特殊的for...range循环。

由于元素值是自动分配给变量的，因此不会有意外访问无效数组索引的风险。因为它更安全、更容易阅读，所以在处理数组和其他集合时，你将看到for循环的range形式最常用。

### 读取文本文件（续）

我们首先向os.Open函数传递一个带有要打开文件的名字的字符串。从os.Open会返回两个值：指向代表被打开文件的os.File值的指针，以及一个错误值。正如我们在许多其他函数中看到的那样，如果错误值为nil，则表示文件被成功打开，但是任何其他值都表示存在错误。（如果文件丢失或不可读，就可能会发生这种情况。）如果是这种情况，我们会记录错误信息并退出程序。

一旦循环退出，我们就完成了对文件的处理。保持文件打开会消耗操作系统的资源，因此当程序完成了对文件的操作时，文件应该总是关闭的。对os.File调用Close方法将完成此操作。与Open函数一样，Close方法也返回一个error值，除非出现问题，否则该值将为nil。（与Open不同，Close只返回一个值，因为除了错误之外，它没有其他有用的值可以返回。）

在扫描文件时，bufio.Scanner也可能遇到错误。如果是这样，调用扫描器上的Err方法将返回该错误，我们将在退出之前记录该错误。

### 我们的程序只能处理三个值（续）

Go数组的大小是固定的，它们不能增长或收缩。但是对data.txt文件用户可以添加任意多行。我们将在下一章中看到解决这种困境的方法！

### 你的Go工具箱

要声明数组变量，包括方括号中的数组长度以及要保存的元素类型：[插图][插图][插图]■　要赋值或访问数组的元素，在方括号中提供其索引。索引从0开始，因此myArray的第一个元素是myArray[0]。

os.Open函数打开一个文件。它返回一个指向os.File值的指针，该值代表那个打开的文件。

### 切片

与数组相同的是，切片由多个相同类型的元素构成。不同的是，切片允许我们在结尾追加更多的元素。为了声明一个保存切片的变量，你可以使用一对空的方括号，后面跟着这个切片所保存的元素类型。

除了不指定大小，与声明一个数组变量的语法完全相同。

不像数组变量，声明切片变量并不会自动创建一个切片。为此，你可以调用内建的make函数。传递给make你想要创建的切片的类型（这个类型与你想要赋值的变量的类型相同）和需要创建的切片的长度。

你不必将声明变量和创建切片分成两步，使用一个短变量声明的make会自动帮你推导出变量的类型。

### 切片字面量

切片字面量看起来和数组字面量非常像，但是数组字面量在方括号中有数组的长度，而切片字面量的方括号中是空的。空的括号后面是切片储存的元素的类型，还有一个在花括号中的列表，列表中是每个元素的初始值。

这里不需要调用make函数；在代码中使用一个切片字面量会创造一个预填充的切片。

### 切片运算符

当你使用make函数或者切片字面量创建一个切片的时候，底层的数组会自动创建出来（只有通过切片，你才能访问它）。但是你也可以自己创建一个数组，然后再基于数组通过切片运算符创建一个切片。

### 底层数组

正如我们之前提到的，切片并不会自己保存任何数据，它仅仅是底层数组的元素的视图。你可以把切片看作一个显微镜，聚焦在胶片（底层数组）内容的特定部分。

### 修改底层数组，修改切片

修改底层数组，修改切片现在，请注意以下事项：由于切片只是底层数组内容的视图，如果你修改底层数组，这些变化也会反映到切片。

给切片的一个元素赋一个新值也会修改底层数组相应的元素。

由于这些问题，你应该已经发现通常我们使用make和切片字面量来创建切片，而不是创建一个数组，再用一个切片在上面操作。使用了make和切片字面量，你就不用关心底层数组了。

### 使用“append”函数在切片上添加数据

Go提供一个内建的函数append来将一个或者多个值追加到切片的末尾。它返回一个与原切片元素完全相同的并且在尾部追加了新元素的新的更大的切片。

### 使用“append”函数在切片上添加数据（续）

注意我们需要确保将append返回的值重新赋给传递给append的那个变量。这是为了避免append返回的切片中的一些不一致行为。切片的底层数组并不能增长大小。如果数组没有足够的空间来保存新的元素，所有的元素会被拷贝至一个新的更大的数组，并且切片会被更新为引用这个新的数组。但是由于这些场景都发生在append函数内部，无法知道返回的切片与传入append函数的切片是否具有相同的底层数组。如果你保留了两个切片，会导致一些非预期的错误。

所以我们调用append函数，惯例是将函数的返回值赋给你传入的那个切片变量。如果你只保存一个切片，你就无须考虑两个切片是否共享了同一个底层数组。

### 切片和零值

不像数组，切片变量自己也有0值：nil。一个没有赋值的切片变量值为nil。

但是在Go中，函数有意被写成对待nil的切片就像它是一个空切片一样。例如，如果输入参数是一个nil切片那么len返回0：

### 从os.Args切片获取命令行参数

os包有一个包级别的变量os.Args，它是一个字符串的切片，代表了当前执行程序的命令行参数。

### 更新程序以使用命令行参数

我们在os.Args上使用切片运算符来忽略程序名称，并且把返回切片赋给一个arguments变量。我们设置一个sum变量来保存所有输入数字的和。然后使用for...range循环处理arguments的元素（使用_空白标识符来忽略元素索引）。我们使用strconv.ParseFloat来将参数从字符串转换为float64。如果出现错误，我们输出并退出。如果没有，我们将数字累加到sum。

### 可变长参数函数

为了让函数的参数可变长，在函数声明中的最后的（或者仅有的）参数类型前使用省略号（...）。

### 向可变长参数函数传递一个切片（续）

我们必须在让函数参数可变长和让它可以接受切片参数之间做出选择吗？幸运的是，Go为这种情况提供了一个特殊的语法。当我们调用一个可变长参数函数时，简单地在你传入的切片变量后增加省略号（...）即可。

### 你的Go工具箱

同型的切片变量与数组变量的声明相同，只是它忽略了长度：[插图][插图][插图]■　在大多数情况下，切片和数组的代码行为完全相同。包括元素赋值、使用0值、传递给len函数和for...range循环。■　切片字面量的声明与数组字面量相同，但它忽略了长度：[插图][插图][插图]

为了声明一个变长参数函数，在最后一个参数之前增加省略号（...）。这个参数就可以以切片的形式接收一组参数。■　当调用可变参数函数的时候，可以通过在切片之后追加省略号的方式来代替变长参数：[插图][插图]

### 映射（续）

与切片一样，声明一个映射变量并不会自动创建一个映射，你需要调用make函数（与你创建切片相同的函数）。你可以传递给make你想要创建的映射类型（与你需要赋值到的类型相同）。

映射的赋值及取值的语法与数组和切片的赋值及取值方式有点像。但是数组和切片仅允许使用整型作为元素索引，而映射可以选择几乎所有的类型来作为键。

### 映射字面量

就像切片字面量，让花括号为空来创建一个空的映射。

### 映射中的零值

对于数组和切片，如果你访问一个没有赋值过的键，你会得到一个零值。[插图]根据值的类型不同，零值可能不一定是0。例如映射的值类型是string，零值就是空字符串

### 映射变量的零值是nil

就像跟切片一样，映射变量的零值是nil。如果你声明了一个映射变量但是未赋值，它的值是nil。那意味着没有映射存在来增加键或者值。如果你尝试这么做，会产生一个panic：

在增加一个新的键/值对之前，需要使用make或者映射字面量来创建一个映射，并且赋值给映射变量。

### 如何区分已经赋值的值和零值

为了解决这个问题，访问映射键的时候可选地获取第2个布尔类型的值。如果这个键已经被赋过值，那么返回true，否则返回false。大多数Go开发者会将这个布尔值赋给一个名为ok的变量（因为名字简短有效）。

如果你仅仅想要测试值是否存在，你可以通过将它赋值给_空白标识符来忽略值。

### for...range循环以随机顺序处理映射

for...range以随机的顺序遍历映射的键和值，因为映射是一个非有序的键/值对集合。当你使用for...range遍历一个映射时，你无法知道你获取的是何种顺序。有时这样可以，但当需要按照特定的顺序遍历时，你需要自己写一些代码。

这里有一些之前程序的更新，使名字按照字母表的顺序输出。它使用了两个for循环。第一个循环遍历映射里面所有的键，忽略值，并且把它们增加到一个字符串的切片上。然后把切片传递给sort包中的Strings函数来以字母表顺序排序。

### 你的Go工具箱

　声明一个映射变量的时候，你必须提供键和值的类型：[插图][插图][插图]■　为了创建一个新的映射，调用make函数并传入需要创建的映射的类型：[插图][插图]

■　从映射中获取一个值能得到第二个可选的布尔值，用来标识这个值是否被赋值过，还是这个值就仅仅代表一个零值：[插图][插图][插图]■　如果你想要测试一个键是否被赋值过，你可以使用_空白标识符来忽略真实的值。[插图][插图]

### 8 构建存储：struct

有时你需要保存超过一种类型的数据。我们学习了切片，它能够保存一组数据。然后学习了映射，它能保存一组键和一组值。这两种数据结构都只能保存一种类型。有时，你需要一组不同类型的数据，例如邮件地址，混合了街道名（字符串类型）和邮政编码（整型）；又如学生记录，混合保存学生名字和成绩（浮点数）。你无法用切片或者映射来保存。但是你可以使用其他的名为struct的类型来保存。本章会介绍struct的所有信息！

### struct是由多种类型的值构建的

使用struct关键字来声明一个struct类型，后面跟着花括号。在括号中，你可以定义一个或多个字段：struct组合的值。每一个字段定义在一个单独的行，由字段名称、后面跟着的字段需要保存的值类型组成。

当我们调用Printf中的%!v(MISSING)的时候，它将myStruct中的值作为struct字面量打印。

### 定义类型和struct

类型定义允许你自己创建新的类型。你可以基于基础类型来创建新的定义类型。

为了定义一个类型，需要使用type关键字，后面跟着新类型的名字，然后是你希望基于的基础类型。如果你使用struct类型作为你的基础类型，你需要使用struct关键字，后面跟着以花括号包裹的一组字段定义，就像你声明struct变量时所做的那样。

### 与函数一起使用已定义类型（续）

要使用一个已经存在的类型名称作为变量的名称！如果你已经在当前包定义了一个名为car的类型，并且你同时也声明了一个名为car的变量，这个变量会遮盖类型名称，使后者无法被访问。

### 使用函数修改struct

那时我们学到了Go是一个按值传递的语言，意味着函数调用时接收的是一个参数的拷贝。如果函数修改了参数值，它修改的只是拷贝，而不是原始值。

对于struct也是相同的。当我们传递subscriberstruct给applyDiscount时，函数接收了一个strcut的拷贝。所以当我们设置了struct的rate字段时，我们设置的是拷贝的struct，而不是原始的。


### 使用函数修改struct（续）

我们的解决方案是修改函数，使它能够接收一个值的指针来代替直接接收值。当调用这个函数时，我们使用取址运算符（&）来传送我们需要更新的值的指针。然后在函数内部，我们使用*来更新指针指向的值。
所以，更新后的值在函数返回后仍然可见。

使用点运算符在struct指针和struct上都可访问字段。

### 通过指针访问struct的字段

所以你可能想到你也需要对指向struct的指针使用*运算符。但是直接把*放到指针前是无法工作的：

如果是*pointer.myField，Go认为myField必须是一个指针。但它不是，所以返回一个错误。为了让代码工作，你需要使用括号包裹住*pointer。那会导致myStruct值被返回，之后你就可以访问struct的字段了。
￼

### 通过指针访问struct的字段（续）

通过指针访问struct的字段（续）
这么一直写（*pointer）.myField很快就会很乏味。所以，点运算符允许你通过strcut的指针来访问字段，就像你可以通过struct值直接访问一样。你可以不需要括号和*运算符。

也可以通过指针来赋值给struct字段：
￼
这就是applyDiscount函数如何可以更新struct字段而不用*运算符。它通过struct指针赋值给rate字段。

### 使用指针传递大型struct

它会为原始的struct和被拷贝的struct都划分空间。
函数接收一个它们被调用时的参数的拷贝，即使它们是像struct那样的大值。
那就是为什么，除非你的struct只有一些小字段，否则向函数传入struct的指针是一个好主意。（即使函数并不想修改struct也是一样的。）当你传递一个struct指针的时候，内存中只有一个原始的struct，并且你可以读取它，修改它，或者做任何你想要的操作，都不会产生一个额外的拷贝。

### 定义类型的名称首字母必须大写才能导出该类型

Go类型名称与变量和函数名称遵循相同的规则：如果变量、函数或者类型以大写字母开头，它就会被认为是导出的，并且可以从外部包来访问。但是我们的subscriber类型名称以小写字母开头。那意味着它只能在magazine包内部使用。


### struct字段的名称首字母必须大写才能导出该字段

struct字段的名称首字母必须大写才能导出该字段
Subscriber类型名称被首字母大写后，看起来我们能在main包中访问它了。但是现在我们得到了一个错误说我们不能访问rate字段，因为它是未导出的。

### struct字面量

Go提供了struct字面量来让你创建一个struct并同时给它的字段赋值。

你可以在花括号中忽略一些甚至所有的字段。被忽略的字段会被设置为它们类型的零值。

### 在另一个struct中设置struct（续）

如果你对fmt.Printf使用"%!v(MISSING)"动词来打印HomeAddress，它会打印出它在Go代码中的样子，也就是说像struct字面量一样。我们将看到每一个Address字段被设置为空字符串，也就是string类型的零值。

### 匿名struct字段

Go允许你定义一个匿名字段：struct字段没有名字，仅仅有类型。我们可以使用匿名字段来让内部struct访问更加简单。
这里更新了Subscriber和Employee类型，让HomeAddress字段作为一个匿名字段。我们只需要移除字段名称，仅保留字段类型。

当你声明一个匿名字段时，你可以使用字段类型名称作为字段名称。

### 嵌入struct

这是main.go的最后版本，修改为将Address当作一个内嵌类型。你可以将代码写成完全没有Address类型；就像Address的字段属于它嵌入的struct类型。

### 你的Go工具箱

使用匿名字段的方式将内部struct增加到外部struct被称为嵌入了外部struct。
·你可以像访问外部字段一样访问嵌入的strcut字段。

### 具有底层基础类型的定义类型

定义类型大多数通常使用struct作为其基础类型，但它们也可以基于int、float64、stirng、bool或者任何其他的类型。

一旦定义了一个类型，你可以把任何基础类型的值转换为定义的类型。像其他的类型转换一样，你写下需要转换到的类型，后面跟着在小括号中的你希望转换的值。

### 具有底层基础类型的定义类型（续）

但是你可以在具有相同基础类型的类型之间转换。Liters可以与Gallons互相转换，因为它们的基础类型是float64。

### 定义方法

定义方法
方法定义与函数定义很像。事实上，它们只有一点不同：你需要增加一个额外的参数，一个接收器参数，它在函数名称之前的括号中。
就像任何的函数参数一样，你需要提供一个接收器参数的名称，后面跟着类型。

方法调用和方法定义的相似性能帮助你记住语法：当你调用一个方法时，接收器要被列为第一个，并且当你定义一个方法的时候，接收器参数也被列为第一个。

（大多数开发者会说sayHi定义在MyType上。）

一旦方法被定义在了某个类型，它就能被该类型的任何值调用。

### 接收器参数（几乎）就是另一个参数

接收器参数的类型是与之联系的方法的类型。但除此之外，接收器在Go中没有什么特殊的。你可以在方法块中访问它的内容，就像其他的函数参数一样。

按照惯例，Go开发者通常使用一个字母作为名称——小写的接收器类型名称的首字母。（这就是为什么我们将m来用作MyType接收器的参数名称。）

Go使用接收器参数来代替其他语言中的“self”或者“this”。

答：方法和类型必须定义在同一包中。这意味着不会在hacking包中定义security包中的类型的方法，并且不会为像int或者string一类的普通类型定义新的方法。

（如果你想要，你可以将接收器参数命名为this，但是不要这么做，约定是使用接收器参数类型名称的第一个字母。）

### 方法（几乎）就像一个函数

就像其他的函数，方法名称以大写字母开头，则认为是导出的，如果它的名称以小写字母开头，则认为是不导出的。如果你想要在当前包之外使用你的方法，确保它的名字以大写字母开头。

### 指针类型的接收器参数（续）

指针类型的接收器参数（续）
我们说过接收器参数与普通参数没有不同。但是就像其他任何参数，接收器参数接收一个接收器的拷贝值。如果你使用方法来修改接收器，你修改的是拷贝，而不是原始值。

放置*号在接收器类型的前面来标识它是指针类型。我们也需要修改方法内部来更新指针指向的值。

顺便说一下，右边的代码打破了一个惯例：为了一致性，你所有的类型函数接受值类型，或者都接受指针类型，但是你应该避免混用的情况。我们仅仅在演示的情况下才混用二者。

Go无法将值类型转换为指针类型，除非你将接收器的值保存在变量中。

你需要将值保存在变量中，允许Go能得到一个指向它的指针。

### 你的Go工具箱

■　一旦一个变量的类型被定义，其他类型的值不能再赋给该变量，即使它们有相同的基础类型。

### 人们将Date struct的字段设置为无效值

我们需要的是一种方法，让用户数据在被赋值之前就是合法的。在计算机科学中，称为数据校验。我们需要测试Year被设置为大于或等于1的值，Month被设置为1~12。Day被设置为1~31。

### setter方法

们应该可以在Date类型上创建SetYear、SetMonth和SetDay方法来接收值，判断是否有效，如果有效，设置到struct字段。这类方法常被称为setter方法。依照惯例，Go的setter方法名为SetX的形式，X是你想要设置的东西的名称。setter方法是用来设置字段或者基础类型中的其他值的方法。

SetYear接受你想要设置的年份作为参数，并设置接收器Date struct上的Year字段。它当前并不校验值的有效性，但是我们会稍后验证。

### setter方法需要指针接收器

我们可以通过将接收器的值修改为指针来修正SetYear：（d*Date）。只需要修改这点。我们不需要更新SetYear方法块，因为d.Year会自动取到指针指向的值（就像我们使用了（*d）.Year）。main函数中的date.SetYear也不需要做修改，因为当Date值传递给方法的时候，它会自动转换为*Date。

### 在setter方法中添加校验

在每个setter方法中，我们将测试值是否在正确的范围内。如果是非法值，返回一个error值。如果合法，我们将会正常设置Date struct字段，并且返回nil作为错误值。让我们首先对SetYear方法增加校验。我们修改方法的声明，增加一个error类型的返回值。在方法块的开始处，我们测试调用者传入的year参数是否小于1。如果是，我们返回一个带着信息"invalidyear"的error。如果大于等于1，我们将它设置为struct的Year字段并且返回nil，表示这里没有错误。

### 字段仍可以设置为无效值

这是事实，没有任何办法能阻止直接设置Date struct的字段。并且如果这么做的话，就会直接绕过setter方法中的验证代码。他们可以设置希望的任何值。我们需要一个方式来保护这些字段，这样使Date类型只能使用setter方法来更新字段。Go提供了一个方法：我们可以把Date类型移动到另一个包，并将数据字段设置为非导出的。

### 将Date类型移到另外的包中

在data.go中，增加一个package calendar的声明，并且导入error包。（那是这个文件中的代码所需要的唯一包。）然后，将所有的Date类型的旧代码拷贝到这个文件。

### 将Date字段设为未导出状态

现在让我们来试着更新Date struct字段，让字段未被导出。只需在字段声明和它出现的所有位置将首字母修改为小写字母即可。Date类型仍然需要是被导出的，就像所有的setter方法，因为我们需要在calendar包之外访问它们。

### 通过导出的方法访问未导出的字段

但是我们可以间接访问字段。未导出的变量、struct字段、函数、方法等仍然能够被相同包的导出的函数或者方法访问。所以当main包中的代码在Date值上调用导出方法SetYear时，SetYear可以修改Date的year字段，即使year是未导出的。导出方法SetMonth可以更新未导出的month字段，等等。

### 通过导出的方法访问未导出的字段（续）

现在Date值的字段只能通过setter方法更新，程序被保护，避免意外输入无效数据。

### getter方法

getter方法不需要修改接收器，所以我们直接使用Date的值作为接收器。但是如果类型的任何方法接受接收器指针类型，为了一致性，通常来说所有的方法都应该这样做。由于我们必须对所有的setter方法使用接收器指针，我们也应对所有的getter方法使用指针。

### 封装

将程序中的数据隐藏在一部分代码中而对另一部分不可见的方法称为封装，它不是Go所独有的。封装很有价值，因为它可以用来防止无效数据（就像我们看到的）。同样，你也可以修改程序代码的封装部分，不用担心其他代码的访问，因为它们不可直接访问。

Go开发者通常在需要的时候才使用封装，比如字段数据需要被setter方法校验时。在Go中，如果你不需要封装一个字段，通常导出并且允许直接访问它。

答：Go语言允许你那样做，但是不推荐。Go社区已经在一个大会上决定了在getter方法前面去掉Get前缀。保留它只会让你的后继者感到困惑。Go仍然对于setter方法使用Set前缀，就像其他语言一样，因为我们需要区分同一个字段的setter方法和getter方法。

### 未导出的字段不会被提升

同样，当Date是Event的一部分的时候，你也不能访问Event中Data未导出的字段。

### 导出的方法像字段一样被提升

导出的方法像字段一样被提升如果你嵌入了一个具有导出方法的struct类型，它的方法会被提升到外部类型，意味着你可以调用那个方法，就像在外部类型上定义了该方法一样。

### 封装Event的Title字段

例如，Title字符串没有长度限制：[插图]看起来将Title字段封装起来是一个好主意，这样我们就能校验新的值了。这里是更新后的Event类型，它是这么做的。我们将字段名称修改为title，这样它就是未导出的，然后增加getter和setter方法。来自unicode/utf8包的RuneCountInString函数被用来确保string中没有过多的字符。

### 提升的方法与外部类型的方法共存

Event类型的Title和SetTitle方法与从嵌入的Date类型提升的方法一同存在。导入calendar包的代码可以让所有的方法被视为属于Event类型，而不用考虑它们真正定义在哪个类型上。

### 我们的calendar包完成了

方法提升允许你使用其他类型的方法就像使用自己的一样。你可以使用这个来组合类型，该类型组合了多种其他类型的方法。这可以帮助保持代码整洁，而不用牺牲便利性。

### 你的Go工具箱

■　在接受数据之前先确保数据有效的做法称为数据校验。■　一个主要用来设置封装字段的方法称为setter方法。setter方法通常包含校验逻辑，以确保提供的值是合法的。■　由于setter方法修改它们的接收器，接收器参数应该是一个指针类型。■　setter方法通常被命名为SetX，X是被设置字段的名称。

■　一个主要被用来获取封装字段值的方法被称为getter方法。■　通常getter方法命名为X，X就是获取的值的字段名称。一些其他的编程语言喜欢使用GetX作为getter方法的名字，但在Go中不推荐。

### 11 你能做什么：接口

有时你并不关心一个值的特定类型。你不需要关心它是什么。你只需要知道它能做特定的事情。你能够在其上调用特定的接口。不需要关心是pen还是pencil，你仅仅需要一个Draw方法。不需要关心是Car还是Boat，你只需要一个Steer方法。那就是Go接口的目标。它允许你定义能够保存任何类型的变量和函数参数，前提是它定义了特定的方法。

### 接口

一个接口是特定值预期具有的一组方法。无论你是否考虑过，你可能也希望Go值向你提供一种与它们交互的方法。最常用的与Go值交互的方法是什么？通过它的方法。在Go中，一个接口被定义为特定值预期具有的一组方法。你可以把接口看作需要类型实现的一组行为。

使用interface关键字定义一个接口类型，后面跟着一个花括号，内部含有一组方法，以及方法期望的参数和返回值。

方法名称、参数类型（可能没有）和返回值（可能没有）都需要与接口中定义的一致。除了接口中列出的方法之外，类型还可以有更多的方法，但是它不能缺少接口中的任何方法，否则就不满足那个接口。一个类型可以满足多个接口，一个接口（通常应该）可以有多个类型满足它。

### 定义满足接口的类型（续）

一个接口类型的变量能够保存任何满足接口的类型的值。下面代码声明了一个MyInterface类型的名为value的变量，然后创建一个MyType的值并赋给value。（这是允许的，因为MyType满足MyInterface。）然后我们可以在value上调用接口的任意方法。

### 具体类型和接口类型

接口类型并不描述是哪个值：它们不说它的基础类型是什么，或者数据是如何存储的。它们仅仅描述了这个值能做什么：它有哪些方法。

### 分配满足接口的任何类型

当你有一个接口类型的变量时，它可以保存满足此接口的任何类型的值。

你们也能将函数的参数定义为接口类型。（毕竟，函数参数也就是变量。）如果声明一个play函数来接受NoiseMaker类型，我们可以传入任何包含了MakeSound方法的值来播放：

### 类型断言

你的第一反应可能是用类型转换将Player类型的值转换为TapeRecorder类型的值。但是类型转换并不适用于接口类型，所以会产生一个错误。

### 类型断言（续）

当你将一个具体类型的值赋给一个接口类型的变量时，类型断言让你能取回具体类型。这像一种形式的类型转换。它的语法甚至像函数调用和类型转换的合体。在一个接口值之后，你输入一个点，后面接着一对括号括起来的具体类型（或者，你想要断言的值的具体类型）。

一旦你使用类型断言来取回具体类型的值，你可以调用那个类型上的方法，但这方法并不属于接口。

### 当类型断言失败时避免异常

当使用类型断言时，如果你不能完全确定接口的原类型是什么，你应该使用可选ok值来处理与你期望的类型不同的情况，避免一个运行时异常。

### “error”接口

我们学习了如何创建自己的error值。我们说过，“一个错误值就是任何含有名为Error的方法的值，此方法返回string”。

声明作为一个接口的error类型意味着，如果它具有一个返回string的Error方法，它就满足error接口，并且它是error的值。这意味着你能定义自己的类型并且用在任何需要error值的地方！

### “error接口”（续）

它指定返回一个error类型的值，而不是OverheatError，但没关系，因为它满足error接口。

为何我们可以在不同的包中使用error接口而不用导入它？它以小写字母开头。那意味着它是从声明的包中未导出的吗？error在哪个包中声明？答：error类型像int或者string一样是一个“预定义标识符”，它不属于任何包。它是“全局块”的一部分，这意味着它在任何地方可用，不用考虑当前包信息。

### Stringer接口

fmt包定义了fmt.Stringer接口：允许任何类型决定在输出时如何展示。让其他类型满足Stringer接口很简单，只需要定义一个返回string类型的方法。接口定义如下所示：

这里我们建立了一个CoffeePot类型来满足Stringer：

### 空接口

如果我们定义一个不需要任何方法的接口会怎么样？它会被任何类型满足！它被所有的类型满足！

type Anything interface {￼
}

### 空接口（续）

空接口（续）
Interface{}类型称为空接口，用来接收任何类型的值。不需要实现任何方法来满足空接口，所以所有的类型都满足它。
如果你定义一个接收一个空接口作为参数的函数，你可以传入任何类型的值作为参数：

但是先不要对你所有的函数使用空接口！如果你有一个空接口类型的值，你无法做任何操作。不需要实现任何方法来满足空接口，所以所有的类型都满足它。

但是不要尝试在空接口值上调用任何函数！请记住，如果你有一个接口类型的值，你只能调用接口上的方法。空接口没有任何方法。那意味着你没法调用空接口类型值的任何方法！

### 空接口（续）

为了在空接口类型的值上调用方法，你需要使用类型断言来获得具体类型的值。

### 你的Go工具箱

■　一个具体类型定义不仅指示了值能做什么（哪些方法可以被调用），也表明了它们是什么：它们定义了保存值数据的基础类型。■　一个接口类型是一个抽象类型。接口并不会描述值是什么：它们不会说基础类型是什么或者数据是如何保存的。它们仅仅描述值能做什么：它具有哪些方法。■　一个接口定义需要包含一组方法名称，以及方法的参数和返回值。

　为了满足一个接口，类型必须实现接口定义的所有方法。方法名称、参数类型（或没有）和返回值类型（或没有）都必须与接口中定义的一致。■　除了接口的方法之外，类型可以有其他的方法，但是它不能缺少接口中的任何方法。否则，类型就不满足那个接口。

当有一个接口类型的变量时，你能在它之上调用的方法只能是接口定义的。■　如果你将一个具体类型赋值给接口类型的变量，你能使用类型断言来获得具体类型的值。只有这样你才能调用具体类型定义的（但没有定义在接口中的）方法。

■　类型断言返回第二个bool值来表明断言是否成功。[插图][插图]

### 12 重新站起来：从失败中恢复

我们将向你展示如何延迟清理操作，以便在出现错误时也能执行这些操作。我们还将向你展示如何在适当的（罕见的）情况下使程序出现panic，以及如何在事后恢复。

### 从文件中读取数字，重新访问（续）

在我们的主函数中，通过访问os.Args[1]从第一个命令行参数获得要打开的文件的名称。（请记住，os.Args[0]元素是正在运行的程序的名称；实际的程序参数出现在os.Args[1]和后面的元素中。）

### 任何错误都将阻止关闭文件

但是这个返回发生在调用CloseFile之前，这意味着文件永远不会被关闭！

### 延迟函数调用

现在，关闭文件失败似乎没什么大不了的。对于一个只打开一个文件的简单程序来说，这可能没问题。但是，每个打开的文件都会继续消耗操作系统的资源。随着时间的推移，打开的多个文件可能会累积并导致程序失败，甚至影响整个系统的性能。当程序完成时，养成确保文件关闭的习惯是非常重要的。

如果你有一个无论如何希望确保运行的函数调用，都可以使用defer语句。你可以将defer关键字放在任何普通函数或方法调用之前，Go将延迟（也就是推迟）执行函数调用，直到当前函数退出之后。

### 使用延迟函数调用从错误中恢复

“defer”关键字通过使用return关键字确保函数调用发生，即使调用函数提前退出。

### 使用延迟函数调用确保文件关闭

因为defer关键字可以确保“无论如何”都执行函数调用，所以它通常用于需要运行的代码，即使在出现错误的情况下也是如此。一个常见的例子是在文件打开之后关闭它们。

### 代码贴（续）

：不行，只能延迟函数和方法调用。你可以编写一个函数或方法来做任何想要做的事情，然后延迟对该函数或方法的调用，但是defer关键字本身只能与函数或方法调用一起使用。

### 列出目录中的文件

io/ioutil包包含一个ReadDir函数，它允许我们读取目录内容。向ReadDir传递一个目录的名称，它将返回一个值切片，每个值切片对应目录包含的每个文件或子目录（以及遇到的任何错误）。每个切片的值都满足FileInfo接口，该接口包括一个返回文件名的Name方法和一个如果是目录则返回true的IsDir方法。

### 发起一个panic

程序出现panic时，当前函数停止运行，程序打印日志消息并崩溃。你可以通过简单地调用内置的panic函数来引发panic。[插图]

panic函数需要一个满足空接口的参数（也就是说，它可以是任何类型）。该参数将被转换为字符串（如果需要），并作为panic日志信息的一部分打印出来。

### 堆栈跟踪

堆栈跟踪每个被调用的函数都需要返回到调用它的函数。为了实现这一点，就像其他编程语言一样，Go保持一个调用堆栈，即在任何给定点上处于活动状态的函数调用的列表。当程序发生panic时，panic输出中包含堆栈跟踪，即调用堆栈列表。这对于确定导致程序崩溃的原因很有用。

### 延迟调用在崩溃前完成

当程序出现panic时，所有延迟的函数调用仍然会被执行。如果有多个延迟调用，它们的执行顺序将与被延迟的顺序相反。

### 何时产生panic

但事实上，调用panic并不是处理错误的理想方法，无法访问的文件、网络故障和错误的用户输入通常应该被认为是“正常的”，应该通过错误值来进行适当的处理。通常，调用panic应该留给“不可能的”情况：错误表示的是程序中的错误，而不是用户方面的错误。

### “recover”函数

但panic也会导致程序崩溃，出现难看的堆栈跟踪。我们宁愿只向用户显示错误信息。Go提供了一个内置的recover函数，可以阻止程序陷入panic。我们需要使用它来体面地退出程序。在正常程序执行过程中调用recover时，它只返回nil，而不执行其他操作：

### “recover”函数（续）

产生panic的函数将立即返回，而该函数块中panic之后的任何代码都不会执行。但是，在产生panic的函数返回之后，正常的执行将恢复。

### panic值从recover中返回

但是当出现panic时，recover返回传递给panic的任何值。这可以用来收集有关panic的信息，帮助恢复或向用户报告错误。

### panic值从recover中返回（续）

在介绍panic函数时，我们提到了其参数的类型是interface{}，即空接口，因此panic可以接受任何值。同样，recover的返回值的类型也是interface{}。你可以将recover的返回值传递给诸如Println（它接受interface{}值）之类的fmt函数，但是你不能直接对其调用方法。

下面是一些将error值传递给panic的代码。但是在这样做时，error被转换为一个interface{}值。当延迟的函数稍后调用recover时，返回的是interface{}值。因此，即使底层的error值有一个Error方法，试图调用interface{}值上的Error会导致编译错误。

### 从scanDirectory中的panic恢复

有了这些更改，我们的用户将只看到一条错误信息，而不是难看的panic日志和堆栈跟踪！

### 恢复panic

语言本身的设计不鼓励使用panic和recover。在2012年的一次主题会议上，Rob Pike（Go的创始人之一）把panic和recover描述为“故意笨拙”。这意味着，在设计Go时，创作者们没有试图使panic和recover被容易或愉快地使用，因此它们会很少使用。

这是Go设计者对exception的一个主要弱点的回应：它们可以使程序流程更加复杂。相反，Go开发人员被鼓励以处理程序其他部分的方式处理错误：使用if和return语句，以及error值。当然，直接在函数中处理错误会使函数的代码变长，但这比根本不处理错误要好得多。（Go的创始人发现，许多使用exception的开发人员只是抛出一个exception，之后并没有正确地处理它。）直接处理错误也使错误的处理方式一目了然——你不必查找程序的其他部分来查看错误处理代码。

### 你的Go工具箱

■　除非调用内置的recover函数，否则panic的程序将崩溃并显示日志信息。■　你可以将任何值作为参数传递给panic。该值将被转换为字符串并作为日志信息的一部分打印出来。■　panic日志信息包括堆栈跟踪，即所有活动的函数调用列表，这些对于调试非常有用。

　你可以将任何值作为参数传递给panic。该值将被转换为字符串并作为日志信息的一部分打印出来。■　panic日志信息包括堆栈跟踪，即所有活动的函数调用列表，这些对于调试非常有用。■　当程序陷入panic时，仍然会执行任何延迟的函数调用，从而允许在崩溃之前执行清理代码。

■　大多数程序只有在出现意料之外的错误时才会出现panic。你应该考虑程序可能遇到的所有错误（例如文件丢失或格式错误的数据），并使用error值来处理这些错误。

### 检索网页

我们将站点的URL传递给http.Get函数。它将返回一个http.Response对象，以及遇到的任何错误。
http.Response对象是一个struct，其Body字段表示页面的内容。Body满足io包的ReadCloser接口，这意味着它有一个Read方法（允许我们读取页面数据）和一个Close方法（在完成时释放网络连接）。

我们将响应体传递给ioutil包的ReadAll函数，该函数将读取其全部内容并将其作为byte值的切片返回。

byte类型，它是Go的基本类型（如float64或bool）之一，用于保存原始数据，比如你可能从文件或网络连接中读取的数据。如果直接打印byte值切片，它不会显示任何有意义的内容，但是如果将byte值切片转换为string，则会返回可读文本。

### 使用goroutine的并发性

如果一个程序是为了支持并发而编写的，那么它也可能支持并行：同时运行任务。一台只有一个处理器的计算机一次只能运行一个任务。但是现在大多数计算机都有多个处理器（或一个多核处理器）。你的计算机可能会在不同的处理器之间分配并发任务，以便同时运行它们。（很少直接管理这些情况，操作系统通常会为你进行处理。）

goroutine允许并发：暂停一个任务来处理其他任务。在某些情况下，它们允许并行：同时处理多个任务！

在Go中，并发任务称为goroutine。其他编程语言有一个类似的概念，叫作线程，但是goroutine比线程需要更少的计算机内存，启动和停止的时间更少，这意味着你可以同时运行更多的goroutine。

要启动另一个goroutine，可以使用go语句，它只是一个普通的函数或方法调用，前面有go关键字：

每个Go程序的main函数都是使用goroutine启动的，因此每个Go程序至少运行一个goroutine。你一直在使用goroutine，却不知道！

### 使用goroutine（续）

Go程序在main goroutine（调用main函数的goroutine）结束后立即停止运行，即使其他goroutine仍在运行。main函数在a和b函数中的代码运行之前就完成了。

在main函数中调用time.Sleep（time.Second）将导致main goroutine暂停1秒。

### 在responseSize函数中使用goroutine

调用time.Sleep（5*time.Second）将使goroutine休眠5秒钟。

### go语句不能使用返回值

go语句不能使用返回值
切换到goroutine带来了另一个需要解决的问题：我们不能在go语句中使用函数返回值。

### Go语句不能使用返回值（续）

channel不仅允许你将值从一个goroutine发送到另一个goroutine，还确保在接收的goroutine尝试使用该值之前，发送的goroutine已经发送了该值。
使用channel的唯一实际方法是从一个goroutine到另一个goroutine的通信。

要实际创建channel，你需要调用内置的make函数（与创建映射和切片的函数相同）。

不是单独声明channel变量，在大多数情况下，使用一个短变量声明更容易：
￼

### 同步goroutine与channel

channel还确保发送的goroutine在接收channel尝试使用该值之前已经发送了该值。channel通过blocking（阻塞）——暂停当前goroutine中的所有进一步操作来实现这一点。

### 更新我们的channel以携带一个struct

channel可以像携带基础类型一样轻松地携带切片、映射和struct等复合类型。我们可以创建一个struct类型，它将存储一个页面URL及其大小，这样就可以通过channel将两者一起发送。
我们将使用底层的struct类型声明一个新的Page类型。Page将有一个URL字段来记录页面的URL，以及一个Size字段来记录页面的大小。

### 你的Go工具箱

■　channel是通过调用内置的make函数创建的。
■　每个channel只携带一种特定类型的值，在创建channel时指定该类型。

myChannel := make(chan MyType)

### 编写测试

·测试函数名应该以Test开头。（名字的其余部分可以是你想要的任何内容，但它应该以大写字母开头。）
·测试函数应该接受单个参数：一个指向testing.T值的指针。

### 使用“Errorf”方法获得更详细的测试失败消息

测试函数的testing.T参数还有一个可以调用的Errorf方法。与Error不同，Errorf接受一个带格式化动词的字符串，就像fmt.Printf和fmt.Sprintf函数一样。你可以使用Errorf在测试的失败消息中包含其他信息，例如传递给函数的参数、得到的返回值和期望的值。

### 测试驱动开发

测试驱动开发
一旦有了一些单元测试的经验，你可能会进入一个被称为测试驱动开发的循环：
1.编写测试：为你想要的特性编写测试，即使它还不存在。然后运行测试以确保它失败。
2.确保通过：在main代码中实现该特性。不要担心你正在编写的代码是草率的还是低效的，你唯一的目标就是让它运作起来。然后运行测试以确保它通过。

自由地修改代码而不用担心代码被破坏是你需要单元测试的真正原因。任何时候，只要你看到一种使代码更短或更容易阅读的方法，你就要毫不犹豫地去做。当完成时，你可以简单地再次运行测试，你坚信一切都还在正常工作。

### 表驱动测试

不需要维护单独的测试函数，我们可以构建一个由输入数据和我们期望的相应输出组成的“表”，然后使用单个测试函数检查表中的每一项。
表没有标准格式，但是一个常见的解决方法是定义一个新类型，专门用于你的测试，它保存每个测试的输入和预期输出

### 表驱动测试（续）

更新后的代码更短，重复性更少，但是表中的测试通过了，就像它们是单独的测试函数一样！

### 使用测试修复panic代码

表驱动测试最好的一点是，当你需要新的测试时，很容易添加它们。假设我们不确定JoinWithCommas在传递给它一个空切片时它会有什么行为。为了找到答案，我们只需在tests切片中添加一个新的testData结构。我们将指定，如果将空切片传递给JoinWithCommas，则应返回一个空字符串：

### 使用测试修复panic代码（续）

如果phrases切片是空的，我们真的不应该试图访问它的任何元素。没有要连接的东西，所以我们所要做的就是返回一个空字符串。让我们在if语句中添加另一个子句，它在len（phrases）为0时返回一个空字符串。

### 你的Go工具箱

■　测试函数必须接受单个参数：一个指向testing.T值的指针。

■　表驱动测试是处理输入和预期输出的“表”的测试。它们将每一组输入传递给正在测试的代码，并检查代码的输出是否与预期值匹配。

### 讲解一个简单的Web应用程序

服务器向viewHandler传递一个http.ResponseWriter，用于向浏览器响应写入数据，以及一个指向http.Request值的指针，该值表示浏览器的请求。（我们不在这个程序中使用Request值，但是处理函数仍然必须接受一个。）

### 讲解一个简单的Web应用程序（续）

在viewHandler中，我们通过调用ResponseWriter上的Write方法向响应添加数据。Write不接受字符串，但它接受byte值的切片，因此我们将"Hello，web！"字符串转换为[]byte，然后将其传递给Write。

ResponseWriter的Write方法返回成功写入的字节数，以及遇到的任何错误。我们不能对写入的字节数做任何有用的事情，所以我们忽略它。但如果出现错误，我们会将其记录下来并退出程序。

### 一级函数

我们将函数本身传递给HandleFunc。该函数被存储起来，以便之后在接收到匹配的请求路径时调用。

在main函数中，我们声明了一个func（）类型的myFunction变量，这意味着该变量可以保存一个函数。

然后我们将sayHi函数本身赋值给myFunction。注意，我们没写括号—我们不写sayHi（）—因为这样做会调用sayHi。我们只输入函数名，如下所示：

### 函数作为类型（续）

函数作为类型（续）
函数的参数和返回值是其类型的一部分。保存函数的变量需要指定函数应该具有哪些参数和返回值。该变量只能保存参数的数量和类型以及返回值与指定类型匹配的函数。

我们定义一个类型为func（int，int）float64的变量mathFunction：它保存一个接受两个整型参数并返回一个float64值的函数。

### 函数作为类型（续）

与指定类型不匹配的函数不能传递给doMath。[插图]这就是为什么如果我们将错误的函数传递给http.HandleFunc，就会出现编译错误。HandleFunc期望传递一个函数，该函数接受一个ResponseWriter和一个指向Request的指针作为参数。传递任何其他内容，都会得到一个编译错误。

### 接下来是什么

我们将学习使用html/template包将数据插入到HTML中

### 你的Go工具箱

■　HandleFunc函数接受一个路径字符串，以及一个处理该路径请求的函数。■　你可以反复调用HandleFunc来为不同的路径设置不同的处理函数。■　处理函数必须接受一个http.ResponseWriter值和一个指向http.Request值的指针来作为参数。■　如果对使用byte的切片的http.ResponseWriter调用write方法，该数据将被添加到发送到浏览器的响应中。

　函数类型包括函数接受的参数的数量和类型（或没有），以及函数返回的值的数量和类型（或没有）。

### 16 要遵循的模式：HTML模板

你需要将数据插入HTML代码中。这就是Go提供html/template包的原因，这是一种在应用程序的HTML响应中包含数据的强大方法。模板是构建更大、更好的Web应用程序的关键

### 处理请求和检查错误的函数

我们不会将ListenAndServe的error返回值传递给check。这是因为ListenAndServe总是返回一个错误。（如果没有错误，ListenAndServe将永远不会返回。）因为我们知道这个错误永远不会是nil，所以我们只需立即对其调用log.Fatal。

### 使我们的应用程序以HTML响应

我们将调用template.ParseFiles函数，并将要加载的文件名"view.html"传递给它。这将使用view.html的内容创建一个Template值。ParseFiles将返回一个指向此Template的指针，也可能返回一个error值，我们将该值传递给check函数。

### “text/template”包

html/template包基于text/template包。使用这两个包的方法几乎完全相同，但是html/template有一些额外的安全特性，这是使用HTML所需要的。

### 使用带有模板的Execute方法的io.Writer接口

os.Stdout值是os包的一部分。Stdout代表“standard output（标准输出）”，它的作用类似于一个文件，但是任何写入它的数据都会输出到终端，而不是保存到磁盘。（如fmt.Println、fmt.Printf等函数在后台将数据写入os.Stdout。）

http.ResponseWriter和os.Stdout为何都是Template.Execute的有效参数？让我们看看它的文档……

嗯，这就是说Execute的第一个参数应该是io.Writer。那是什么意思？让我们看看io包的文档：[插图]io.Writer看起来像是一个接口！任何类型的Write方法都可以满足它的要求，该方法接受byte值的一个切片，并返回一个包含已写入字节数的整数和一个error值。

### 满足io.Writer的ResponseWriter和os.Stdout

这意味着http.ResponseWriter值和os.Stdout都满足io.Writer接口，并可以传递给Template值的Execute方法。Execute将通过对传递给它的任何值调用Write方法来写出模板。

### 使用action将数据插入模板

Template值的Execute方法的第二个参数允许你传入要插入到模板中的数据。它的类型是空接口，这意味着你可以传入任何类型的值。

要在模板中插入数据，可以向模板文本添加action（操作）。action用双花括号{{}}表示。在双花括号中，指定要插入的数据或要模板执行的操作。每当模板遇到action时，它将计算其内容，并在action的位置将结果插入模板文本中。

在一个操作中，你可以使用一个带有“dot”（点）的Execute方法来引用传递给它的数据值。

它会多次调用模板上的Execute，每次使用不同的数据值。在将结果写入os.Stdout之前，Execute使用数据值替换action。

### 使用“range”action来重复模板的某部分

在{{range}}action与其对应的{{end}}标记之间的模板部分，将对数组、切片、映射或channel中收集的每个值进行重复。该部分中的任何操作也将被重复。

### 使用action将struct字段插入模板

简单类型通常无法保存填写模板所需的各种信息。在执行模板时使用struct类型更为常见。

### 从文件中读入签名切片

其次，如果文件不存在，getStrings将只是返回nil来代替字符串切片，而不是报告错误。它通过把从os.Open获得的任何error值传递给os.IsNotExist函数来实现这一点，如果错误表示文件不存在，则返回true。

### 从文件中读入签名切片（续）

getStrings会返回nil？这不会导致显示模板时出现问题吗？答：没必要担心。正如我们在append函数中已经看到的，Go中的其他函数通常被设置为将nil切片和映射视为空。例如，如果向len函数传递了一个nil切片，它只返回0：

模板action也将nil切片和映射视为空。例如，我们已经知道，如果给{{range}}action一个nil值，{{range}}action就不会输出其内容。让getStrings返回nil而不是切片就可以了；如果没有从文件中加载到签名，模板将不会输出任何签名。

### 更新模板以包含签名

但这是因为html/template包自动“转义”了HTML，用代码替换了导致将其视为HTML的字符，从而使其出现在页面的文本中（在这种情况下它是无害的）。下面是实际插入响应中的内容：[插图][插图][插图]插入这样的脚本标记只是不道德的用户在网页中插入恶意代码的众多方法之一。html/template包可以很容易地防止这种攻击和许多其他的攻击！

### 用于表单提交的Path和HTTP方法

提交表单实际上需要向服务器发出两个请求：一个请求获取表单，另一个请求将用户的数据发送回服务器。让我们更新表单的HTML，以指定第二个请求应该发送到何处以及如何发送。

### 从请求中获取表单字段的值

让我们看看请求包含的数据。对http.Request调用FormValue方法，并将字符串"signature"传递给它。这将返回一个值为"signature"表单字段的字符串。将其存储在名为signature的变量中。

### 保存表单数据

Fprintln返回成功写入文件的字节数（我们忽略它），以及遇到的任何错误（我们将其传递给check函数）。

对要写入的文件调用Close可能会导致错误，并且这些错误需要进行处理，如果使用defer，我们无法立即处理这些错误。因此，我们只需简单地调用Close来作为常规程序流的一部分，然后将其返回值传递给check。

### 我们完整的应用程序代码

view.html文件提供了签名列表的HTML模板。模板action提供了插入签名数量以及整个签名列表的位置。

### 你的Go工具箱

■　Template值的Execute方法接受一个满足io.Writer接口的值，以及可以在模板的action中访问的数据值。■　模板action可以引用传递给使用{{.}}的Execute的数据值，简称“点”。点的值可以在模板的不同上下文中变化。

　可以使用http.Request值的FormValue方法访问来自请求的表单数据。■　可以使用http.Redirect函数来引导浏览器请求不同的路径。

### 理解os.OpenFile

在终端中运行go doc osOpenFile（或在浏览器中搜索"os"包文档）。

为了使本附录中的代码示例简短，假设所有程序都包含一个check函数，就像我们在第16章中展示的那样。它接受一个error值，检查它是否为nil，如果不是，则报告错误并退出程序。

### 将标志常量传递到os.OpenFile

os.O_RDONLY看起来是几个用于传递给os.OpenFile函数的int常量之一，它们会改变函数的行为。

### 按位与运算符

&运算符（只有一个&）是位运算符。只有当其左边值中的对应位和右边值中的对应位都为1时，它才会将位设置为1。对于数字0和1，只需要一位就可以表示，这是相当简单的：

### 对“os”包常量使用按位或运算

这意味着我们可以将这些值与按位或运算符组合在一起，并且任何位都不会相互干扰：

在代码中只使用常量名，不要使用它们的int值！如果在代码中使用像1和1024这样的值来代替常量，那么可能在短期内没问题。但是，如果Go的维护人员修改了常量的值，那么代码就会崩溃。确保使用像os.O_WRONLY和os.O_APPEND这样的常量名，这样你就安全了。

### 使用按位或运算修复os.OpenFile选项

当我们只将os.O_WRONLY选项传递给os.OpenFile时，它会重写文件中已经存在的部分数据。让我们看看是否可以组合选项，以便将新数据追加到文件末尾。

使用按位或运算符将os.O_WRONLY和os.O_APPEND常量值合并为一个值。

### Unix样式的文件权限

我们一直在关注os.OpenFile的第二个参数，它控制读、写、创建和追加文件。到目前为止，我们一直忽略第三个参数，它控制文件的权限：在程序创建文件后，哪些用户将被允许读取和写入该文件。

Windows不像类Unix系统那样处理文件权限，所以无论你做什么，都将在Windows上使用默认权限创建文件。但是，同样的程序在运行于类Unix机器上时不会忽略权限参数。熟悉权限的工作原理非常重要，如果可能的话，还要在希望运行的各种操作系统上测试程序。

### 使用os.FileMode类型表示权限

Go的os包使用FileMode类型表示文件权限。如果文件不存在，则传递给os.OpenFile的FileMode将决定使用什么权限创建文件，因此决定了用户对文件具有什么样的访问权限。

每个文件有三组权限，影响三个不同类别的用户。第一组权限仅适用于拥有该文件的用户。（默认情况下，你的用户账户是你创建的任何文件的所有者。）第二组权限用于分配给该文件的用户组。第三组适用于系统上的其他用户，这些用户既不是文件所有者，也不是文件分配组的一部分。

### #1 “if”的初始化语句

它也使用了一个err变量。我们必须记住，在第一次使用err时使用一个短变量声明，以后更改为使用赋值。否则，我们将得到一个编译错误，说试图重新声明一个变量。

第一次介绍for循环吗？我们说过它们可以包含一个初始化语句，你可以在这里初始化变量。这些变量只在for循环块的作用域内。

### #1“if”的初始化语句（续）

与for循环类似，Go允许你在if语句中的条件之前添加初始化语句。初始化语句通常用于初始化一个或多个变量，以便在if块中使用。

初始化语句中声明的变量的作用域仅限于if语句的条件表达式及其块。如果我们重写前面的示例以使用if初始化语句，则每个err变量的作用域将被限制在if语句的条件和块中，这意味着我们将有两个完全独立的err变量。我们不用担心哪一个先被定义。

这种对作用域的限制是双向的。如果一个函数有多个返回值，而你需要其中一个在if语句中，另一个在if语句外，那么你可能无法在if初始化语句中调用它。如果你试一下，你将会发现你所需要的在if块之外的值超出了作用域。

### #4 更多关于符文的信息

Unicode标准试图创建一组4字节的值，这些值可以表示这些不同书写系统中的每个字符（以及许多其他字符）。Go使用rune类型的值来表示Unicode值。通常，一个符文代表一个字符。（当然也有例外，但这些超出了本书的范围。）

### #4更多关于符文的信息（续）

Go使用UTF-8，这是一种表示Unicode字符的标准，每个字符使用1到4个字节。旧ASCII字符集中的字符仍然可以用一个字节表示；其他字符可能需要2到4个字节。

当你将字符串传递给len函数时，它将返回以字节（而不是符文）为单位的长度。英文字母串可以占用5个字节——每个符文只需要1个字节，因为它来自旧的ASCII字符集。但是俄文字符串需要10个字节——每个符文需要2个字节来存储。如果需要字符串的字符长度，则应该使用unicode/utf8包的RuneCountInString函数。此函数将返回正确的字符数，而不考虑用于存储每个字符的字节数。

### #4更多关于符文的信息（续）

我们必须将字符串转换为字节切片，以便将它们写入HTTP响应或终端。只要确保在结果切片中写入所有字节，这样就可以正常工作。但是，如果只想处理部分字节，那就麻烦了。

这对英文字母表字符很有用，每个字符占用1个字节。但是俄文字符每个都占2个字节。切断该字符串的前3个字节只会忽略第一个字符和第二个字符的“一半”，从而导致无法打印字符。Go支持将字符串转换为rune值的切片，并将符文切片转换回字符串。要使用部分字符串，应该将它们转换为rune值的切片，而不是byte值的切片。这样，你就不会意外地抓取符文的部分字节。

它将字符串转换为符文切片而不是字节切片。我们的切片运算符现在省略了每个切片的前三个符文，而不是前3个字节。

### #4更多关于符文的信息（续）

这段代码使用for...range循环打印英文字符，每个字符1字节。然后，它尝试对俄文字符做同样的操作，每个字符1个字节——但是失败了，因为每个字符都需要2个字节。

Go允许你对字符串使用for...range循环，它一次处理一个符文，而不是一个字节。这是一种更安全的方法。你提供的第一个变量将被分配给字符串中的当前字节索引（而不是rune索引）。第二个变量将被分配给当前的符文。

个for...range循环来处理字符串本身，而不是它们的字节表示。你可以从输出中的索引中看到，对英文字符一次处理1个字节，但是对俄文字符一次处理2个字节。

### #5 有缓冲的channel

当goroutine在无缓冲的channel上发送值时，它会立即阻塞，直到另一个goroutine接收到该值。另一方面，有缓冲的channel可以在导致发送的goroutine阻塞之前保存一定数量的值。在适当的情况下，这可以提高程序的性能。在创建channel时，可以通过给make传递第二个参数来创建有缓冲的channel，该参数包含channel应该能够在其缓冲区中保存的值的数量。

当goroutine通过channel发送一个值时，该值被添加到缓冲区中。发送的goroutine将继续运行，而不被阻塞。[插图][插图]

发送的goroutine可以继续在channel上发送值，直到缓冲区被填满；只有这时，额外的发送操作才会导致goroutine阻塞。

### #6 进一步阅读

https://headfirstgo.com/

A Tour of Gohttps://tour.golang.org

The Go Bloghttps://blog.golang.org官方的Go博客。提供有关使用Go以及新的Go版本和功能的公告的有用文章。

The Go Programming Languagehttps://www.gopl.io/

### 索引

log包错误处理和log包96Fatal函数38，447