## UNIX编程艺术
> 埃瑞克·S·理曼德

### 内容简介

本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验

### 序

如果你是个初级或者中级水平的 Unix 用户，但是没什么开发经验，想学习在 Unix下如何高效地设计软件时，可以看看这本书。

### 1 哲学

Unix并不承诺让你免遭此劫，只是让你的知识投资更趋稳定。因为不变的东西有很多：语言、系统调用、工具用法——它们积年不变，甚至可以用上数十载。而在其它操作系统中则无法预判什么东西会持久不变，有时候甚至整个操作系统都会被淘汰。在Unix中，持久性知识和短期性知识有着明显的区别，人们在一开始学习的时候，就能提前判断（命中率约有九成）要学的知识属于哪一类。这些便是Unix有众多忠实拥趸的原因。

Unix API几乎就可以作为编写真正可移植软件的硬件无关标准。难怪最初IEEE称之为 “可移植操作系统标准”（Portable Operating System Standard）的POS很快就被大家加了后缀变成了“POSIX”[译注：缩写为 POSIX 是为了读音更像 Unix]。确实，只有称之为Unix API的等价物才能算是这种标准比较可信的模型。

Unix提供众多的程序粘合手段，这意味着Unix基本工具箱的各种组件连纵开合后，将收到单个工具设计者无法想象的功效。

Unix管道的发明人、Unix传统的奠基人之一Doug McIlroy在[McIlroy78]中曾经说过：（i）让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。

（ⅲ）尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。

Unix哲学是这样的：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。

3.组合原则：设计时考虑拼接组合。

11.缄默原则：如果一个程序没什么好说的，就沉默。
12.补救原则：出现异常时，马上退出并给出足够错误信息。

“计算机编程的本质就是控制复杂度”[Kernighan-Plauger]。排错占用了大部分的开发时间，弄出一个拿得出手的可用系统，通常与其说出自才华横溢的设计成果，还不如说是跌跌撞撞的结果。

要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度——用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。

在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。

在输入输出方面，Unix传统极力提倡采用简单、文本化、面向流、设备无关的格式。在经典的Unix下，多数程序都尽可能采用简单过滤器的形式，即将一个输入的简单文本流处理为一个简单的文本流输出。

Unix中，文本流之于工具，就如同在面向对象环境中的消息之于对象。文本流界面的简洁性加强了工具的封装性。而许多精致的进程间通讯方法，比如远程过程调用，都存在牵扯过多各程序间内部状态的倾向。

● 只要可行，一切都应该做成与来源和目标无关的过滤器。
● 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。
● 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。
● 复杂的前端（用户界面）和后端应该泾渭分明。
● 如果可能，用C编写前，先用解释性语言搭建原型。

### 2 历史——双流记

忘记过去的人，注定要重蹈覆辙。

95年，Linux找到了自己的杀手级应用——开源的web服务器Apache。就像Linux，Apache出众地稳定和高效。很快，运行Apache的Linux机器成了全球ISP平台的首选。约60%!的(MISSING)网站选用Apache，[8]轻松击败了另两个主要的专有型竞争对手。

另一个教训是：别和低价而灵活的方案较劲。或者，换句话说，低档的硬件只要数量足够，就能爬上性能曲线而最终获胜。

Unix要繁荣，就必须继续采用吸纳低价而灵活的方案的诀窍，而不是去反对它们。

### 3 对比：Unix哲学同其他哲学的比较

Unix系统拥有抢先式多任务（preemptive multitasking）能力。在Unix中，时间片由调度程序来分配，这个调度程序定期中断或抢断正在运行的进程而把控制权交给下一个进程。几乎所有的现代操作系统都支持抢占式调度。

管道和所有其他经典Unix IPC方法有一个精微的性质，就是要求把程序间的通讯简化到某一程度而促使功能分离。相反地，如果没有与管道等效的机制，则程序必须在完全相互了解对方内部细节的基础上设计程序，才能实现彼此间的合作。

Unix中，一组程序设计时不仅要尽量考虑相互协作，而且要考虑和未知程序的协作。

Unix开创了轻松编程的先河。Unix的众多首创之一就是将编译器和脚本工具放在默认安装中，可供所有用户使用，支持了一种跨越众多机器的玩家开发文化。在很多Unix下写代码的人并不认为自己在写代码——他们认为是在为普通任务的自动化编写脚本，或在定制环境。

● 随着时间的推移，CLI越来越被忽略了，原因是环境稀缺。薄弱CLI引起的问题不仅没有得到改善，反而越来越糟糕。（Windows Server 2003试图稍稍扭转这种趋势。）

### 4 模块性：保持清晰，保持简洁

Modularity:Keeping lt Clean,Keeping lt Simple

### 5 文本化：好协议产生好实践

管道和套接字既可以传输文本也可以传输二进制数据。但是，我们将在第 7 章看到的例子却都是文本化的，理由非常充分：那就是我们在第1章引用的Doug McIlroy的建议。文本流是非常有用的通用格式，因为人无需专门工具就可以很容易地读写和编辑文本流，这些格式是透明的（或可以设计成透明的）。

### 7 多道程序设计：分离进程为独立的功能

Multiprogramming:Separating Processes to Separate Function

### 10 配置：迈出正确的第一步

传统上，一个Unix程序可以在启动环境的五个地方寻找控制信息：
●/etc下的运行控制文件（或者系统中其它固有位置）。
● 由系统设置的环境变量。
● 用户主目录中的运行控制文件（或“点文件”）。（如果不熟悉，请参考第 3章对这个重要概念的讨论。）
● 由用户设置的环境变量。
● 启动程序的命令行所传递的开关和参数。

-e
执行（execute）（带参数）。

e偶尔具有“排除（exclude）”或“表达（expression）”的含义。

-q
安静 （quite）（通常不带参数）。禁

递归（recurse）（不带参数）。如果一个程序作用于目录，那么这个选项可告诉程序递归进所有子目录。在对目录作用的程序中这个选项具有其它用法非常让人意外。经典的例子当然是cp（1）了。
反向（reverse）（不带参数）。示例：ls（1）和 sort（1）。过滤器可用这个选项反向进行其正常的转换行为（比较-d选项）。

冗长（verbose）（带或不带参数）。用于启用事务监控性质的、更冗长的列表或调试输出。示例：cat（1）、cp（1）、flex（1）、tar（1）和很多其它程序。

### 14 语言：C还是非C

复杂的shell脚本经常产生可移植性问题，主要原因并不在于shell本身而在于shell使用了某些它假定存在的程序。尽管偶尔可在非 Unix 操作系统中发现 Bourne 和 Korn shell变种，shell程序（实际上）根本无法移植到Unix之外。


总结：shell 的最佳之处在于书写小型脚本非常自然快捷。最糟之处在于大型 shell脚本必须依靠大量辅助命令，而这些辅助命令不一定在所有目标机器上都表现一致甚至不一定存在。要在大型shell脚本中分析依赖关系并不容易。

Perl是增强了的shell。它为代替awk（1）而专门设计，并扩展用来代替shell 作为混合语言脚本编程的“胶合剂”使用。Perl首次发布于1987年。
Perl 最强功能是其内置的对文本、面向行的数据格式进行模式导向的处理功能。比起shell，Perl包含更加强大的数据结构，包括混合元素类型的动态数组和支持名-值对的、查找方便迅捷的散列（字典）类型。

### 15 工具：开发的战术

vi这个名字是“visual editor （可视编辑器）”的缩写，发音为/vee eye/（不是/vie/并且绝对不是/siks/！）。

### 16 重用：论不要重新发明轮子

大多数都可以使用标准工具在几分钟内编译并运行起来。只要念个咒：./configure；make；make install；当然，通常情况下必须在root用户下才能做安装部分的操作。

### 17 可移植性：软件可移植性与遵循标准

17.5.1.3 Shell的可移植性
很不幸，shell脚本的可移植性非常糟。问题不在shell本身；bash（1）（开源的Bourne Again shell）已经普遍存在，所以纯shell脚本几乎可以到处运行。问题是大多数的shell脚本大量使用了其它可移植性差的命令和过滤器，而且绝不保证在任意指定的机器上它们都存在。

所以大多数在shell中稍重量级的编程都转移到诸如Perl、Python、Tcl等第二代脚本语言中完成。

17.5.1.5 Python的可移植性
Python可移植性极其出色。如同Perl一样，Python的主干版本甚至提供一个Tk包的可移植接口，可支持Unix、MacOS和Windows的GUI。

### 19 开放源码：在Unix新社区中编程

假设正好有个叫做“foobar”的项目，主版本号为1，次版本号或发布号为2，补丁级别为3。如果只有一个档案部分（假定为源代码），则文件名称看起来应该像这样：
foobar-1.2.3.tar.gz

foo_bar-1.2.3.tar.gz
下划线给人们带来发音、打字和记忆的困难。

### 20 未来：危机与机遇

Futures:Dangers and Opportunities

The best way to predict the future is to invent it.
预测未来最好的方法就是去创造未来。